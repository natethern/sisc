(define (opt:optimize e)
  (let-values ([(rv state) (opt e (scan e))])
    rv))

(define opt
  (lambda (e state)
    (match e
      (,x
       (guard (symbol? x))
       (opt:ref x state))
      ((quote ,x) 
       (guard (core-form-not-redefined? 'quote))
       (values `(quote ,x) (new-state)))
      ((begin ,[exp1 exp1-state] ,[exps* exps-state*] ...)
       (guard (core-form-not-redefined? 'begin))
       (let-values ([(rv state) (opt:begin exp1 exps* state)])
         (values rv (merge-states state exp1-state 
                                  (apply merge-states exps-state*)))))
      ((if ,[test test-state] ,[conseq conseq-state] ,[altern altern-state])
       (guard (core-form-not-redefined? 'if))
       (let-values ([(rv state) (opt:if test conseq altern state)])
         (values rv (merge-states state test-state conseq-state altern-state))))
      ;; Lets
      (((lambda ,formals ,body) ,[values* values-state*] ...)
       (guard (and (core-form-not-redefined? 'lambda)                    
		   (list? formals)))
       (if (= (length formals) (length values*))
           (let-values ([(rv state) (opt:let formals values* body state)])
             (values rv (merge-states state (apply merge-states values-state*))))
           (let-values ([(body state) (opt body state)])
             (values `((lambda ,formals ,body) ,@values*)
                     values-state*))))
      ((lambda ,formals ,body)
       (guard (core-form-not-redefined? 'lambda))
       (opt:lambda formals body state))
      ((letrec ((,lhs* ,[rhs* rhs-state*]) ...) ,body)
       (guard (core-form-not-redefined? 'letrec))
       (let-values ([(rv state) (opt:letrec lhs* rhs* body state)])
         (values rv (merge-states state (apply merge-states rhs-state*)))))
      ((define ,lhs ,[rhs rhs-state])
       (guard (core-form-not-redefined? 'define))
       (values `(define ,lhs ,rhs) rhs-state))
      ((set! ,formal ,[value vstate])
       (guard (core-form-not-redefined? 'set!))
       (let-values ([(rv state) (opt:set! formal value state)])
         (values rv (merge-states state vstate))))     
      ((compile-in-annotation ,[expr expr-state] ,annotation)
       (values `(compile-in-annotation ,expr ,annotation)
               expr-state))
      ((,[rator rator-state] ,[rands* rands-state*] ...)
       (let-values ([(rv state) (opt:application rator rands* state)])
         (values rv (merge-states state rator-state 
                                  (apply merge-states rands-state*)))))
      (,other (error 'optimizer "Unrecognized s-expression: ~a" other)))))

(define (scan expr)
  (match expr
    (,x 
     (guard (symbol? x))
     `((refed-vars ,x)))
    ((quote ,x) 
     (guard (core-form-not-redefined? 'quote))
     (new-state))
    ((begin ,[exp1] ,[exps*] ...)
     (guard (core-form-not-redefined? 'begin))
     (merge-states exp1 (apply merge-states exps*)))
    ((if ,[test] ,[conseq] ,[altern])
     (guard (core-form-not-redefined? 'if))
     (merge-states test conseq altern))
    (((lambda ,formals ,[body]) ,[values*] ...)
     (guard (core-form-not-redefined? 'lambda))
     (merge-states body (apply merge-states values*)))
    ((lambda ,formals ,[body]) 
     (guard (core-form-not-redefined? 'lambda))
     body)
    ((letrec ((,lhs* ,[rhs*]) ...) ,[body])
     (guard (core-form-not-redefined? 'letrec))
     (merge-states (apply merge-states rhs*) body))
    ((define ,lhs ,[rhs]) 
     (guard (core-form-not-redefined? 'define))
     rhs)
    ((set! ,formal ,[value]) 
     (guard (core-form-not-redefined? 'set!))
     (union-state-entry
      (union-state-entry value 'set-vars formal)
      'refed-vars formal))
    ((compile-in-annotation ,[expr] ,annotation) expr)
    ((,[rator] ,[rands*] ...)
     (merge-states rator (apply merge-states rands*)))
    (,other (error 'optimizer "Unrecognized s-expression: ~a" other))))

