(define (opt:optimize e)
  (mvlet ([(rv state) (opt e (scan e))])
    rv))

(define (opt e state)
  (match e
    ((quote ,x) (values `(quote ,x) (new-state)))
    (,x
     (guard (symbol? x))
     (opt:ref x state))
    ((begin ,[exp1 exp1-state] ,[exps* exps-state*] ...)
     (mvlet ([(rv state) (opt:begin exp1 exps* state)])
       (values rv (merge-states state exp1-state 
                                (apply merge-states exps-state*)))))
    ; Lets
    (((lambda ,formals ,body) ,[values* values-state*] ...)
     (mvlet ([(rv state) (opt:let formals values* body state)])
       (values rv (merge-states state (apply merge-states values-state*)))))
    ((letrec ((,lhs* ,[rhs* rhs-state*]) ...) ,body)
     (mvlet ([(rv state) (opt:letrec lhs* rhs* body state)])
       (values rv (merge-states state (apply merge-states rhs-state*)))))
    ((lambda ,formals ,body)
     (opt:lambda formals body state))
    ((set! ,formal ,[value vstate])
     (mvlet ([(rv state) (opt:set! formal value state)])
       (values rv (merge-states state vstate))))     
    ((define ,lhs ,[rhs rhs-state])
     (values `(define ,lhs ,rhs) rhs-state))
    ((if ,[test test-state] ,[conseq conseq-state] ,[altern altern-state])
     (mvlet ([(rv state) (opt:if test conseq altern state)])
       (values rv (merge-states state test-state conseq-state altern-state))))
    ((compile-in-annotations ,[expr expr-state] ,annotation)
     (values `(compile-in-annotations ,expr ,annotation)
             expr-state))
    ((,[rator rator-state] ,[rands* rands-state*] ...)
     (mvlet ([(rv state) (opt:application rator rands* state)])
       (values rv (merge-states state rator-state 
                                (apply merge-states rands-state*)))))
    (,other (values other (new-state)))))

(define scan
  (lambda (expr)
    (match expr
      ((quote ,x) (new-state))
      (,x
       (guard (symbol? x))
       (new-state))
      ((begin ,[exp1] ,[exps*] ...)
       (merge-states exp1 (apply merge-states exps*)))
      (((lambda ,formals ,[body]) ,[values*] ...)
       (merge-states body (apply merge-states values*)))
      ((letrec ((,lhs* ,[rhs*]) ...) ,[body])
       (merge-states (apply merge-states rhs*) body))
      ((lambda ,formals ,[body]) body)
      ((set! ,formal ,[value]) 
       (union-state-entry value 'set-vars formal))
      ((define ,lhs ,[rhs]) rhs)
      ((if ,[test] ,[conseq] ,[altern])
       (merge-states test conseq altern))
      ((compile-in-annotations ,[expr] ,annotation) expr)
      ((,[rator] ,[rands*] ...)
       (merge-states rator (apply merge-states rands*)))
      (,other (new-state)))))