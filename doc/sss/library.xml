<chapter id="LibraryFunctions">
  <title>
    Additional Libraries
  </title>
  <sect1 id="SISCLibs">
    <title>Optional &SISC; Libraries</title>
    <para>
      The optional &SISC; libraries are
      <link linkend="Modules">modules</link>
      whose definition is included in the full &SISC; distribution,
      but not the lite distribution.
    </para>
    <sect2 id="BitwiseLogicalOperations">
      <title>
        Bitwise Logical Operations
      </title>
      <para>
        &requires; 
        <emphasis role="bold">
          (import <emphasis>logicops</emphasis>)
        </emphasis>
      </para>
      <para>
        In addition to the &R5RS; set of procedures that deal with
        numbers, &SISC; provides operators for performing bitwise
        logic operations on a limited range of integers.  The domain of the
        logical operators are exact real integers of the range
        -2,147,483,648 to 2,147,483,647 inclusive.  An error is raised
        if the logical operators are applied to integers outside this
        range, to a non-integer, or a non-real.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>logand</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>logand</methodname>
              <methodparam><parameter>integer</parameter>
              </methodparam>
              <methodparam choice="opt" rep="repeat">
                <parameter>integer</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Performs the logical AND of all the provided arguments.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>logor</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>logor</methodname>
              <methodparam><parameter>integer</parameter>
              </methodparam>
              <methodparam choice="opt" rep="repeat">
                <parameter>integer</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Performs the logical OR of all the provided arguments.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>logxor</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>logxor</methodname>
              <methodparam><parameter>integer</parameter>
              </methodparam>
              <methodparam choice="opt" rep="repeat">
                <parameter>integer</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Performs the logical exclusive-OR of all the provided arguments.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>lognot</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>lognot</methodname>
              <methodparam><parameter>integer</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Performs the logical NOT of the provided integer.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        In addition, two operators are provided to perform arithmetic
        shifts on any integer (these operators do not have the range
        limitation the previous logical functions do).  The shift
        operators return a newly generated number formed by shifting
        the provided number left or right by the given number of bits.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>ashl</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>ashl</methodname>
              <methodparam><parameter>integer</parameter></methodparam>
              <methodparam><parameter>bits</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Arithmetically shifts <parameter>integer</parameter>
                left by <parameter>bits</parameter> bits.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>ashr</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>ashr</methodname>
              <methodparam><parameter>integer</parameter></methodparam>
              <methodparam><parameter>bits</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Arithmetically shifts <parameter>integer</parameter>
                right by <parameter>bits</parameter> bits.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        Mathematically, if r is the number, and s is the number of
        bits, ashl calculates:
        
        <programlisting>
r x 2<superscript>s</superscript>
        </programlisting>
        while ashr calculates
        <programlisting>
r / 2<superscript>s</superscript>
        </programlisting>
        in the integer domain.  Both ashl and ashr operate on exact
        integers and produce only exact integers.  
      </para>
    </sect2>
    <sect2 id="Hashtables">
      <title>Hash Tables</title>
      <para>
          &requires; 
        <emphasis role="bold">
          (import <emphasis>hashtable</emphasis>)
        </emphasis>
      </para>
      <para>
        Hash tables store mappings of keys to values. Hence they are
        similar to association lists, except that hash tables allow
        retrieval, addition and modification in constant time whereas
        association lists typically perform these operations in linear
        time based on the number of elements.
      </para>
      <para>
          &SISC; hash tables are thread-safe, i.e. multiple threads can
        concurrently access and modify the same hash table.
      </para>
      <sect3>
        <title>Creation</title>
        <para>
          Hash tables are a distinct data type. They can be created
          empty or filled with the contents of an association list. The
          converse, creating an association list from a hash table, is
          also supported.
        </para>
        <blockquote>
          <para>
            <indexterm><primary>make-hashtable</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>hashtable</type>
              <methodname>make-hashtable</methodname>
              <methodparam choice="opt">
                <parameter>eq?/eqv?/equal?</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a hash table. The optional argument supplies
                the equality test procedure that the hashtable should
                use. It must be one of <function>eq?</function>,
                <function>eqv?</function>, or
                <function>equal?</function>.
              </para>
              <para>
                  The keys of hash tables using
                  <function>equal?</function> must not be mutated.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>hashtable?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a hash
                table, &num;f otherwise.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable/size</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>number</type>
              <methodname>hashtable/size</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the number of key/value pairs stored in
                <parameter>hashtable</parameter>.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>alist-&gt;hashtable</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>hashtable</type>
              <methodname>alist-&gt;hashtable</methodname>
              <methodparam><parameter>alist</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a hashtable and initializes it with the keys and
                values found in
                <parameter>alist</parameter>. <parameter>alist</parameter>
                must be a list of pairs, with the <function>car</function>
                of each pair representing a key and the
                <function>cdr</function> representing its associated
                value. If there are multiple pairs which contain the
                same key (with respect to <function>eqv?</function>)
                then the resulting hash table will associate the key
                with the value of the last such pair.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable-&gt;alist</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>alist</type>
              <methodname>hashtable-&gt;alist</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns an association list comprising the elements of
                <parameter>hashtable</parameter>. The list contains
                pairs whose <function>car</function>s are they keys
                found in <parameter>hashtable</parameter> and whose
                <function>cdr</function>s contain the associated
                values.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Access</title>
        <para>
          All hash table access operations follow a similar
          pattern. They return the value that was associated with the
          the given key at the time the operation was invoked. If no
          binding for the key existed, an optionally supplied value is
          returned that defaults to &num;f. This allows the programmer
          to associate keys with &num;f values and distinguish this case
          from not having any association for a key.
        </para>
        <blockquote>
          <para>
            <indexterm><primary>hashtable/put!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>hashtable/put!</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
              <methodparam><parameter>key</parameter></methodparam>
              <methodparam><parameter>val</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>nobinding</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Associates <parameter>key</parameter> with
                <parameter>val</parameter> in
                <parameter>hashtable</parameter>. Returns the previous
                association of <parameter>key</parameter> or
                <parameter>nobinding</parameter>, which defaults to
                &num;f, if <parameter>key</parameter> has no previous
                association.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable/get</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>hashtable/get</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
              <methodparam><parameter>key</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>nobinding</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the value associated with
                <parameter>key</parameter> in
                <parameter>hashtable</parameter>, or
                <parameter>nobinding</parameter>, which defaults to
                &num;f, if <parameter>key</parameter> has no
                association.
              </para>
            </blockquote>
          </para>
          <para>    
            <indexterm><primary>hashtable/get!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>hashtable/get!</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
              <methodparam><parameter>key</parameter></methodparam>
              <methodparam><parameter>thunk</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the value associated with
                <parameter>key</parameter> in
                <parameter>hashtable</parameter>. If
                <parameter>key</parameter> has no association then
                <parameter>thunk</parameter> is evaluated and the result
                is associated with <parameter>key</parameter> in
                <parameter>hashtable</parameter> and also returned.  The
                <parameter>nobinding</parameter> argument, which
                defaults to &num;f, denotes the value indicating an
                unassociated key.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable/remove!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>hashtable/remove!</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
              <methodparam><parameter>key</parameter></methodparam>
              <methodparam><parameter>val</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>nobinding</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Removes the association of <parameter>key</parameter> in
                <parameter>hashtable</parameter>. Returns the associated
                value of <parameter>key</parameter> or
                <parameter>nobinding</parameter>, which defaults to
                &num;f, if <parameter>key</parameter> has no
                association.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          Hash tables can be invoked as procedures. This provides
          convenient short-cuts for the very common
          <function>hashtable/get</function> and
          <function>hashtable/put!</function> operations:
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname></methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
              <methodparam><parameter>key</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>val</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                If <parameter>val</parameter> is present, then this is
                equivalent to calling <literal>(hashtable/put!</literal>
                <parameter>hashtable</parameter>
                <parameter>key</parameter>
                <parameter>value</parameter><literal>)</literal>,
                otherwise <literal>(hashtable/get</literal>
                <parameter>hashtable</parameter>
                <parameter>key</parameter><literal>)</literal>.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Bulk Operations</title>
        <para>
          Bulk operations are operations that apply to all elements of a
          hash table.
        </para>
        <blockquote>
          <para>
            <indexterm><primary>hashtable/clear!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>hashtable/clear!</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Removes all elements from <parameter>hashtable</parameter>.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable/keys</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>hashtable/keys</methodname>
              <methodparam><parameter>hashtable</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the keys contained in <parameter>hashtable</parameter>.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable/for-each</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>hashtable/for-each</methodname>
              <methodparam><parameter>thunk</parameter></methodparam>
              <methodparam><parameter>hashtable</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Applies <parameter>thunk</parameter> to each element of
                <parameter>hashtable</parameter>. <parameter>thunk</parameter>
                is invoked with two parameters - the key and the value
                of the element.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>hashtable/map</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>hashtable/map</methodname>
              <methodparam><parameter>thunk</parameter></methodparam>
              <methodparam><parameter>hashtable</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Applies <parameter>thunk</parameter> to each element of
                <parameter>hashtable</parameter>. <parameter>thunk</parameter>
                is invoked with two parameters - the key and the value
                of the element. The results of evaluating
                <parameter>thunk</parameter> are returned as a list.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
    </sect2>
    <sect2 id="Buffers"> 
      <title>Binary Buffers</title>
      <para>
          &requires; 
        <emphasis role="bold">
          (import <emphasis>buffers</emphasis>)
        </emphasis>
      </para>
      <para>
        Binary buffers provide an opaque container for a fixed amount
        of binary data.  The binary buffer library provides a number 
        of functions for creating and accessing those buffers.  
        The buffer is very similar to a vector, in
        that it is a randomly accessable, zero-based structure.  But as
        a tradeoff for space efficiency, binary 
        buffers are only capable of storing bytes.  The bytes are stored
        as 8-bit, unsigned fixed integers (of the range 0-255).
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>buffer?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>buffer?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns true if and only if the provided argument is a
                binary buffer.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>make-buffer</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>buffer</type>
              <methodname>make-buffer</methodname>
              <methodparam><parameter>size</parameter></methodparam>
              <methodparam choice="opt"><parameter>fill-value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new buffer capable of storing
                <parameter>size</parameter> bytes.
                <parameter>size</parameter> must be a fixed
                non-negative integer.  If provided, the value of all
                bytes in the buffer is initialized to
                <parameter>fill-value</parameter>.  If not provided,
                the contents of the buffer is unspecified.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>buffer</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>buffer</type>
              <methodname>buffer</methodname>
              <methodparam choice="opt" rep="repeat">
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new buffer whose size is equal to
                the number of arguments given and whose contents are
                the bytes given as arguments.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>buffer-length</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>fixed integer</type>
              <methodname>buffer-length</methodname>
              <methodparam><parameter>buffer</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the capacity of the given buffer.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>buffer-ref</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>fixed integer</type>
              <methodname>buffer-ref</methodname>
              <methodparam><parameter>buffer</parameter></methodparam>
              <methodparam><parameter>index</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the byte at offset
                <parameter>index</parameter> in the specified buffer.
                It is an error if <parameter>index</parameter> is out
                of range.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>buffer-set!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>buffer-set!</methodname>
              <methodparam><parameter>buffer</parameter></methodparam>
              <methodparam><parameter>index</parameter>
              </methodparam>
              <methodparam><parameter>new-value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Sets the byte at offset <parameter>index</parameter>
                of the specified buffer to the given fixed integer
                <parameter>new-value</parameter>.
                It is an error if <parameter>index</parameter> is out
                of range.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>buffer-copy!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>buffer-copy!</methodname>
              <methodparam><parameter>source-buffer</parameter></methodparam>
              <methodparam><parameter>source-offset</parameter>
              </methodparam>
              <methodparam><parameter>dest-buffer</parameter>
              </methodparam>
              <methodparam><parameter>dest-offset</parameter>
              </methodparam>
              <methodparam choice="opt"><parameter>count</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Copies <parameter>count</parameter> bytes starting from index
                <parameter>source-offset</parameter> in the source
                buffer to successive bytes starting at index
                <parameter>dest-offset</parameter> in the destination
                buffer.  If <parameter>count</parameter> is
                unspecified, it is assumed to be the length of the
                source buffer.
                It is an error to copy more bytes from the source
                buffer than are available, or to copy more bytes into
                the destination buffer than its capacity allows.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        Buffers are serializable (can exist in loadable libraries or
        a &SISC; heap), but are not representable in an s-expression.  
        For this reason, they bear the printed representation of
        <literal>&num;&lt;buffer&gt;</literal>.
      </para>
    </sect2>
    <sect2>
      <title>Procedure Properties</title>
      <para>
          &requires; 
        <emphasis role="bold">
          (import <emphasis>procedure-properties</emphasis>)
        </emphasis>
      </para>
      <para>
          &SISC; allows key/value bindings to be associated with
        procedures. This has a number of applications. For instance,
        <link linkend="GenericProcedures">generic procedures</link>
        store their methods in a procedure property.
      </para>
      <para>
        Keys must be symbols. Values are any valid Scheme value. 
        All operations are thread-safe.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>procedure-property</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>procedure-property</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
              <methodparam><parameter>symbol</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>nobinding</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the value associated with the property
                <parameter>symbol</parameter> of procedure
                <parameter>proc</parameter>, or
                <parameter>nobinding</parameter>, which defaults to
                &num;f, if the property is not set.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>set-procedure-property!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>set-procedure-property!</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
              <methodparam><parameter>symbol</parameter></methodparam>
              <methodparam><parameter>val</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>nobinding</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Sets the property <parameter>symbol</parameter> of procedure
                <parameter>proc</parameter> to the value
                <parameter>val</parameter>. Returns the previous value
                of the property or <parameter>nobinding</parameter>,
                which defaults to &num;f, if the property was unset.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>procedure-property!</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>procedure-property!</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
              <methodparam><parameter>symbol</parameter></methodparam>
              <methodparam><parameter>thunk</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>nobinding</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the value associated with the property
                <parameter>symbol</parameter> of procedure
                <parameter>proc</parameter>. If the property is unset
                then <parameter>thunk</parameter> is evaluated and the
                property is set to the result, which is also returned.
                The <parameter>nobinding</parameter> argument, which
                defaults to &num;f, denotes the value indicating that
                the property is unset.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="LibraryModule">
      <title>Loadable Scheme Libraries</title>
      <para>
          &requires; 
        <emphasis role="bold">
          (import <emphasis>libraries</emphasis>)
          <footnote>
            <para>
              This module gets imported by default.
            </para>
          </footnote>
        </emphasis>
      </para>
      <para>
        Scheme code can be packaged into libraries that can have
        dependencies on other libraries and can be loaded as
        required. Libraries are identified by a name that follows Java
        package file naming conventions, i.e. using path-style names
        typically containing domain, organisation name, project name and
        library name. For instance, if company Foo produces a library
        Baz for project Bar and that library contains three files, the
        file structure might look as follows:
<programlisting>
com/foo/bar/baz.scm
com/foo/bar/baz/baz1.scm
com/foo/bar/baz/baz2.scm
com/foo/bar/baz/baz3.scm
</programlisting>
        This library can be made accessible from &SISC; by adding the
        base directory or a jar file containing these files to the
        Java class path. Libraries are loaded by the following
        procedure.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>require-library</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>require-library</methodname>
              <methodparam><parameter>name</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Checks whether the library identified by
                <parameter>name</parameter> (a string), has already
                been loaded and, if not, loads it. An error is raised
                if the library cannot be found.
              </para>
              <para>
                Libraries are loaded using the
                <function>load</function> procedure from a resource
                located by the <link
                linkend="Resources"><function>find-resource</function>
                procedure</link>.  The name of the resource is derived
                from the name of the library by appending ".sll",
                ".sce" and, if that does not succeed, ".scm".
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        Note that <function>require-library</function> only loads a
        single file. The definition of dependencies on other libraries
        and the loading of other files therefore needs to happen
        within that file. For instance, the file
        <filename>com/foo/bar/baz.scm</filename> from the above
        example might contain the following:
        <programlisting>
(require-library "com/foo/bar/boo")
(load "baz/baz1.scm")
(load "baz/baz2.scm")
(load "baz/baz3.scm")
        </programlisting>
      </para>
      <para>
        It is possible to programmatically check whether a particular
        library exists and whether it has been loaded:
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>library-exists?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>library-exists?</methodname>
              <methodparam><parameter>name</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if the library identified by
                <parameter>name</parameter> (a string) exists, &num;f
                otherwise.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>library-loaded?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>library-loaded?</methodname>
              <methodparam><parameter>name</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if the library identified by
                <parameter>name</parameter> (a string) 
                has been loaded, &num;f otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="OperatingSystemInterface">
      <title>
        Operating System Interface
      </title>
      <note>
        <para>
          The interface to the host operating system is a work in
          progress. Documentation and a corresponding implementation
          will appear in future revisions. 
        </para>
      </note>
    </sect2>
  </sect1>
  <sect1 id="ThirdPartyLibs">
    <title>Third-Party Libraries</title>
    <para>
        &SISC; provides hooks for accessing a number of third-party
      Scheme libraries.
    </para>
    <warning>
      <para>
        This functionality has not undergone much testing.
      </para>
    </warning>
    <sect2>
      <title>SRFIs</title>
      <para>
        The Scheme Requests For Implementation (SRFI) process aims to
        coordinate libraries and other additions to the Scheme
        language between different Scheme implementations. For details
        see <ulink url="http://srfi.schemers.org/"/> which describes
        the process and contains a list of all available SRFIs.
      </para>
      <sect3>
        <title>SRFI Modules</title>
        <para>
          In &SISC; each SRFI is encapsulated in a module. See <xref
          linkend="Modules"/> for details of &SISC;'s module system.
          The definitions for SRFI modules are not included in the
          standard &SISC; heap build and hence must be loaded
          separately from the compiled library
          <filename>srfi.sll</filename>, which is contained in the
          <filename>sisc-lib.jar</filename> jar file in the root
          directory of the &SISC; binary distribution. As long as this
          jar file is on the classpath, which is the case by default,
          the following command makes the SRFI modules available:
          <programlisting>
(require-library "sisc/libs/srfi")
          </programlisting>
        </para>
      </sect3>
      <sect3>
        <title>Using SRFIs</title>
        <para>
            &SISC; currently supports SRFIs
          0,1,2,5,6,7,8,9,11,13,14,16,19,23,24,25,26,28,29,30,31,34,35,37,38.
          Once the SRFI module definitions have been loaded as
          described above, an SRFI <parameter>n</parameter> can be
          imported using
          <programlisting>
(import srfi-<parameter>n</parameter>)
          </programlisting>
          e.g.
          <programlisting>
(import srfi-1)
(xcons 1 2) ;=&gt; (2 . 1)
          </programlisting>
        </para>
        <para>
          SRFI modules, like all modules in &SISC;, can be
          imported/used by other modules. Doing so does not pollute
          the top-level environment with the definitions exported by
          the module, i.e. any code outside the importing module
          remains unaffected.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>SLIB</title>
      <para>
        The <application>SLIB</application> portable scheme library
        provides compatibility and utility functions for standard
        Scheme implementations. It is supported by many Schemes,
        including &SISC;.
      </para>
      <sect3>
        <title>Downloading and Installation</title>
        <para>
          The latest version of <application>SLIB</application> is
          available from <ulink
                                url="http://swissnet.ai.mit.edu/~jaffer/SLIB.html"/> as both
          a zip file and RPM. The site also hosts an online version of
          the <application>SLIB</application> manual.
        </para>
        <para>
          Download <application>SLIB</application> and install it in a
          convenient location. The RPM will by default be installed
          in <filename>/usr/share/slib/</filename>. Do not worry when
          you see some errors about missing programs such as
          <application>mzscheme</application> and
          <application>scheme48</application> when installing the RPM
          - these happen because <application>SLIB</application> tries
          to auto-configure itself for various Schemes that you may
          not have installed on your system.
        </para>
      </sect3>
      <sect3>
        <title>Environment</title>
        <para>
          Using <application>SLIB</application> in &SISC; requires two
          Java system properties to be set:
          <itemizedlist>
            <listitem>
              <formalpara>
                <title><envar>sisc.home</envar></title>
                <para>
                  This should (but does not actually
                  <emphasis>have</emphasis> to) point to the location
                  where you have installed &SISC;. If you are using
                  one of the scripts from the binary &SISC;
                  distribution in order to run &SISC; then this
                  property will automatically be set to the value of
                  the <envar>SISC_HOME</envar> environment variable.
                </para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title><envar>sisc.slib</envar></title>
                <para>
                  This must point to the location where you installed
                  <application>SLIB</application>. Other Schemes
                  supporting <application>SLIB</application> tend to
                  use an environment variable
                  <envar>SCHEME_LIBRARY_PATH</envar>, so it is
                  advisable to define that (if it is not already
                  defined) and run Java with a
                  <computeroutput>-Dsisc.slib=...</computeroutput>
                  option based on the environment variable. If you are
                  using the scripts from the binary $SISC;
                  distribution in order to run &SISC; then you can set
                  the property by adding the
                  <computeroutput>-Dsisc.slib=...</computeroutput> to
                  the <envar>JAVAOPT</envar> environment variable.
                </para>
              </formalpara>
            </listitem>
          </itemizedlist>
          You need to ensure that all potential users of
          <application>SLIB</application> have
          <emphasis>read</emphasis> permissions to files in the
          directories referred to by the above system properties.
        </para>
        <para>
          You also need access to the file
          <filename>slib.scm</filename>, which can be found in the
          <filename>scheme-src</filename> directory of the &SISC;
          distribution.
        </para>
      </sect3>
      <sect3>
        <title>Building the Catalog</title>
        <para>
          Make sure that the above system properties are set and
          that you have <emphasis>write</emphasis> permissions to the
          <envar>sisc.home</envar> directory; often this means you
          need to be logged in as a privileged user.
        </para>
        <para>
          Start &SISC; as you normally would. At the prompt type
          <programlisting>
(load "<parameter>path</parameter>/slib.scm")
(require 'new-catalog)
(exit)
          </programlisting>
          where <parameter>path</parameter> is the directory
          containing the <filename>slib.scm</filename> file.
        </para>
        <para>
          The above should create a file <filename>slibcat</filename>
          in the <envar>sisc.home</envar> directory. It is a good idea
          to check that this has indeed happened.
        </para>
      </sect3>
      <sect3>
        <title>Using <application>SLIB</application></title>
        <para>
          Make sure the above system properties are set. Start
            &SISC; as you normally would. At the prompt load
          <filename>slib.scm</filename> as described above, i.e.
          <programlisting>
(load "<parameter>path</parameter>/slib.scm")
          </programlisting>
          You can now load <application>SLIB</application> modules
          using <function>require</function>, e.g.
          <programlisting>
(require 'tsort)
(tsort '((shirt tie belt)
         (tie jacket)
         (belt jacket)
         (watch)
         (pants shoes belt)
         (undershorts pants shoes)
         (socks shoes))
       eq?)
          </programlisting>
          loads the topological sorting module and invokes one of the
          procedures defined by it.
        </para>
        <para>
          Please refer to the <application>SLIB</application> manual
          for further details of what modules are available. Note
          however that, as with most other Schemes supported by
          <application>SLIB</application>, there will be some modules
          that are not available or do not work in &SISC;.
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>Creating Libraries</title>
    <para>
      &requires; 
      <emphasis role="bold">
        (import <emphasis>compiled-libraries</emphasis>)
      </emphasis>
    </para>
    <para>
      &SISC; allows the creation of <emphasis>compiled libraries</emphasis> 
      which contain compiled scheme code.  These
      libraries can then be linked into a running &SISC; session in
      order to extend the functionality without processing or
      possessing the original source.  Such libraries can be loaded
      using <function>load</function> as would any ordinary Scheme
      source file.
    </para>
    <para>
      Compiled libraries must currently be generated from a Scheme
      module (see <xref linkend="SchemeModules"/>).  First, the user
      creates such a module (usually by loading a source file that
      defines the module), then use the
      <function>create-library-from-module</function> function to
      create the library file and save it to disk.  When loaded, the
      created library will have the same effect as defining the module
      from source code.  That is, the module will be available for
      import but will <emphasis>not</emphasis> be imported.
    </para>
    <para>
      <blockquote>
        <para>
          <indexterm><primary>create-library-from-module</primary>
          </indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>undefined</type>
            <methodname>create-library-from-module</methodname>
            <methodparam><parameter>module-name</parameter></methodparam>
            <methodparam><parameter>library-filename</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Creates a library named
              <parameter>module-name</parameter> and stores it in the
              file named by the string
              <parameter>library-filename</parameter>.  The library
              created will when loaded have the effect of defining 
              the module named by <parameter>module-name</parameter>
              (a symbol).
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>undefined</type>
            <methodname>create-library-from-module</methodname>
            <methodparam><parameter>library-name</parameter></methodparam>
            <methodparam><parameter>library-filename</parameter>
            </methodparam>
            <methodparam><parameter>module-name</parameter>
            </methodparam>
            <methodparam choice="opt" rep="repeat"><parameter>module-name</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Creates a library named
              <parameter>library-name</parameter> and stores it in the
              file named by the string
              <parameter>library-filename</parameter>.  The library
              created will when loaded define the modules named by the
              <parameter>module-name</parameter> symbols.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </para>
    <para>
      In the first form, a library is created from the existing module
      named <parameter>module-name</parameter>, which will also become
      the name of the library.  In the second form, the user is able
      to specify the name of the library, and have it include the
      definitions of several modules at once.  
    </para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
