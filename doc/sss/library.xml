<chapter id="LibraryFunctions">
  <title>
    Additional Libraries
  </title>
  <sect1 id="BitwiseLogicalOperations">
    <title>
      Bitwise Logical Operations
    </title>
    <para>
      &requires; 
      <emphasis role="bold">
	(import <emphasis>logicops</emphasis>)
      </emphasis>
    </para>
    <para>
      In addition to the &R5RS; set of procedures that deal with
      numbers, &SISC; provides operators for performing bitwise
      logic operations on a limited range of integers.  The domain of the
      logical operators are exact real integers of the range
      -2,147,483,647 to 2,147,483,646 inclusive.  An error is raised
      if the logical operators are applied to integers outside this
      range, to a non-integer, or a non-real.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logand</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical AND of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logor</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical OR of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logxor</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical exclusive-OR of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>lognot</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical NOT of the provided integer.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      In addition, two operators are provided to perform arithmetic
      shifts on any integer (these operators do not have the range
      limitation the previous logical functions do).  The shift
      operators return a newly generated number formed by shifting
      the provided number left or right by the given number of bits.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>ashl</methodname>
	    <methodparam><parameter>integer</parameter></methodparam>
	    <methodparam><parameter>bits</parameter></methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Arithmetically shifts <parameter>integer</parameter>
	      left by <parameter>bits</parameter> bits.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>ashr</methodname>
	    <methodparam><parameter>integer</parameter></methodparam>
	    <methodparam><parameter>bits</parameter></methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Arithmetically shifts <parameter>integer</parameter>
	      right by <parameter>bits</parameter> bits.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      Mathematically, if r is the number, and s is the number of
      bits, ashl calculates:
      
      <programlisting>
	r x 2<superscript>s</superscript>
      </programlisting>
      while ashr calculates
      <programlisting>
	r / 2<superscript>s</superscript>
      </programlisting>
      in the integer domain.  Both ashl and ashr operate on exact
      integers and produce only exact integers.  
    </para>
  </sect1>
  <sect1 id="Hashtables">
    <title>Hash Tables</title>
    <para>
      &requires; 
      <emphasis role="bold">
        (import <emphasis>hashtable</emphasis>)
      </emphasis>
    </para>
    <para>
      Hash tables store mappings of keys to values. Hence they are
      similar to association lists, except that hash tables allow
      retrieval, addition and modification in constant whereas
      association lists typically perform these operations in linear
      time based on the number of elements.
    </para>
    <para>
      SISC hash tables use <function>eqv?</function> for element
      comparison, which implies that keys generally ought to be of a
      type for which comparison with <function>eqv?</function> is
      meaningful. Furthermore, <emphasis>keys must be
      immutable</emphasis>. Specifically this excludes dynamically
      allocated strings, lists and vectors.
    </para>
    <para>
      SISC hash tables are thread-safe, i.e. multiple threads can
      concurrently access and modify the same hash table.
    </para>
    <sect2>
      <title>Creation</title>
      <para>
        Hash tables are a distinct data type. They can be created
        empty or filled with the contents of an association list. The
        converse, creating an association list from a hash table, is
        also supported.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>hashtable</type>
            <methodname>make-hashtable</methodname>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>&num;t/&num;f</type>
            <methodname>hashtable?</methodname>
            <methodparam><parameter>obj</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>hashtable</type>
            <methodname>alist-&gt;hashtable</methodname>
            <methodparam><parameter>alist</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>alist</type>
            <methodname>hashtable-&gt;alist</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
    <sect2>
      <title>Access</title>
      <para>
        All hash table access operations follow a similar
        pattern. They return the value that was associated with the
        the given key at the time the operation was invoked. If no
        binding for the key existed, an optionally supplied value is
        returned that defaults to &num;f. This allows the programmer
        to associate keys with &num;f values and distinguish this case
        from not having any association for a key.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/put!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam><parameter>val</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/get</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/get!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam><parameter>thunk</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/remove!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam><parameter>val</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
    <sect2>
      <title>Bulk Operations</title>
      <para>
        Bulk operations are operations that apply to all elements of a
        hash table.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <void/>
            <methodname>hashtable/clear!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>list</type>
            <methodname>hashtable/keys</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <void/>
            <methodname>hashtable/for-each</methodname>
            <methodparam><parameter>thunk</parameter></methodparam>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>list</type>
            <methodname>hashtable/map</methodname>
            <methodparam><parameter>thunk</parameter></methodparam>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
  </sect1>
  <sect1 id="OperatingSystemInterface">
    <title>
      Operating System interface
    </title>
    <para></para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
End:
-->
