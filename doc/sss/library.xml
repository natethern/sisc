<chapter id="LibraryFunctions">
  <title>
    &SISC; Library Functions
  </title>
  <sect1 id="Debugging">
    <title>
      Debugging
    </title>
    <para>
      &requires;<emphasis role='bold'>debugging-module</emphasis>
    </para>
    <para>
      &SISC; provides debugging aids that can be added to Scheme
      source code, as well as limited support for debugging without
      modification. 
    </para>
    <para>
      <blockquote>
	<para>
	  &syntax;
	  <methodsynopsis language="scheme">
	    <type>procedure</type>
	    <methodname>trace-lambda</methodname>
	    <methodparam>
	      <parameter>trace-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>formals</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>body</parameter>
	    </methodparam>	
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      When replaced with a trace-lambda, all calls to a lambda
	      defined procedure are traced on the console.
	      <parameter>trace-name</parameter> is a symbol to identify
	      the procedure in the trace. <parameter>formals
	      </parameter>and <parameter>body</parameter> have identical
	      semantics to lambda.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &syntax;
	  <methodsynopsis language="scheme">
	    <type>value</type>
	    <methodname>trace-let</methodname>
	    <methodparam>
	      <parameter>loop-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>formal-bindings</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>body</parameter>
	    </methodparam>	
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Replaces a named-let expression in a similar manner to
	      trace-lambda.  
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>trace</methodname>
	    <methodparam>
	      <parameter>symbol</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>symbol</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Begins traces on the procedures named by the symbols
	      given.  The procedures must be defined in the top-level
	      environment.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>untrace</methodname>
	    <methodparam>
	      <parameter>symbol</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>symbol</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Stops tracing the top-level procedures named by the
	      symbols given.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      <function>trace-lambda</function> and
      <function>trace-let</function> are useful for debugging
      anonymous lambdas and named-lets
      respectively. Trace-top-level-procedures can be used to trace
      calls to any procedure, including native procedures and stored
      continuations.
    </para>
  </sect1>
  <sect1 id="BitwiseLogicalOperations">
    <title>
      Bitwise Logical Operations
    </title>
    <para>
      &requires;<emphasis role='bold'>logicops-module</emphasis>
    </para>
    <para>
      In addition to the &R5RS; set of procedures that deal with
      numbers, &SISC; provides operators for performing bitwise
      logic operations on a limited range of integers.  The domain of the
      logical operators are exact real integers of the range
      -2,147,483,647 to 2,147,483,646 inclusive.  An error is raised
      if the logical operators are applied to integers outside this
      range, to a non-integer, or a non-real.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logand</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical AND of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logor</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical OR of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logxor</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical exclusive-OR of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>lognot</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical NOT of the provided integer.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      In addition, two operators are provided to perform arithmetic
      shifts on any integer (these operators do not have the range
      limitation the previous logical functions do).  The shift
      operators return a newly generated number formed by shifting
      the provided number left or right by the given number of bits.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>ashl</methodname>
	    <methodparam><parameter>integer</parameter></methodparam>
	    <methodparam><parameter>bits</parameter></methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Arithmetically shifts <parameter>integer</parameter>
	      left by <parameter>bits</parameter> bits.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>ashr</methodname>
	    <methodparam><parameter>integer</parameter></methodparam>
	    <methodparam><parameter>bits</parameter></methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Arithmetically shifts <parameter>integer</parameter>
	      right by <parameter>bits</parameter> bits.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      Mathematically, if r is the number, and s is the number of
      bits, ashl calculates:
      
      <programlisting>
	r x 2<superscript>s</superscript>
      </programlisting>
      while ashr calculates
      <programlisting>
	r / 2<superscript>s</superscript>
      </programlisting>
      in the integer domain.  Both ashl and ashr operate on exact
      integers and produce only exact integers.  
    </para>
  </sect1>
  <sect1 id="OperatingSystemInterface">
    <title>
      Operating System interface
    </title>
    <para></para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
End:
-->
