<chapter id="LibraryFunctions">
  <title>
    Additional Libraries
  </title>
  <sect1 id="BitwiseLogicalOperations">
    <title>
      Bitwise Logical Operations
    </title>
    <para>
      &requires; 
      <emphasis role="bold">
	(import <emphasis>logicops</emphasis>)
      </emphasis>
    </para>
    <para>
      In addition to the &R5RS; set of procedures that deal with
      numbers, &SISC; provides operators for performing bitwise
      logic operations on a limited range of integers.  The domain of the
      logical operators are exact real integers of the range
      -2,147,483,647 to 2,147,483,646 inclusive.  An error is raised
      if the logical operators are applied to integers outside this
      range, to a non-integer, or a non-real.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logand</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical AND of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logor</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical OR of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>logxor</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical exclusive-OR of all the provided arguments.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>lognot</methodname>
	    <methodparam><parameter>integer</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Performs the logical NOT of the provided integer.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      In addition, two operators are provided to perform arithmetic
      shifts on any integer (these operators do not have the range
      limitation the previous logical functions do).  The shift
      operators return a newly generated number formed by shifting
      the provided number left or right by the given number of bits.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>ashl</methodname>
	    <methodparam><parameter>integer</parameter></methodparam>
	    <methodparam><parameter>bits</parameter></methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Arithmetically shifts <parameter>integer</parameter>
	      left by <parameter>bits</parameter> bits.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>integer</type>
	    <methodname>ashr</methodname>
	    <methodparam><parameter>integer</parameter></methodparam>
	    <methodparam><parameter>bits</parameter></methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Arithmetically shifts <parameter>integer</parameter>
	      right by <parameter>bits</parameter> bits.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      Mathematically, if r is the number, and s is the number of
      bits, ashl calculates:
      
      <programlisting>
	r x 2<superscript>s</superscript>
      </programlisting>
      while ashr calculates
      <programlisting>
	r / 2<superscript>s</superscript>
      </programlisting>
      in the integer domain.  Both ashl and ashr operate on exact
      integers and produce only exact integers.  
    </para>
  </sect1>
  <sect1 id="Hashtables">
    <title>Hash Tables</title>
    <para>
      &requires; 
      <emphasis role="bold">
        (import <emphasis>hashtable</emphasis>)
      </emphasis>
    </para>
    <para>
      Hash tables store mappings of keys to values. Hence they are
      similar to association lists, except that hash tables allow
      retrieval, addition and modification in constant time whereas
      association lists typically perform these operations in linear
      time based on the number of elements.
    </para>
    <para>
      &SISC; hash tables use <function>eqv?</function> for element
      comparison, which implies that keys generally ought to be of a
      type for which comparison with <function>eqv?</function> is
      meaningful. Furthermore, <emphasis>keys must be
      immutable</emphasis>. Specifically this excludes dynamically
      allocated strings, lists and vectors.
    </para>
    <para>
      &SISC; hash tables are thread-safe, i.e. multiple threads can
      concurrently access and modify the same hash table.
    </para>
    <sect2>
      <title>Creation</title>
      <para>
        Hash tables are a distinct data type. They can be created
        empty or filled with the contents of an association list. The
        converse, creating an association list from a hash table, is
        also supported.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>hashtable</type>
            <methodname>make-hashtable</methodname>
            <void/>
          </methodsynopsis>
          <blockquote>
            <para>
              Creates an empty hash table.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>&num;t/&num;f</type>
            <methodname>hashtable?</methodname>
            <methodparam><parameter>obj</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns &num;t if <parameter>obj</parameter> is a hash
              table, &num;f otherwise.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>hashtable</type>
            <methodname>alist-&gt;hashtable</methodname>
            <methodparam><parameter>alist</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Creates a hashtable and initializes it with the keys and
              values found in
              <parameter>alist</parameter>. <parameter>alist</parameter>
              must be a list of pairs, with the <function>car</function>
              of each pair representing a key and the
              <function>cdr</function> representing its associated
              value. If there are multiple pairs which contain the
              same key (with respect to <function>eqv?</function>)
              then the resulting hash table will associate the key
              with the value of the last such pair.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>alist</type>
            <methodname>hashtable-&gt;alist</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns an association list comprising the elements of
              <parameter>hashtable</parameter>. The list contains
              pairs whose <function>car</function>s are they keys
              found in <parameter>hashtable</parameter> and whose
              <function>cdr</function>s contain the associated
              values.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
    <sect2>
      <title>Access</title>
      <para>
        All hash table access operations follow a similar
        pattern. They return the value that was associated with the
        the given key at the time the operation was invoked. If no
        binding for the key existed, an optionally supplied value is
        returned that defaults to &num;f. This allows the programmer
        to associate keys with &num;f values and distinguish this case
        from not having any association for a key.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/put!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam><parameter>val</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Associates <parameter>key</parameter> with
              <parameter>val</parameter> in
              <parameter>hashtable</parameter>. Returns the previous
              association of <parameter>key</parameter> or
              <parameter>nobinding</parameter>, which defaults to
              &num;f, if <parameter>key</parameter> has no previous
              association.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/get</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns the value associated with
              <parameter>key</parameter> in
              <parameter>hashtable</parameter>, or
              <parameter>nobinding</parameter>, which defaults to
              &num;f, if <parameter>key</parameter> has no
              association.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/get!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam><parameter>thunk</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns the value associated with
              <parameter>key</parameter> in
              <parameter>hashtable</parameter>. If
              <parameter>key</parameter> has no association then
              <parameter>thunk</parameter> is evaluated and the result
              is associated with <parameter>key</parameter> in
              <parameter>hashtable</parameter> and also returned.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname>hashtable/remove!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam><parameter>val</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>nobinding</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Removes the association of <parameter>key</parameter> in
              <parameter>hashtable</parameter>. Returns the associated
              value of <parameter>key</parameter> or
              <parameter>nobinding</parameter>, which defaults to
              &num;f, if <parameter>key</parameter> has no
              association.
            </para>
          </blockquote>
        </para>
      </blockquote>
      <para>
        Hash tables can be invoked as procedures. This provides
        convenient short-cuts for the very common
        <function>hashtable/get</function> and
        <function>hashtable/put!</function> operations:
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>obj</type>
            <methodname></methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
            <methodparam><parameter>key</parameter></methodparam>
            <methodparam choice="opt">
              <parameter>val</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              If <parameter>val</parameter> is present, then this is
              equivalent to calling <literal>(hashtable/put!</literal>
              <parameter>hashtable</parameter>
              <parameter>key</parameter>
              <parameter>value</parameter><literal>)</literal>,
              otherwise <literal>(hashtable/get</literal>
              <parameter>hashtable</parameter>
              <parameter>key</parameter><literal>)</literal>.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
    <sect2>
      <title>Bulk Operations</title>
      <para>
        Bulk operations are operations that apply to all elements of a
        hash table.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <void/>
            <methodname>hashtable/clear!</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Removes all elements from <parameter>hashtable</parameter>.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>list</type>
            <methodname>hashtable/keys</methodname>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns the keys contained in <parameter>hashtable</parameter>.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <void/>
            <methodname>hashtable/for-each</methodname>
            <methodparam><parameter>thunk</parameter></methodparam>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Applies <parameter>thunk</parameter> to each element of
              <parameter>hashtable</parameter>. <parameter>thunk</parameter>
              is invoked with two parameters - the key and the value
              of the element.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>list</type>
            <methodname>hashtable/map</methodname>
            <methodparam><parameter>thunk</parameter></methodparam>
            <methodparam><parameter>hashtable</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Applies <parameter>thunk</parameter> to each element of
              <parameter>hashtable</parameter>. <parameter>thunk</parameter>
              is invoked with two parameters - the key and the value
              of the element. The results of evaluating
              <parameter>thunk</parameter> are returned as a list.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
  </sect1>
  <sect1 id="OperatingSystemInterface">
    <title>
      Operating System interface
    </title>
    <note>
      <para>
        The interface to the host operating system is a work in
        progress. Documentation and a corresponding implementation
        will appear in future revisions. 
      </para>
    </note>
  </sect1>
  <sect1 id="ThirdPartyLibs">
    <title>Third-Party Libraries</title>
    <para>
      &SISC; provides hooks for accessing a number of third-party
      Scheme libraries.
    </para>
    <note>
      <para>
        This functionality has not undergone much testing.
      </para>
    </note>
    <sect2>
      <title>SRFIs</title>
      <para>
        The Scheme Requests For Implementation (SRFI) process aims to
        coordinate libraries and other additions to the Scheme
        language between different Scheme implementations. For details
        see <ulink url="http://srfi.schemers.org/"/> which describes
        the process and contains a list of all available SRFIs.
      </para>
      <sect3>
        <title>SRFI Modules</title>
        <para>
          In &SISC; each SRFI is encapsulated in a module. See <xref
          linkend="Modules"/> for details of &SISC;'s module system.
          The definitions for SRFI modules are not included in the
          standard &SISC; heap build and hence must be loaded
          separately from the <filename>srfi.scm</filename>, which can
          be found in the <filename>scheme-src</filename> directory
          of the &SISC; distribution:
<programlisting>
(load "<parameter>path</parameter>/srfi.scm")
</programlisting>
          Loading this takes quite a while, which is one reason why
          the module definitions are not included in the standard heap
          build.
        </para>
      </sect3>
      <sect3>
        <title>Using SRFIs</title>
        <para>
          &SISC; currently supports SRFIs
          0,1,2,5,6,7,8,9,11,12,13,14,16,23,24.
          Once the SRFI module definitions have been loaded as
          described above, an SRFI <parameter>n</parameter> can be
          imported using
<programlisting>
(import srfi-<parameter>n</parameter>)
</programlisting>
          e.g.
<programlisting>
(import srfi-1)
(xcons 1 2) ;=&gt; (2 . 1)
</programlisting>
        </para>
        <para>
          SRFI modules, like all modules in &SISC;, can be
          imported/used by other modules. Doing so does not pollute
          the top-level environment with the definitions exported by
          the module, i.e. any code outside the importing module
          remains unaffected.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>SLIB</title>
      <para>
        The <application>SLIB</application> portable scheme library
        provides compatibility and utility functions for standard
        Scheme implementations. It is supported by many Schemes,
        including &SISC;.
      </para>
      <sect3>
        <title>Downloading and Installation</title>
        <para>
          The latest version of <application>SLIB</application> is
          available from <ulink
          url="http://swissnet.ai.mit.edu/~jaffer/SLIB.html"/> as both
          a zip file and RPM. The site also hosts an online version of
          the <application>SLIB</application> manual.
        </para>
        <para>
          Download <application>SLIB</application> and install it in a
          convenient location. The RPM will be default be installed
          in <filename>/usr/share/slib/</filename>. Do not worry when
          you see some errors about missing programs such as
          <application>mzscheme</application> and
          <application>scheme48</application> when installing the RPM
          - these happen because <application>SLIB</application> tries
          to auto-configure itself for various Schemes that you may
          not have installed on your system.
        </para>
      </sect3>
      <sect3>
        <title>Environment</title>
        <para>
          Using <application>SLIB</application> in &SISC; requires two
          environment variables to be set:
          <itemizedlist>
            <listitem>
              <formalpara>
                <title><envar>SISC_LIB</envar></title>
                <para>
                  This should (but does not actually
                  <emphasis>have</emphasis> to) point to the location
                  where you have installed &SISC;.
                </para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title><envar>SCHEME_LIBRARY_PATH</envar></title>
                <para>
                  This must point to the location where you installed
                  <application>SLIB</application>.
                </para>
              </formalpara>
            </listitem>
          </itemizedlist>
          Note that you must specify a trailing separator, i.e. a
          <literal>/</literal> if you are on a Unix system. You also
          need to ensure that all potential users of
          <application>SLIB</application> have
          <emphasis>read</emphasis> permissions to files in the
          directories referred to by the above environment variables.
        </para>
        <para>
          You also need access to the file
          <filename>slib.scm</filename>, which can be found in the
          <filename>scheme-src</filename> directory of the &SISC;
          distribution.
        </para>
      </sect3>
      <sect3>
        <title>Building the Catalog</title>
        <para>
          Make sure that the above environment variables are set and
          that you have <emphasis>write</emphasis> permissions to the
          <envar>SISC_LIB</envar> directory; often this means you
          need to be logged in as a privileged user.
        </para>
        <para>
          Start &SISC; as you normally would. At the prompt type
<programlisting>
(load "<parameter>path</parameter>/slib.scm")
(require 'new-catalog)
(exit)
</programlisting>
          where <parameter>path</parameter> is the directory
          containing the <filename>slib.scm</filename> file.
        </para>
        <para>
          The above should create a file <filename>slibcat</filename>
          in the <envar>SISC_LIB</envar>. It is a good idea to check
          that this has indeed happened.
        </para>
      </sect3>
      <sect3>
        <title>Using <application>SLIB</application></title>
        <para>
          Make sure the above environment variables are set. Start
          &SISC; as you normally would. At the prompt load
          <filename>slib.scm</filename> as described above, i.e.
<programlisting>
(load "<parameter>path</parameter>/slib.scm")
</programlisting>
          You can now load <application>SLIB</application> modules
          using <function>require</function>, e.g.
<programlisting>
(require 'tsort)
(tsort '((shirt tie belt)
         (tie jacket)
         (belt jacket)
         (watch)
         (pants shoes belt)
         (undershorts pants shoes)
         (socks shoes))
       eq?)
</programlisting>
          loads the topological sorting module and invokes one of the
          procedures defined by it.
        </para>
        <para>
          Please refer to the <application>SLIB</application> manual
          for further details of what modules are available. Note
          however that, as with most other Schemes supported by
          <application>SLIB</application>, there will be some modules
          that are not available / do not work in &SISC;.
        </para>
      </sect3>
    </sect2>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
