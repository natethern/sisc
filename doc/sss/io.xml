<chapter id="IO">
  <title>I/O</title>
  <para>
      &SISC;'s I/O routines are implemented in a flexible manner, allowing 
    extensions to create new I/O sources that will behave as
    standard Scheme port objects.  The ports can then be operated on
    with all &R5RS; port operations, as well as some &SISC; specific 
    port functions.
  </para>
  <sect1>
    <title>Ports</title>
    <sect2 id="urlfile">
      <title>URLs</title>
      <para>
        In &SISC; all procedures that create ports for accessing
        files, e.g. <function>open-input-file</function>,
        <function>open-output-file</function> accept URLs in addition
        to ordinary file names. Here are some examples of valid URLs:
        <programlisting>
http://foo.com/bar/bar1.scm
file:/tmp/foo.scm
file:c:\bar\baz.scm
file:foo.scm
jar:http://foo.com/bar.jar!/bar/bar1.scm
        </programlisting>
        The last is a URL referring to a file stored in a JAR on a
        remote web server. For further details on the format of URLs
        please consult <ulink
        url="http://www.ietf.org/rfc/rfc2396.txt">this
        specification</ulink>. The format of JAR URLs is defined in
        <ulink
        url="http://java.sun.com/j2se/1.4/docs/api/java/net/JarURLConnection.html">the
        JDK API documentation</ulink>.  What types of URLs are
        supported by a particular installation of Java depends on the
        configured protocol handlers. See <ulink
        url="http://java.sun.com/j2se/1.4/docs/api/java/net/URL.html">the
        JDK API documentation</ulink> for details.
        <footnote>
          <para>
            Handling of JAR files in URLS may be dependent on the
            &SISC; host language, as well as some uncommon protocols.  
            FILE, HTTP and FTP should be expected to work with any
            host language.
          </para>
        </footnote>
      </para>
      <para>
        Relative file names or URLs are resolved in relation to the
        following parameter:
        <blockquote>
          <para>
            <indexterm><primary>current-url</primary></indexterm>
              &parameter;
            <methodsynopsis language="scheme">
              <type>url</type>
              <methodname>current-url</methodname>
              <methodparam choice="opt">
                <parameter>url</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Retrieves or sets the URL which forms the basis for
                resolving relative filenames and URLs. It is
                initialized on start up with the path to the current
                directory. All parameters and the returned value are
                strings.
              </para>
            </blockquote>
          </para>
        </blockquote>
        The algorithm for resolving relative URLs is defined in <ulink
        url="http://www.ietf.org/rfc/rfc2396.txt">this
        specification</ulink>.  For compatibility with other Schemes,
        &SISC; also supports the
        <function>current-directory</function> procedure, which is a
        simple wrapper around <function>current-url</function>.
      </para>
      <para>
        A convenience procedure exists for executing a procedure while
        the <function>current-url</function> is temporarily set to a
        different value:
        <blockquote>
          <para>
            <indexterm><primary>with-current-url</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-current-url</methodname>
              <methodparam><parameter>url</parameter></methodparam>
              <methodparam><parameter>thunk</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Sets the current URL to the URL obtained by
                normalizing <parameter>url</parameter> in relation to
                the current URL, then executes
                <parameter>thunk</parameter>, and then sets
                the current URL back to the previous value.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        URLs can be normalized using
        <blockquote>
          <para>
            <indexterm><primary>normalize-url</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>url</type>
              <methodname>normalize-url</methodname>
              <methodparam><parameter>url1</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>url2</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                When called with one string argument,
                <function>normalize-url</function> returns the
                normalized version of the given URL. Normalization
                involves, amongst other things, the replacement of
                relative path references such as <literal>.</literal>
                and <literal>..</literal>.
              </para>
              <para>
                When called with two string arguments, the procedure
                returns the normalized version of the second URL when
                interpreted as a being relative to the first URL.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        A convenience procedure exists for executing a procedure while
        the <function>current-url</function> is temporarily set to a
        different value:
        <blockquote>
          <para>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-current-url</methodname>
              <methodparam><parameter>url</parameter></methodparam>
              <methodparam><parameter>thunk</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Sets the current URL to the URL obtained by
                normalizing <parameter>url</parameter> in relation to
                the current URL, then executes
                <parameter>thunk</parameter>, and then sets
                the current URL back to the previous value.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2>
      <title>Buffered I/O</title>
      <para>
          &SISC; extends the &R5RS; standard's port-creation functions
        in order to provide buffered output ports.  All &SISC; output
        ports are buffered, and a programmer may choose whether a
        given port should automatically flush after each write
        operation.  By default ports do <emphasis>not</emphasis>
        automatically flush
        <footnote>
          <para>
            The console output port is an exception, as it is 
            an auto-flush port.
          </para>
        </footnote>.  Enabling auto-flush can be done when the
        port is created per the specifications of the output port
        constructors in following sections.  A port that
        does not automatically flush can be flushed at any time by
        calling <computeroutput>flush-output-port</computeroutput>.
        Finally, an output-port that does not automatically flush will
        be flushed when the port is closed with
        <computeroutput>close-output-port</computeroutput>, but may
        not be flushed if the Scheme system is exited without closing
        the port.
      </para>
      <blockquote>
        <para>
          <indexterm><primary>flush-output-port</primary>
          </indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>undefined</type>
            <methodname>flush-output-port</methodname>
            <methodparam choice="opt">
              <parameter>output-port</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Causes the specified
              <parameter>output-port</parameter>'s buffered data to be
              written immediately.  This operation is allowed on both
              auto-flush and non-auto-flush output ports, though it
              has no effect on the
              former. <parameter>output-port</parameter> defaults to
              <literal>current-output-port</literal>.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </sect2>
    <sect2 id="charports">
      <title>Character Ports</title>
      <para>
        The &R5RS; I/O primitives implemented by &SISC; create
        <emphasis>character ports</emphasis>.  Character ports read
        characters from input sources and treat the data as characters
        in a given character set.  Correspondingly, character ports
        output bytes from characters according to a given character
        set's encoding rules.
      </para>
      <para>
        By default character ports use the value of the string
        parameter <function>character-set</function> as the character
        encoding name.  A list of many possible encoding names can be
        found in the
        <ulink url="http://java.sun.com/j2se/1.4.1/docs/guide/intl/encoding.doc.html">
        Java Platform Documentation</ulink>
      </para>
      <para>
        One may temporarily change the default character set using
        the <function>with-character-set</function> function.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>with-character-set</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-character-set</methodname>
              <methodparam>
                <parameter>encoding</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Changes the value of the
                <function>character-set</function> parameter, and the
                default character set to the named encoding while
                executing the body of <parameter>thunk</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <sect3>
        <title>Port Creation</title>
        <para>
          <blockquote>
            <para>
              <indexterm><primary>open-input-file</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>input-port</type>
                <methodname>open-input-file</methodname>
                <methodparam>
                  <parameter>url</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>encoding</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates an input port from the specified
                  <parameter>url</parameter>.  If the optional
                  <parameter>encoding</parameter> parameter, a string,
                  is supplied input will be decoded from the specified
                  encoding rather than the default.
                </para>
              </blockquote>
            </para>
            <para>
              <indexterm><primary>open-output-file</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>output-port</type>
                <methodname>open-output-file</methodname>
                <methodparam>
                  <parameter>url</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>encoding</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>auto-flush</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates an output port to the specified
                  <parameter>url</parameter>.  If the optional
                  <parameter>encoding</parameter> parameter, a string,
                  is supplied output will be encoded in the specified
                  encoding rather than the default.  If the optional
                  <parameter>auto-flush</parameter> argument is provided
                  and is non-false, the port will automatically flush
                  after each write call.  If the specified file exists,
                  it will be overwritten silently when the port is
                  opened.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3 id="iodelegate">
        <title>Port Creation Wrappers</title>
        <para>
          The next set of procedures assists in creating a port,
          followed by calling a given procedure with that port.  When
          the procedure returns, the port is closed. Invoking escaping
          continuations from inside the procedure does not close the
          port, and invoking a continuation captured inside the
          procedure does not open the port.
        </para>
        <para>
          <blockquote>
            <para id="func-call-with-input-file">
              <indexterm><primary>call-with-input-file</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>value</type>
                <methodname>call-with-input-file</methodname>
                <methodparam>
                  <parameter>url</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>encoding</parameter>
                </methodparam>              
                <methodparam>
                  <parameter>procedure</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Calls <parameter>procedure</parameter> with a new
                  input port attached to <parameter>url</parameter>.
                  The result of the thunk is returned.
                </para>
                <para>
                  If the optional <parameter>encoding</parameter>
                  parameter is provided, the character port created will
                  use the specified encoding rather than the default.
                </para>
              </blockquote>
            </para>
            <para id="func-call-with-output-file">
              <indexterm><primary>call-with-output-file</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>value</type>
                <methodname>call-with-output-file</methodname>
                <methodparam>
                  <parameter>url</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>encoding</parameter>
                </methodparam>
                <methodparam>
                  <parameter>procedure</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Calls <parameter>procedure</parameter> with a new
                  character output port attached to
                  <parameter>url</parameter>. The result of the thunk is
                  returned.
                </para>
                <para>
                  If the optional <parameter>encoding</parameter>
                  parameter is provided, the character port created will
                  use the specified encoding rather than the default.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3 id="redirectedio">
        <title>Replacing Standard Ports</title>
        <para>
          The following procedures wrap a thunk, redirecting the input
          and output of the thunk while it is evaluating to an input or
          output port other than the
          <literal>current-input-port</literal> 
          and <literal>current-output-port</literal>. Invoking escaping
          continuations from inside the procedure restores the original
          port, and invoking a continuation captured inside the procedure
          restores the redirection.
        </para>
        <para>
          <blockquote>
            <para id="func-with-input-from-port">
              <indexterm><primary>with-input-from-port</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>value</type>
                <methodname>with-input-from-port</methodname>
                <methodparam>
                  <parameter>input-port</parameter>
                </methodparam>
                <methodparam>
                  <parameter>thunk</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>   
                  Evaluates <parameter>thunk</parameter> with
                  <parameter>input-port</parameter> as the
                  <literal>current-input-port</literal> for the duration
                  of the evaluation.  
                </para>
              </blockquote>
            </para>
            <para id="func-with-output-to-port">
              <indexterm><primary>with-output-to-port</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>value</type>
                <methodname>with-output-to-port</methodname>
                <methodparam>
                  <parameter>output-port</parameter>
                </methodparam>
                <methodparam>
                  <parameter>thunk</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>   
                  Evaluates <parameter>thunk</parameter> with
                  <parameter>output-port</parameter> as the
                  <literal>current-output-port</literal> for the duration
                  of the evaluation.  
                </para>
              </blockquote>
            </para>
            <para id="func-with-input-from-file">
              <indexterm><primary>with-input-from-file</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>value</type>
                <methodname>with-input-from-file</methodname>
                <methodparam>
                  <parameter>url</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>encoding</parameter>
                </methodparam>
                <methodparam>
                  <parameter>thunk</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Evaluates <parameter>thunk</parameter> with an input
                  port attached to a file opened for reading from
                  <parameter>url</parameter> as the
                  <literal>current-input-port</literal> for the duration
                  of the evaluation. The port is closed when
                  <parameter>thunk</parameter> returns normally.
                </para>
                <para>
                  If the optional <parameter>encoding</parameter>
                  parameter is provided, the character port created will
                  use the specified encoding rather than the default.
                </para>
              </blockquote>
            </para>
            <para id="func-with-output-to-file">
              <indexterm><primary>with-output-to-file</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>value</type>
                <methodname>with-output-to-file</methodname>
                <methodparam>
                  <parameter>url</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>encoding</parameter>
                </methodparam>
                <methodparam>
                  <parameter>thunk</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Evaluates <parameter>thunk</parameter> with an input
                  port attached to a file opened for writing to
                  <parameter>url</parameter> as the
                  <literal>current-output-port</literal> for the
                  duration of the evaluation. The port is closed when
                  <parameter>thunk</parameter> returns normally.
                </para>
                <para>
                  If the optional <parameter>encoding</parameter>
                  parameter is provided, the character port created will
                  use the specified encoding rather than the default.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3>
        <title>Port Predicates</title>
        <para>
          <blockquote>
            <para>
              <indexterm><primary>input-port?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>input-port?</methodname>
                <methodparam>
                  <parameter>value</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if <parameter>value</parameter> is an
                  input port, &num;f otherwise.
                </para>
              </blockquote>
            </para>
            <para>
              <indexterm><primary>output-port?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>output-port?</methodname>
                <methodparam>
                  <parameter>value</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if <parameter>value</parameter> is an
                  output port, &num;f otherwise.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
    </sect2>
    <sect2 id="StringPorts"> <title>String Ports</title>
      <para>
        &requires; 
        <emphasis role="bold">
          (import <emphasis>string-io</emphasis>)
        </emphasis>
      </para>
      <para>
        String ports are input or output ports that read or write to a
        string rather than a file or other stream.  String ports can
        be used to parse or emit formatted strings using the standard
        Scheme port operations.  A String Input port will read from a
        given string until the end of string is reached, at which
        point <computeroutput>&num;!eof</computeroutput> is returned.
      </para>
      <para>
        String ports deal with characters as the atomic unit, and as such
        preserve full unicode width characters at all times.
      </para>
      <para>
        <blockquote>
          <para id="func-open-input-string">
            <indexterm><primary>open-input-string</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string-input-port</type>
              <methodname>open-input-string</methodname>
              <methodparam>
                <parameter>string</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a string input port whose characters are read
                from the provided string.  Characters will be returned
                from any read operation on the port until the end of
                the string is reached.  Read calls after reaching the
                end of the string will return &num;!eof.
              </para>
            </blockquote>
          </para>
          <para id="func-open-output-string">
              &procedure;
            <methodsynopsis language="scheme">
              <type>string-output-port</type>
              <methodname>open-output-string</methodname> <void/>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a string output port, which behaves as an
                ordinary output port, except that writes are used to
                create a string as output.  The results of all the
                write operations are retrieved using
                <function>get-output-string</function>.
              </para>
            </blockquote>
          </para>
          <para id="func-get-output-string">
            <indexterm><primary>get-output-string</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string</type> <methodname>get-output-string</methodname>
              <methodparam>
                <parameter>string-output-port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the string that was created by zero or more
                writes to a string output port.  If no writes were
                performed on the string output port, an empty string
                ("") is returned.  After this call, the provided
                string output port is reset to its initial, empty
                state.
              </para>
            </blockquote>
          </para>
          <para id="func-call-with-input-string">
            <indexterm><primary>call-with-input-string</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>call-with-input-string</methodname>
              <methodparam>
                <parameter>string</parameter>
              </methodparam>
              <methodparam>
                <parameter>procedure</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para> Calls <parameter>procedure</parameter> with a new
              string input port created from
              <parameter>string</parameter>.  The result of the thunk
              is returned.
              </para>
            </blockquote>
          </para>
          <para id="func-call-with-output-string">
            <indexterm><primary>call-with-output-string</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string</type>
              <methodname>call-with-output-string</methodname>
              <methodparam>
                <parameter>procedure</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para> Calls <parameter>procedure</parameter> with a new
              string output port.  The contents of the
              string-output-port are returned when the procedure
              returns.
              </para>
            </blockquote>
          </para>
          <para id="func-with-input-from-string">
            <indexterm><primary>with-input-from-string</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-input-from-string</methodname>
              <methodparam>
                <parameter>string</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>   
                Evaluates <parameter>thunk</parameter> with a
                string-input-port created from
                <parameter>string</parameter> as the
                <literal>current-input-port</literal> for the duration
                of the evaluation.
              </para>
            </blockquote>
          </para>
          <para id="func-with-output-to-string">
            <indexterm><primary>with-output-to-string</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string</type>
              <methodname>with-output-to-string</methodname>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>   
                Evaluates <parameter>thunk</parameter> with a
                string-output-port created as the
                <literal>current-output-port</literal> for the duration
                of the evaluation.  When the thunk returns, the
                contents of the string-output-port are returned.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>string-input-port?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>string-input-port?</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                string input port, &num;f otherwise.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>string-output-port?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>string-output-port?</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                string output port, &num;f otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <note>
        <para>
          This interface complies with SRFI-6 (Basic String Ports).
        </para>
      </note>
    </sect2>
    <sect2 id="BinaryIO">
      <title>Binary Ports and Block IO</title>
      <para>
        &requires; 
        <emphasis role="bold">
          (import <emphasis>binary-io</emphasis>)
        </emphasis>
      </para>
      <para>
        In addition to the &R5RS; I/O functions, &SISC; provides a
        symmetric set of functions for reading and writing binary data
        to and from ports with no character set translation.  These
        ports are operated on in the same way as character ports,
        i.e. with <function>read</function>,
        <function>read-char</function>, <function>display</function>,
        etc.
        In addition to the standard operations, binary ports provides block
        input/output functions, that allow a Scheme program to read
        blocks of more than one byte of data at a time from binary ports.
        &SISC; stores data that is read or is to be written in a 
        binary buffer (see <xref linkend="Buffers"/>).
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>open-binary-input-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>binary-input-port</type>
              <methodname>open-binary-input-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
		        Creates an input port in the same manner as &R5RS;
                <function>open-input-file</function>, producing an
		        input port that does no character-set decoding on the
                bytes read as input.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>open-binary-output-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>binary-output-port</type>
              <methodname>open-binary-output-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>auto-flush</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates an output port in the same manner as
                <function>open-output-file</function>, producing an
                output port that does no character-set encoding.
              </para>
            </blockquote>
          </para>
          <para id="func-call-with-binary-input-file">
            <indexterm><primary>call-with-binary-input-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>call-with-binary-input-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>procedure</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Calls <parameter>procedure</parameter> with a new
                binary input port attached to
                <parameter>url</parameter>.  The result of the thunk
                is returned.
              </para>
            </blockquote>
          </para>
          <para id="func-call-with-binary-output-file">
            <indexterm><primary>call-with-binary-output-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>call-with-binary-output-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>procedure</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Calls <parameter>procedure</parameter> with a new
                binary output port attached to
                <parameter>url</parameter>. The result of the thunk is
                returned.
              </para>
            </blockquote>
          </para>
          <para id="func-with-binary-input-from-file">
            <indexterm><primary>with-binary-input-from-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-binary-input-from-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Evaluates <parameter>thunk</parameter> with a binary
                input port attached to a file opened for reading from
                <parameter>url</parameter> as the
                <literal>current-input-port</literal> for the duration
                of the evaluation. The port is closed when
                <parameter>thunk</parameter> returns normally.
              </para>
            </blockquote>
          </para>
          <para id="func-with-binary-output-to-file">
            <indexterm><primary>with-binary-output-to-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-binary-output-to-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Evaluates <parameter>thunk</parameter> with a binary
                input port attached to a file opened for writing to
                <parameter>url</parameter> as the
                <literal>current-output-port</literal> for the
                duration of the evaluation. The port is closed when
                <parameter>thunk</parameter> returns normally.
              </para>
            </blockquote>
          </para>
          <para id="func-block-read">
            <indexterm><primary>block-read</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>integer</type>
              <methodname>block-read</methodname>
              <methodparam>
                <parameter>buffer</parameter>
              </methodparam>
              <methodparam>
                <parameter>binary-input-port</parameter>
              </methodparam>
              <methodparam>
                <parameter>count</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Reads up to <parameter>count</parameter> bytes of data
                from the provided <parameter>binary-input-port</parameter>
                into the binary buffer <parameter>buffer</parameter>.  
                Note that less
                than <parameter>count</parameter> bytes may be read.
                The number of bytes actually read is returned.  If the
                end-of-file is encountered before any bytes could be
                read, <literal>&num;!eof</literal> will be returned.
              </para>
            </blockquote>
          </para>
          <para id="func-block-write">
            <indexterm><primary>block-write</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>block-write</methodname>
              <methodparam>
                <parameter>buffer</parameter>
              </methodparam>
              <methodparam>
                <parameter>binary-output-port</parameter>
              </methodparam>
              <methodparam>
                <parameter>count</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Writes <parameter>count</parameter> bytes of data from
                the provided <parameter>buffer</parameter> to the
                given <parameter>binary-output-port</parameter>.  Exactly
                <parameter>count</parameter> bytes will be written.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>binary-input-port?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>binary-input-port?</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                binary input port, &num;f otherwise.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>binary-output-port?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>binary-output-port?</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                binary output port, &num;f otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="SerialIO">
      <title>Serialization</title>
      <para>
        &requires; 
        <emphasis role="bold">
          (import <emphasis>serial-io</emphasis>)
        </emphasis>
      </para>
      <para>
        With <function>read</function> and <function>write</function>,
        Scheme values are read and written in a standardized, textual
        external representation. However, this external representation
        only fully describes a limited subset of Scheme types. For
        instance it is impossible to read/write a procedure, or
        closure, or continuation.
      </para>
      <para>
        &SISC; provides a special port type and procedures for reading
        and writing <emphasis>any</emphasis> Scheme value using a
        binary representation. The (de)serialization preserves the
        referential structure of the object graph comprising the
        serialized values.
      </para>
      <para>
        Serial ports are binary ports, i.e. all operations applicable
        to binary ports also apply to serial ports.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>open-serial-input-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>serial-input-port</type>
              <methodname>open-serial-input-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
		        Creates an input port in the same manner as &R5RS;
                <function>open-input-file</function>, producing an
		        input port that can be used to read external
                representations of Scheme values.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>open-serial-output-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>serial-output-port</type>
              <methodname>open-serial-output-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>auto-flush</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates an output port in the same manner as
                <function>open-output-file</function>, producing an
                output port that can be used to write external
                representations of Scheme values.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>call-with-serial-input-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>call-with-serial-input-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>procedure</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Calls <parameter>procedure</parameter> with a new
                serial input port attached to
                <parameter>url</parameter>. The result of the thunk is
                returned.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>call-with-serial-output-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>call-with-serial-output-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>procedure</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Calls <parameter>procedure</parameter> with a new
                serial output port attached to
                <parameter>url</parameter>. The result of the thunk is
                returned.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>with-serial-input-from-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-serial-input-from-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Evaluates <parameter>thunk</parameter> with a serial
                input port attached to a file opened for reading from
                <parameter>url</parameter> as the
                <literal>current-input-port</literal> for the duration
                of the evaluation. The port is closed when
                <parameter>thunk</parameter> returns normally.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>with-serial-output-to-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-serial-output-to-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Evaluates <parameter>thunk</parameter> with a serial
                input port attached to a file opened for writing to
                <parameter>url</parameter> as the
                <literal>current-output-port</literal> for the
                duration of the evaluation. The port is closed when
                <parameter>thunk</parameter> returns normally.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>deserialize</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>deserialize</methodname>
              <methodparam choice="opt">
                <parameter>serial-input-port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Reads a Scheme value from an external representation
                retrieved from
                <parameter>serial-input-port</parameter>. If
                <parameter>serial-input-port</parameter> is absent the
                data is read from the current input port.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>serialize</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>serialize</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>serial-output-port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Writes an external representation of
                <parameter>value</parameter> to
                <parameter>serial-output-port</parameter>. If
                <parameter>serial-output-port</parameter> is absent
                the data is written to the current output port.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>serial-input-port?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>serial-input-port?</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                serial input port, &num;f otherwise.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>serial-output-port?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>serial-output-port?</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                serial output port, &num;f otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
  </sect1>
  <sect1 id="netio">
    <title>Networking</title>
    <para>
        &requires; 
      <emphasis role="bold">
        (import <emphasis>networking</emphasis>)
      </emphasis>
    </para>
    <para>
      The &SISC; Networking library provides a mechanism for
      creating and manipulating IP network protocols as standard
      Scheme ports.  &SISC; supports TCP, UDP, and Multicast UDP.
      Each is described in the sections that follow.
    </para>
    <para>
      Each protocol provides one or more <emphasis>socket
        constructors</emphasis>.  These functions produce a Socket
      handle, which is represented in &SISC; as
      <computeroutput>&num;&lt;socket&gt;</computeroutput>.  A
      socket handle is then used to obtain Scheme ports.
    </para>
    <para>
      IP addresses and network hostnames are represented as strings in
      &SISC;.  Unless otherwise noted, the network library functions
      that require an address may take a network address as a string
      which may be any of:
    </para>
    <itemizedlist>
      <listitem>
        <para> 
          A hostname, to be resolved through the domain name system.
        </para>
      </listitem>
      <listitem>
        <para> 
          An IPv4 network address in the standard dotted quad format. (RFC-791)
        </para>
      </listitem>
      <listitem>
        <para> 
          An IPv6 network address in colon separated hexadecimal form,
          and zero-shortened form. (RFC-2373)
        </para>
      </listitem>
    </itemizedlist>
    <para>
      IPv6 addresses must be supported by the underlying operating
      system.  An error may be raised if the address is not
      supported.  All IP port values must be exact
      integers in the proper range.
    </para>
    <sect2 id="netutils">
      <title>IP Addressing</title>
      <para>
        Several utility functions are provided for manipulating IP
        addresses.  These are described below.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>get-host-ip-by-name</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string</type>
              <methodname>get-host-ip-by-name</methodname>
              <methodparam>
                <parameter>hostname</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Attempts to resolve a hostname provided as a string into an 
                IP address in dotted-quad form.  If the host cannot be
                found, &f; is returned.
              </para>
            </blockquote>
          </para>
          <para id="func-get-host-name-by-ip">
            <indexterm><primary>get-host-name-by-ip</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string</type>
              <methodname>get-host-name-by-ip</methodname>
              <methodparam>
                <parameter>ip-address</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Attempts a reverse lookup of the given dotted-quad address
                to determine a registered domain name.  If unsuccessful, &f;
                is returned.
              </para>
            </blockquote>
          </para>
          <para id="func-get-local-host">
            <indexterm><primary>get-local-host</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>string</type>
              <methodname>get-local-host</methodname>
              <void/>
            </methodsynopsis>
            <blockquote>
              <para>
                Attempts to determine the Internet visible IP address of the
                local machine.  If successful, this address is returned in
                dotted-quad notation.  &f; is returned otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="sockets">
      <title>Socket Operations</title>
      <para>
        Once obtained using a protocol specific constructor, a
        Socket Handle allows manipulation of common socket options,
        the creation of Scheme input/output ports, and closing of
        the socket.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>socket?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>socket?</methodname>
              <methodparam><parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns true if and only if the provided value is a socket.
              </para>
            </blockquote>
          </para>
          <para id="func-open-socket-input-port">
            <indexterm><primary>open-socket-input-port</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>input-port</type>
              <methodname>open-socket-input-port</methodname>
              <methodparam><parameter>socket</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>encoding</parameter>
              </methodparam>              
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a character input port to the socket.  If the optional <parameter>encoding</parameter>
                parameter is provided, the character port created will
                use the specified encoding rather than the default.
              </para>
            </blockquote>
          </para>
          <para id="func-open-socket-output-port">
            <indexterm><primary>open-socket-output-port</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>output-port</type>
              <methodname>open-socket-output-port</methodname>
              <methodparam><parameter>socket</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>encoding</parameter>
              </methodparam>                                          
              <methodparam choice="opt">
                <parameter>auto-flush</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a character output port to the socket.  If provided, the
                boolean argument specifies whether the given port should be
                set to auto-flush mode.  If unspecified, the port does
                <emphasis>not</emphasis> auto-flush.
                If the optional <parameter>encoding</parameter>
                parameter is provided, the character port created will
                use the specified encoding rather than the default.
              </para>
            </blockquote>
          </para>
          <para id="func-open-binary-socket-input-port">
            <indexterm><primary>open-binary-socket-input-port</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>binary-input-port</type>
              <methodname>open-binary-socket-input-port</methodname>
              <methodparam><parameter>socket</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a binary input port to the socket.  
              </para>
            </blockquote>
          </para>
          <para id="func-open-binary-socket-output-port">
            <indexterm><primary>open-binary-socket-output-port</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>binary-output-port</type>
              <methodname>open-binary-socket-output-port</methodname>
              <methodparam><parameter>socket</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>auto-flush</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a character output port to the socket.  If provided, the
                boolean argument specifies whether the given port should be
                set to auto-flush mode.  If unspecified, the port does
                <emphasis>not</emphasis> auto-flush.
              </para>
            </blockquote>
          </para>          
          <para id="func-close-socket">
            <indexterm><primary>close-socket</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>unspecified</type>
              <methodname>close-socket</methodname>
              <methodparam>
                <parameter>socket</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Closes an IP socket.  
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        The port-obtaining functions above work on most sockets.
        An exception applies for  TCP server sockets, which are used only to
        obtain connected TCP sockets.
      </para>
    </sect2>
    <sect2 id="TCP">
      <title>TCP</title>
      <para>
        The most commonly used Internet protocol maps most favorably
        to Scheme's input/output model.  Writing to an output port
        retrieved from a TCP socket writes the data to that socket.
        Reading from an input port reads from the connected socket.
        One important note is that one can control the amount of data
        that fills a TCP packet by using an output port that does
        not auto-flush.  Data is written to the port until one
        considers the packet complete, and then uses
        <computeroutput>(flush-output-port port)</computeroutput> to
        complete the packet.  Note also that this does not
        <emphasis>guarantee</emphasis> that one gets the desired
        packet size, but does allow one to construct reasonably
        sized packets.
      </para>
      <para>
        TCP sockets are obtained one of two ways.  Either one
        creates an outgoing connection to another listening host and
        then subsequently obtains a socket handle, or one creates a
        <emphasis>listening socket</emphasis> and then obtains a
        socket by waiting for an incoming connection on the
        specified port.  In either case, the result is a socket
        handle with an available input and output port that can be
        obtained using a function in the previous section.
      </para>
      <para>
        <blockquote>
          <para id="func-open-tcp-socket">
            <indexterm><primary>open-tcp-socket</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>socket</type>
              <methodname>open-tcp-socket</methodname>
              <methodparam>
                <parameter>host</parameter>
              </methodparam>
              <methodparam>
                <parameter>port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Attempts to connect to the host at the given hostname or IP
                address encoded as a string, at the given TCP port
                specified as an integer.  An error is raised if the host
                cannot be found or the connection fails.  If successful, 
                a socket is returned.
              </para>
            </blockquote>
          </para>
          <para id="func-open-tcp-listener">
            <indexterm><primary>open-tcp-listener</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>server-socket</type>
              <methodname>open-tcp-listener</methodname>
              <methodparam>
                <parameter>port</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>interface-address</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a TCP server socket, which may only be used with
                accept-tcp-socket, or closed.  The server socket will listen
                on the integer port specified.  If provided, the
                interface-address, a string specifies the address of a
                local interface to bind to.  If not provided, the port
                is bound on all available interfaces.  An error is
                raised if the socket cannot be bound and set listening.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>server-socket?</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>server-socket?</methodname>
              <methodparam><parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns true if and only if the provided value is a server
                socket.
              </para>
            </blockquote>
          </para>
          <para id="func-accept-tcp-socket">
            <indexterm><primary>accept-tcp-socket</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>socket</type>
              <methodname>accept-tcp-socket</methodname>
              <methodparam>
                <parameter>server-socket</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Accepts an incoming connection on the provided
                server-socket, and returns a TCP socket handle.  This
                function will block until an incoming connection is made,
                or, if set, the socket timeout is exceeded.  If the latter
                happens, an error will be raised.
              </para>
            </blockquote>
          </para>
          <para id="func-set-so-timeout">
            <indexterm><primary>set-so-timeout!</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>set-so-timeout!</methodname>
              <methodparam>
                <parameter>socket</parameter>	  
              </methodparam>
              <methodparam>
                <parameter>timeout</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Sets the socket timeout on a socket.  The socket can be
                either a server socket or connected socket.  In the former
                case, this value specifies the number of milliseconds that
                an accept-tcp-socket can wait before timing out.  In the
                latter, the value specifies the number of milliseconds that
                can elapse during a read call before timing out.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="UDP">
      <title>UDP</title>
      <para>
        UDP sockets can be obtained for both receive only and
        send/receive sessions. 
      </para>
      <note>
        <para>
          The behavior of the <function>char-ready?</function>
          function is somewhat more difficult to predict on a UDP
          input port.  The function will return <literal>#t</literal>
          only when a previous datagram contained more bytes than were
          requested by the read operation that received it.
        </para>
      </note>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>open-udp-listen-socket</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>udp socket</type>
              <methodname>open-udp-listen-socket</methodname>
              <methodparam>
                <parameter>listen-port</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>interface-address</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>datagram-size</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a UDP socket that listens on
                <parameter>listen-port</parameter> (optionally bound
                to only the interface on
                <parameter>interface-address</parameter>).  If
                provided, <parameter>datagram-size</parameter>
                specifies the buffer size (in bytes) for receiving UDP
                datagrams.  Datagrams larger than
                <parameter>datagram-size</parameter> are truncated to
                that size.  If unspecified, the default datagram size
                is 1500 bytes.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>open-udp-socket</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>udp socket</type>
              <methodname>open-udp-socket</methodname>
              <methodparam>
                <parameter>remote-host</parameter>
              </methodparam>
              <methodparam>
                <parameter>remote-port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a UDP socket for sending datagrams to 
                the Internet host specified by
                <parameter>remote-host</parameter>, on port
                <parameter>remote-port</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        After obtaining a UDP socket, input and output ports can be
        obtained in the usual manner.  It is an error to attempt to
        obtain an output-port from a listening UDP socket, or an input
        port from a sending UDP socket.  
      </para>
      <para>
        UDP input ports behave as
        ordinary input ports.  When a datagram arrives as a result of
        any read operation on the port, their entire contents are
        stored in a buffer of length
        <parameter>datagram-size</parameter> bytes.  Successive read
        operations return data from that buffer until it is exhausted,
        at which point a read operation will cause the UDP socket to
        listen for another datagram.
      </para>
      <para>
        UDP output ports should be treated with some care, however.
        If a UDP output port was obtained in auto-flush mode, each
        write operation to the output port will cause a new datagram
        to be sent.  Control over the size of the datagram must be
        maintained by using a port that does not auto-flush, writing
        the desired data, and flushing once the amount of data that
        the user wants to occupy a single UDP datagram is reached.
        The behavior of constructing very large UDP packets is
        undefined.  The packet may be silently dropped or (more
        likely) fragmented at the IP layer.
      </para>
    </sect2>
    <sect2>
      <title>Multicast UDP</title>
      <para>
          &SISC; provides support for IP multicast UDP datagrams as
        well.  This allows a program to both send and receive to an IP
        multicast group.  Multicast UDPs are an extension of ordinary
        UDP.  Thus all I/O operations on a Multicast UDP socket are
        subject to the same semantics as an ordinary UDP socket.
      </para>
      <note>
        <para>
          The Multicast UDP library requires that the underlying
          operating system's IP networking stack support Multicast.
          The functions described here may produce an error if the
          operating system does not.
        </para>
      </note>
      <para>
        A program wishing to use multicast UDP sockets must first
        obtain a multicast socket for either listening to a multicast
        group, or for both listening and sending to such a group.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>open-multicast-socket</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>multicast udp socket</type>
              <methodname>open-multicast-socket</methodname>
              <methodparam>
                <parameter>listen-port</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>interface-address</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>datagram-size</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a multicast UDP socket that listens on
                <parameter>listen-port</parameter> (optionally bound
                only to the interface addressed by
                <parameter>interface-address</parameter>.  If
                provided, <parameter>datagram-size</parameter> specifies the
                buffer size (in bytes) for receiving UDP datagrams.
                Datagrams larger than
                <parameter>datagram-size</parameter> are truncated to
                that size.  If unspecified, the default datagram size
                is 1500 bytes.  
              </para>
            </blockquote>
          </para>
          <para>
              &procedure;
            <methodsynopsis language="scheme">
              <type>multicast udp socket</type>
              <methodname>open-multicast-socket</methodname>
              <methodparam>
                <parameter>group</parameter>
              </methodparam>
              <methodparam>
                <parameter>port</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>interface-address</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>datagram-size</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Opens a multicast UDP socket for sending datagrams 
                to the specified multicast
                <parameter>group</parameter>, on the specified
                <parameter>port</parameter>.  The returned socket will
                also be capable of listening to that group on the same
                port (and optionally bound only to the interface
                addressed by <parameter>interface-address</parameter>), 
                though the socket will not initially be a member of
                the group.  If provided,
                <parameter>datagram-size</parameter> specifies the
                buffer size (in bytes) for receiving UDP datagrams.
                Datagrams larger than
                <parameter>datagram-size</parameter> are truncated to
                that size.  If unspecified, the default datagram size
                is 1500 bytes.  
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para> 
        Once a sending socket has been obtained (the second form), an
        output-port can be obtained in the usual manner, and datagrams
        can be immediately sent to the multicast group.  To receive
        datagrams, sockets returned from both forms must
        <emphasis>join</emphasis> a multicast group.  
      </para>
      <para>
        A multicast group is specified by a class D IP address and by a
        standard UDP port number. Class D IP addresses are in the range
        224.0.0.0 to 239.255.255.255, inclusive. The address 224.0.0.0 is
        reserved and should not be used. 
      </para>
      <para>
        Groups are joined and left using the following functions:
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>join-multicast-group</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>join-multicast-group</methodname>
              <methodparam>
                <parameter>multicast-socket</parameter>
              </methodparam>
              <methodparam>
                <parameter>group</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>		
                Causes the given multicast socket to join the group
                specified by the Internet address in
                <parameter>group</parameter>.  Once joined, read
                operations on an obtained input-port will be able to
                receive datagrams destined to that group.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>leave-multicast-group</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>leave-multicast-group</methodname>
              <methodparam>
                <parameter>multicast-socket</parameter>
              </methodparam>
              <methodparam>
                <parameter>group</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>		
                Causes the given multicast socket to leave the group
                specified by the Internet address in
                <parameter>group</parameter>.  Read operations on any
                input ports obtained from this socket will no longer
                receive datagrams from that group.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        A single multicast socket can simultaneously listen to more
        than one multicast group.  A socket can only send to one
        group, however: the group it was constructed with.
      </para>
      <para>
        Multicast packets are limited in extent by their
        time-to-live.  Each time a multicast packet crosses a router,
        its ttl is decremented.  In this manner, one can send
        datagrams only to local networks or subnetworks, as well as
        more grand scopes.  The TTL of a socket is set using
        <function>set-multicast-ttl!</function>
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>set-multicast-ttl!</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>undefined</type>
              <methodname>set-multicast-ttl!</methodname>
              <methodparam>
                <parameter>multicast-socket</parameter>
              </methodparam>
              <methodparam>
                <parameter>ttl</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>		
                Sets the multicast TTL of the given socket to
                <parameter>ttl</parameter>, an integer.  All datagrams
                sent after this call will have their TTL set to the
                new value.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        Valid multicast TTLs are in the range 0 (restricted to the
        same host) to 255 (unlimited in scope).
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Miscellaneous</title>
    <sect2 id="PrettyPrinting">
      <title>Pretty-Printing</title>
      <para>
          &SISC; includes a pretty-printer, a function that behaves like
        <computeroutput>write</computeroutput>, but introduces
        whitespace in order to make the output of data more readable
        to humans.
      </para>
      <para id="func-pretty-print">
        <blockquote>
          <para>
            <indexterm><primary>pretty-print</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>unspecified</type>
              <methodname>pretty-print</methodname>
              <methodparam>
                <parameter>value</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>output-port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Pretty-prints the specified value, either to the specified
                output-port, or to the console if no output-port is
                specified. 
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2>
      <title>Source Loading</title>
      <para>
        The <function>load</function> procedure accepts URLs as well
        as ordinary file names. See <xref linkend="urlfile"/> for
        details on what kinds of URLs are supported.
      </para>
      <para>
        The file name passed to <function>load</function> is resolved
        relative to the <function>current-url</function>
        parameter. During the execution of <function>load</function>,
        <function>current-url</function> is set to the loaded file, so
        that any invocations of <function>load</function> from the
        loaded file resolve the given file name relative to the file
        currently being loaded. For example, lets assume we have a web
        site that serves the following files:
        <programlisting>
 ;;;contents of http://foo.com/bar/bar1.scm ;;;
(load "bar2.scm")
;;;contents of http://foo.com/bar/bar2.scm ;;;
(load "/baz/baz1.scm")
;;;contents of http://foo.com/baz/baz1.scm ;;;
(load "../baz/baz2.scm")
;;;contents of http://foo.com/baz/baz2.scm ;;;
(display "Hello")
        </programlisting>
        Invoking
        <programlisting>
(load "http://foo.com/bar/bar1.scm")
        </programlisting>
        results in each file being loaded; with the last file in the chain,
        <filename>baz2.scm</filename>, displaying
        <computeroutput>Hello</computeroutput>.
      </para>
      <para>
        The <function>load</function> function supports many types of
        files which contain executable code.
        <function>load</function> will attempt to determine (primarily
        by the file's extension) which type of file is being loaded to
        load that file in the correct manner.  The file types
        currently supported are those described in <xref
                                                         linkend="FileExtensions"/>.  
      </para>
      <para>
        When a pure source file is loaded, each s-expression is evaluated
        in sequence, exactly as if entered into the REPL one
        s-expression at a time.
      </para>
    </sect2>
    <sect2>
      <title>Location Tracking</title>
      <para>
          &SISC; allows the location of input, i.e. the file name, line
        number, and column number, to be tracked when reading from an
        input port.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>open-source-input-file</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>input-port</type>
              <methodname>open-source-input-file</methodname>
              <methodparam>
                <parameter>url</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                This procedure behaves the same as
                <function>open-input-file</function>, except that it
                also tracks the location of the input.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>input-port-location</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>input-port-location</methodname>
              <methodparam>
                <parameter>input-port</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the current location information associated
                with <parameter>input-port</parameter>. The return
                value is an association list containing the following
                keys: <literal>source-file</literal>,
                <literal>line-number</literal>,
                <literal>column-number</literal>. If no location
                information is available, &num;f is returned.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>      
    </sect2>
    <sect2 id="Resources">
      <title>Locating Resources</title>
      <para>
          &SISC; provides a mechanism for locating and subsequently
          loading named resources, such as Scheme source files, Scheme
          data files, property files. The resources are located using
          the mechanism described in <xref
          linkend="ClassLoading"/>. This allows Scheme programs to
          load resources in a portable, J2EE-compliant manner.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>find-resource</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>url</type>
              <methodname>find-resource</methodname>
              <methodparam><parameter>string</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Locates the resource named by
                <parameter>string</parameter> on the Java class
                path. The resource location is returned as a URL
                suitable for &SISC; I/O operations. If the resource
                cannot be found, &num;f is returned.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>find-resources</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>url-list</type>
              <methodname>find-resources</methodname>
              <methodparam><parameter>string</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Locates the resource named by
                <parameter>string</parameter> on the Java class path.
                The resource locations are returned as a list of URLs
                suitable for &SISC; I/O operations. If the resource
                cannot be found, an empty list is returned.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="FileManipulation">
      <title>File Manipulation</title>
      <para>
        &requires; 
        <emphasis role="bold">
          (import <emphasis>file-manipulation</emphasis>)
        </emphasis>
      </para>
      <para>
        The file-manipulation library provides access to a number of
        functions for reading and manipulating files and their
        attributes.  The file-manipulation library acts on filenames
        in the same manner as other Scheme file related functions,
        e.g. it accepts file and directory names as strings, which are
        resolved relative to the current URL.  
      </para>
      <para> 
        The following functions act on both files and directories.
        With the exception of <function>file-exists?</function> and
        <function>get-parent-url</function>, the  behavior when
        applying these to non-existant files or directories is
        undefined.
      </para>
      <blockquote>
        <para>
          <indexterm><primary>file-delete!</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-delete!</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Attempts to remove the given file or directory.  If
              successful, <literal>#t</literal> is returned.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-hidden?</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-exists?</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Returns true if the given file or directory exists.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-is-directory?</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-is-directory?</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Returns true if the given string names an existing
              directory.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-is-file?</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-is-file?</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Returns true if the given string names an existing
              file.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-last-modified</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>integer</type>
            <methodname>file-last-modified</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Returns the number of milliseconds since the Unix
              epoch (Jan 1, 1970) of the date the file or directory
              was last modified.  
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-rename!</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-rename!</methodname>
            <methodparam>
              <parameter>source-filename</parameter>
            </methodparam>
            <methodparam>
              <parameter>dest-filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Renames the given source file or directory to the
              destination.  This can be used both to rename a file
              or directory or to move a file/directory in the same
              filesystem.  If successful, <literal>#t</literal> is
              returned.  
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-set-last-modified!</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-set-last-modified!</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
            <methodparam>
              <parameter>unixtime</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Sets the last modified date of the given filename to
              the given integer (in number of milliseconds since the
              epoch).  Returns <literal>#t</literal> if successful.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>get-parent-url</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>string</type>
            <methodname>get-parent-url</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>      
                Given any URL, returns the URL of its parent.  For
                filenames, as an example, the parent directory is
                returned.
              </para>
            </blockquote>
          </para>
      </blockquote>
      <para>
        The following functions operate only on files.  Their behavior
        when applied to directories or non-existant files is undefined.
      </para>
      <blockquote>
        <para>
          <indexterm><primary>file-is-readable?</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-is-readable?</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>     
              Returns <literal>#t</literal> if the file can be opened
              for reading.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-is-writeable?</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-is-writeable?</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>     
              Returns <literal>#t</literal> if the file can be opened
              for writing.
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-length</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>integer</type>
            <methodname>file-length</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Returns the length, in bytes, of the given file.  
            </para>
          </blockquote>
        </para>
        <para>
          <indexterm><primary>file-set-read-only!</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>file-set-read-only!</methodname>
            <methodparam>
              <parameter>filename</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Sets the given file read-only.  Returns
              <literal>#t</literal> if successful.
            </para>
          </blockquote>
        </para>
      </blockquote>
      <para>
        Finally, the following functions are specific to directories.
        Their behavior on files is undefined.  The behavior of
        <function>directory-list</function> is undefined on
        non-existant directories.
      </para>
      <blockquote>
        <para>
          <indexterm><primary>directory-list</primary></indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>list of strings</type>
            <methodname>directory-list</methodname>
            <methodparam>
              <parameter>directory</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>      
              Retrieves the children of the given directory, as a
              list of strings.  Each string names one child, and is
              a filename relative to the given directory.
            </para>
          </blockquote>
        </para>
          <para>
	    <indexterm><primary>make-directory!</primary></indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>#t/#f</type>
              <methodname>make-directory!</methodname>
              <methodparam>
                <parameter>directoryname</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>      
                Attempts to creates the given directory.  Returns
                <literal>#t</literal> if successful.
              </para>
            </blockquote>
          </para>
          <para>
	    <indexterm><primary>make-directories!</primary></indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>#t/#f</type>
              <methodname>make-directories!</methodname>
              <methodparam>
                <parameter>directoryname</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>      
                Attempts to creates the given directory and all
                non-existing parent directories.  Returns
                <literal>#t</literal> if successful.
              </para>
            </blockquote>
          </para>
      </blockquote>
    </sect2>
    <sect2 id="ClassLoading">
      <title>Class Loading</title>
      <para>
        Some &SISC; features require classes and other resources to be
        loaded. By default, &SISC; will use the current thread's class
        loader, or, if none is present, the system class loader. This
        can be augmented using the following functions:
        <blockquote>
          <para>
            <indexterm><primary>current-class-path</primary></indexterm>
            &parameter;
            <methodsynopsis language="scheme">
              <type>string-list</type>
              <methodname>current-class-path</methodname>
              <methodparam choice="opt">
                <parameter>class-path</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Retrieves or sets the current class path. The class
                path is a list of strings representing URLs, typically
                pointing to jar files. When &SISC; attempts to load a
                class or other resource, it searches these locations
                before falling back on the default class loader.
              </para>
              <para>
                The elements of the <parameter>class-path</parameter>
                list are normalized using the
                <parameter>current-url</parameter> (see <xref
                  linkend="urlfile"/>), thus permitting the usage of
                relative URLs.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>with-class-path</primary></indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>with-class-path</methodname>
              <methodparam>
                <parameter>string-list</parameter>
              </methodparam>
              <methodparam>
                <parameter>thunk</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>   
                Evaluates <parameter>thunk</parameter> with a
                <parameter>string-list</parameter> as the setting for
                the <literal>current-class-path</literal>.
              </para>
            </blockquote>
          </para>
        </blockquote>
        Note that <literal>current-class-path</literal> is a 
        <link linkend="Parameters">parameter</link>, so each thread has
        it's own setting, initially inherited from the parent thread.
      </para>
    </sect2>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
