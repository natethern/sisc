<chapter id="JavaInteraction">
  <title>Java Interaction</title>
  <para>
    &SISC; can be used as a scripting language for Java, or Java may be
    used to provide functionality to Scheme. Such activity is collectively
    termed 'bridging'. In &SISC; bridging is accomplished by a Java API
    for executing Scheme code and evaluating Scheme expressions, and a
    module that provides Scheme-level access to Java objects and
    implementation of Java interfaces in Scheme.
  </para>
  <sect1 id="JavaToScheme">
    <title>Java-to-Scheme Interface</title>
    <para>
      Multiple Scheme applications can run within a single &SISC;
      runtime. Each application has its own top level environment and
      evaluator. An application is represented by instances of the
      <classname>sisc.interpreter.AppContext</classname> class.
      
      A Scheme application can execute in multiple threads. Each thread must
      have its own dynamic environment, containing entities such as the current
      input and output ports. Dynamic environments are represented by
      instances of the
      <classname>sisc.env.DynamicEnvironment</classname> class.       
      A thread can be associated with multiple interpreters. The reason for
      there being multiple interpreters is that internal calls need to be
      executed by an interpreter different from the one that initiated the
      internal call so that the state of the latter can be preserved.
      
    </para>
    <sect2>
      <title>Calling Scheme From Java</title>
      <para>
        A call from Scheme to Java can occur in one of two places:
        <itemizedlist>
          <listitem>
            <para>
              Within a call from Scheme to Java - we shall call this an
              <quote>internal call</quote>.
            </para>
          </listitem>
          <listitem>
            <para>
              Elsewhere, e.g. as the result of a timer expiration or
              as part of a thread created by Java - we shall call this
              an <quote>external call</quote>.
            </para>
          </listitem>
        </itemizedlist>
        The <classname>sisc.interpreter.Context</classname> class is the key
        point where both the above call scenarios are managed.
      </para>
      <sect3>
        <title>Internal Calls</title>
        <para>
          When making an internal call, one typically wants to do that in an
          interpreter that shares the same <classname>AppContext</classname> and
          <classname>DynamicEnvironment</classname> as the calling interpreter. One can
          get hold of such an interpreter using
          <programlisting>
Interpreter r = Context.enter();
          </programlisting>
          One can determine if a call is internal in the following manner:
          <programlisting>
Interpreter current = Context.currentInterpreter();
if (current == null) { ...make external call...}
else { ...make internal call... }
          </programlisting>
          The calls themselves are made using one of the three
          <function>eval</function> methods on the
          <classname>sisc.interpreter.Interpreter</classname>:
          <indexterm><primary>eval</primary>
          </indexterm>
          
          <itemizedlist>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>String</type>
                  <parameter>expr</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Evaluates expressions read from a string, returning
                  the result of the evaluation of the last
                  expression.
                </para>
              </blockquote>
            </listitem>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>InputStream</type>
                  <parameter>stream</parameter>
                </methodparam>
                <methodparam>
                  <type>String</type>
                  <parameter>sourceId</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Evaluates expressions read from an input stream, returning
                  the result of the evaluation of the last
                  expression. The <parameter>sourceId</parameter>
                  identifies the source of the stream for display
                  purposes.
                </para>
              </blockquote>
            </listitem>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>Value</type>
                  <parameter>val</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  This is the same as calling <literal>(eval
                  </literal><parameter>val</parameter><literal>)
                  </literal> in Scheme.
                </para>
              </blockquote>
            </listitem>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>Procedure</type>
                  <parameter>proc</parameter>
                </methodparam>
                <methodparam>
                  <type>Value[]</type>
                  <parameter>args</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  This is the same as calling
                  <literal>(</literal><parameter>proc</parameter>
                  <parameter>arg</parameter> ...<literal>) </literal> in
                  Scheme.
                </para>
              </blockquote>
            </listitem>
          </itemizedlist>
          Several such calls can be made on the same interpreter.
        </para>
        <para>
          Before returning from the code that is making the internal
          calls one must call
          <programlisting>
Context.exit()
          </programlisting>
          in order to release the resources associated with the call
          context.
        </para>
      </sect3>
      <sect3>
        <title>External Calls</title>
        <para>
          The main challenge when making external calls is what
          application and dynamic environment to make them
          in. <classname>sisc.interpreter.Context</classname> maintains an application
          registry. To register an application call
          <programlisting>
Context.register("appname", appContext)
          </programlisting>
          The application registry can be used to obtain new
          interpreters that are associated with specific applications
          and have a fresh dynamic environment:
          <programlisting>
Interpreter r = Context.enter("appname");
          </programlisting>
          <classname>AppContext</classname>s are usually created by
          calling their argument-less constructor and are later
          modified by loading a heap image into them.  Heap images 
          are randomly accessable, and as such must be accessed in
          their entirety, rather than as a stream.  If not loaded
          from disk, this entails first transfering the image over a
          stream into memory, then operating on the entire heap in
          memory.
          A typical initialization sequence, loading the heap image
          from disk, would be:
          <programlisting>
AppContext ctx = new AppContext();
Context.register("myapp", ctx);
Interpreter r = Context.enter("myapp");
ctx.loadEnv(r, new SeekableDataInputStream(new BufferedRandomAccessInputStream("sisc.shp","r")));
Context.exit();
          </programlisting> 
        </para>
        <para>
          Sometimes one may want to use a different mechanism for
          finding applications and dynamic environments. For instance,
          threads created from Scheme should probably execute within
          the application that created them and using a dynamic
          environment that is cloned from the dynamic environment
          present when the thread is started. There is therefore a
          general mechanism for obtaining a new interpreter that uses
          a specific application and dynamic environment:
          <programlisting>
Interpreter r = Context.enter(appContext, dynamicEnv);
          </programlisting>
          External calls are made in the same way as internal calls,
          e.g. using one of the eval methods. Before returning from
          the code that is making the external calls one must call
          <programlisting>
Context.exit()
          </programlisting>
          in order to release the resources associated with the call
          context.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Miscellaneous Features</title>
      <sect3 id="JErrorHandling">
        <title>Error Handling</title>
        <para>
          <literal>Interpreter.eval()</literal> throws a
          <classname>sisc.interpreter.SchemeException</classname> when an evaluation
          causes an exception that is not caught inside the
          evaluation. When making internal calls the exception can be
          propagated to the calling interpreter in one of four ways:
          <itemizedlist>
            <listitem>
              <para>
                by throwing a <classname>RuntimeException</classname>
                - this will be reported as<literal>"Error in
                "</literal><parameter>prim-name</parameter><literal>:
                </literal><parameter>description</parameter><literal>"</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                by calling
                <literal>Module.throwPrimException("</literal><parameter>description</parameter><literal>")</literal>
                - this will be
                reported as <literal>"Error in
                </literal><parameter>prim-name</parameter><literal>:
                </literal><parameter>description</parameter><literal>"</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                by calling
                <literal>throwNestedPrimException("</literal><parameter>description</parameter><literal>",
                </literal><parameter>schemeException</parameter><literal>)</literal>
                - this will be reported as <literal>"Error in
                </literal><parameter>prim-name</parameter><literal>:
                </literal><parameter>description</parameter><literal>\n</literal><parameter>nested-description</parameter><literal>"</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                by calling
                <literal>throwNestedPrimException(</literal><parameter>schemeException</parameter><literal>)</literal>
                - this will be reported as <literal>"Error in
                </literal><parameter>prim-name</parameter><literal>:
                exception during nested
                call\n</literal><parameter>nested-description</parameter><literal>"</literal>.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Scheme code can throw Java exceptions (see <xref
          linkend="S2JExceptions"/>). The
          <classname>sisc.modules.s2j.Util</classname> class contains
          a static method
          <literal>javaException(</literal><parameter>schemeException</parameter><literal>)</literal>
          that extracts the Java exception from a
          <literal>SchemeException</literal>, or, if no Java exception
          is present, returns the <literal>SchemeException</literal>.
        </para>
      </sect3>
      <sect3 id="JContinuations">
        <title>Continuations</title>
        <para>
          Continuations do not cross the Scheme/Java boundary. In the
          embedded call scenario invoking a continuation inside the
          embedded call will not discard the computation of the
          caller. The embedded call will return when the continuation
          returns. If the continuation contains the read-eval-print
          loop the return will never happen. Similarly, capturing a
          continuation inside a call (embedded or external) will only
          capture the continuation to point where the call was made.
        </para>
        <para>
          Capturing and invoking a continuation within the
          <emphasis>same</emphasis> call works correctly.
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="SchemeToJava">
    <title>Scheme-to-Java Interface</title>
    <para>
      &requires; 
      <emphasis role="bold">
        (import <emphasis>s2j</emphasis>)
      </emphasis>
    </para>
    <para>
      A significant proportion of the module's functionality is
      offered through tight integration with the 
      <link linkend="GenericProcedures">generic procedures</link> mechanism.
    </para>
    <sect2>
      <title>Java Objects</title>
      <para>
        Java objects are exposed to the Scheme world as instances of a
        special data type that is disjoint from all other Scheme
        types.
      </para>
      <blockquote>
        <para>
          <indexterm><primary>java-object?</primary>
          </indexterm>
          &procedure;
          <methodsynopsis language="scheme">
            <type>&num;t/&num;f</type>
            <methodname>java-object?</methodname>
            <methodparam><parameter>value</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              returns &num;t if <parameter>value</parameter> is a Java
              object, &num;f otherwise.
            </para>
          </blockquote>
        </para>
      </blockquote>
      <sect3>
        <title>Object Types</title>
        <para>
          Some types of Java objects are handled specially, namely
          classes, interfaces, arrays and <constant>null</constant>. A
          set of predicates ascertains whether a Java object is of one
          of these special types.
        </para>
        <blockquote>
          <simplelist>
            <member>
              <indexterm><primary>java-class?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-class?</methodname>
                <methodparam><parameter>value</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              <indexterm><primary>java-interface?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-interface?</methodname>
                <methodparam><parameter>value</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              <indexterm><primary>java-array?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-array?</methodname>
                <methodparam><parameter>value</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              <indexterm><primary>java-null?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-null?</methodname>
                <methodparam><parameter>value</parameter></methodparam>
              </methodsynopsis>
            </member>
          </simplelist>
          <blockquote>
            <para>
              Ascertains whether <parameter>value</parameter> is a Java
              class, interface, array or is <constant>null</constant>.
            </para>
          </blockquote>
        </blockquote>
        <para>
          Generally all java objects can be invoked as procedures. The result
          of the invocation depends on the type of object and the
          arguments.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
              <methodparam><parameter>fieldname</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java object's instance or
                static member field. <parameter>jobj</parameter> can
                be any Java object. <parameter>fieldname</parameter>
                denotes the field name and must be supplied as a
                symbol. It is converted to a Java field name using the
                <function>java-mangle-field-name</function> procedure.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jclass</parameter></methodparam>
              <methodparam><parameter>fieldname</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java class' static member
                field. <parameter>jclass</parameter> can be any Java
                class. <parameter>fieldname</parameter> denotes the
                field name and must be supplied as a symbol. It is
                converted from a to a Java field name using the
                <function>java-mangle-field-name</function> procedure.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jarray</parameter></methodparam>
              <methodparam><parameter>index</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of a Java array element.
                <parameter>jarray</parameter> can be any Java array
                object. <parameter>index</parameter> can be either a
                number or, for multi-dimensional arrays, a list or vector
                of numbers.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Java Beans</title>
        <para>
          Access to Java Bean properties is accomplished by invoking a
          Java object with a list of field names instead of the single
          field name supplied for ordinary field access.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
              <methodparam><parameter>prop-list</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java object's bean property
                <parameter>jobj</parameter> can be any Java
                object. <parameter>prop-list</parameter> is a list of
                property names, supplied as symbols, and must contain
                at least one element. The symbols are converted to
                bean property names using the
                <function>java-mangle-field-name</function> procedure.
              </para>
              <para>
                If <parameter>prop-list</parameter> contains more than
                one element then a nested lookup is performed,
                i.e. the first property is looked up on the
                <parameter>jobj</parameter>, the second property is
                looked up on the resulting object, and so on until the
                final property in the list, which is retrieved from or
                set on the object resulting from the preceding lookup.
              </para>
              <para>
                The bean property access falls back on normal field
                access if the named bean property cannot be found.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Object Comparison</title>
        <para>
          Comparing Java objects using <function>eq?</function>
          compares the objects using Java's <function>==</function>
          comparison. <function>equal?</function>, on the other hand,
          compares the objects using Java's
          <function>equals</function> method. Applying either
          <function>eq?</function> or <function>equal?</function> to a
          mixture of Java objects and other Scheme values returns
          &num;f.
        </para>
      </sect3>
      <sect3>
        <title>Object Serialization</title>
        <para>
          The objects representing Java classes, fields, methods and
          constructors can be (de)serialized. Objects representing
          ordinary Java objects cannot be (de)serialized.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Instantiating Java Classes and Invoking Methods</title>
      <para>

      </para>
      <sect3>
        <title>Object Creation</title>
        <para>
          Java objects can be created by Scheme code by invoking
          <function>make</function> with a class object as the first
          parameter followed by any number of Java objects, e.g.
          <programlisting>
(define sb (make &lt;jstringbuffer&gt; (-&gt;jstring "foo")))
          </programlisting>
          <constant>&lt;jstringbuffer&gt;</constant> is bound to the
          object representing the Java class
          <classname>java.lang.StringBuffer</classname>. The angle
          brackets are only a notational convention for denoting
          variables bound to class
          objects. <function>-&gt;jstring</function> converts a Scheme
          string into a Java string. In <xref linkend="JavaClasses"/>
          we explain how to get hold of class objects and in <xref
          linkend="S2JConversions"/> we show how to convert between
          Scheme and Java objects.
        </para>
        <para>
          The <function>make</function> procedure calls a generic
          constructor which is chained to a generic constructor that
          is obtained as follows
          <blockquote>
            <para>
              <indexterm><primary>generic-java-constructor</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>generic-java-constructor</methodname>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a generic constructor that contains all Java
                  constructors of all classes. Its main purpose is to
                  allow new constructors (besides
                  <function>make</function>) to be defined that (like
                  <function>make</function>) are chaining all Java
                  constructors.
                </para>
                <para>
                  If the <parameter>next-proc</parameter> parameter is
                  specified, the generic constructor is chained to
                  that procedure, which must be a generic constructor.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          The types of the parameters passed to
          <function>make</function> determine which constructor is
          invoked. Normally this is a constructor defined in
          Java. Note however that that Scheme code can define new
          constructors or overload/override existing constructors via
          the <function>define-constructor</function> macro, and
          add post-creation initialization code by defining methods on
          the <function>initialize</function> generic procedure. See
          <xref linkend="GenericProcedures"/> for details of the
          object creation/initialization mechanism.
        </para>
        <para>
          Due to the implicit or
          chaining of the generic constructor invoked by
          <function>make</function> to the generic Java constructor,
          constructors defined in Scheme take precedence over
          constructors defined in Java. They are not visible to Java
          code. They must invoke a Java constructor in order to
          actually create a Java object. Typically this is done via
          the <function>next-method</function> feature of the generic
          procedures mechanism.
        </para>
        <para>
          Note that <function>make</function> cannot create Java
          arrays. This is done by a special procedure instead.
          <blockquote>
            <para>
              <indexterm><primary>java-array-new</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>jarray</type>
                <methodname>java-array-new</methodname>
                <methodparam><parameter>jclass</parameter></methodparam>
                <methodparam><parameter>dimensions</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a Java array. <parameter>jclass</parameter>
                  determines the type of array
                  elements. <parameter>dimensions</parameter> determines
                  the size of the array and can be either a number or, for
                  multi-dimensional arrays, a list or vector of numbers.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3 id="JavaMethodInvocation">
        <title>Method Invocation</title>
        <para>
          Scheme code can invoke Java methods via generic procedures,
          e.g.
          <programlisting>
(define-generic to-string)
(to-string sb)
          </programlisting>
          which calls the <function>toString</function> method on the
          <classname>java.lang.StringBuffer</classname> instance
          defined above.
        </para>
        <para>
          Generic procedures defined with
          <function>define-generic</function> are by default chained
          to special generic procedures obtained as follows:
          <blockquote>
            <para>
              <indexterm><primary>generic-java-procedure</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>generic-java-procedure</methodname>
                <methodparam><parameter>method-name</parameter></methodparam>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a generic procedure that contains all Java
                  methods of name <parameter>method-name</parameter>
                  of all classes.
                </para>
                <para>
                  If the <parameter>next-proc</parameter> parameter is
                  specified, the generic procedure is chained to it.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          <function>generic-java-procedure</function> mangles the name
          of the methods so. This way, generic procedures can follow
          the usual Scheme naming conventions and get chained to
          generic procedures that invoke Java methods with names
          following usual Java naming conventions. The name mangling
          is performed by
          <blockquote>
            <para>
              <indexterm><primary>java-mangle-method-name</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>symbol</type>
                <methodname>java-mangle-method-name</methodname>
                <methodparam><parameter>name</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Converts a Scheme procedure name, supplied as a
                  symbol in <parameter>name</parameter> into a Java
                  method name in accordance with the following rules:
                  <orderedlist>
                    <listitem>
                      <para>
                        Any trailing <literal>!</literal> is removed.
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Any trailing <literal>?</literal> is removed
                        and a leading <literal>is-</literal> added
                        instead.
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Any occurrence of <literal>-</literal> is
                        removed and the character following it is
                        converted to upper case.
                      </para>
                    </listitem>
                  </orderedlist>
                </para>
                <para>
                  With these rules, <function>foo-bar-baz?</function>
                  maps to <function>isFooBarBaz</function>.
                </para>
              </blockquote>
            </para>
            <para>
              <indexterm><primary>java-mangle-field-name</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>symbol</type>
                <methodname>java-mangle-field-name</methodname>
                <methodparam><parameter>name</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Converts a Scheme symbol into a Java field name by
                  removing any occurence of the <literal>-</literal>
                  character and converting the character following it
                  to upper case.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          Sometimes the names of Java methods make it inconvenient to
          define generic functions with the right names needed for the
          automatic chaining described above to work. For instance,
          the names might clash with those of well-known Scheme
          procedures. To overcome this problem,
          <function>define-generic</function> can take a second
          argument that makes the chaining explicit. Using the above
          <function>generic-java-procedure</function> it is thus
          possible to avoid name clashes as follows:
          <programlisting>
(define-generic app (generic-java-procedure 'append))
(app sb (-&gt;jstring "foo"))
          </programlisting>
          The invocation of <function>app</function> selects the
          appropriate <function>append</function> method on
          <classname>java.lang.StringBuffer</classname>
        </para>
        <para>
          The types of the parameters passed when invoking a generic
          procedure determine which method is invoked. Unlike Java,
          method selection is completely dynamic depending on the
          types of all parameters, including the first one, which, in
          the Java world, corresponds to the target object of a method
          invocation. Also, note that Scheme code can define new
          methods and overload/override existing methods via the
          <function>define-method</function> macro defined in <xref
          linkend="GenericProcedures"/>. These methods are not visible
          to Java code and the implicit (or explicit) chaining of
          ordinary generic procedures to the generic procedures
          obtained from <function>generic-java-procedure</function>
          results in all Scheme-defined methods taking precedence over
          Java methods.
        </para>
        <para>
          Static Java methods can be invoked by calling the
          appropriate generic procedure with a class as the first
          argument. Note that, unlike in Java, it is not possible to
          invoke a static method on an instance. The type signature of
          static Java methods has
          <literal>(</literal><function>meta</function>
          <parameter>class</parameter><literal>)</literal> as the type
          of the first argument (see <xref
          linkend="GenericProcedures"/> for a description of
          <function>meta</function>). Hence, static Java methods can
          be overridden by Scheme methods with a similar type
          signature.
        </para>
      </sect3>
      <sect3 id="JavaClasses">
        <title>Classes</title>
        <para>
          The primary means of getting hold of a Java class is
          <blockquote>
            <para>
              <indexterm><primary>java-class</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>jclass</type>
                <methodname>java-class</methodname>
                <methodparam><parameter>classname</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Resolves <parameter>classname</parameter> to a Java
                  class. Classes are loaded as described in <xref
                  linkend="ClassLoading"/>. <parameter>classname</parameter>
                  can be a string or symbol and must be one of the
                  following:
                  <itemizedlist spacing="compact">
                    <listitem>
                      <para>
                        a fully-qualified name of a Java class or
                        interface
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        the name of a primitive type,
                        e.g. <literal>"int"</literal>
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        one of the above followed by any number of
                        <literal>[]</literal>, denoting an array type
                      </para>
                    </listitem>
                  </itemizedlist>
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          By convention, names of constants bound to class objects are
          constructed by enclosing the fully qualified class name in
          angle brackets, e.g.
          <programlisting>
(define &lt;java.util.Comparator&gt; (java-class "java.util.Comparator"))
          </programlisting>
          An exception are primitive types and classes defined in the
          <classname>java.lang</classname> (excluding the wrapper
          classes for primitive types, such as
          <classname>java.lang.Integer</classname>). The
          <literal>s2j</literal> module exports pre-defined bindings
          for these in an abbreviated notation that only uses the type
          name or down-cased unqualified class name prefixed with the
          letter <literal>j</literal>,
          e.g. <literal>&lt;jint&gt;</literal>,
          <literal>&lt;jobject&gt;</literal>.
        </para>
        <para>
          The class of an object can be obtained with
          <blockquote>
            <para>
              <indexterm><primary>java-class-of</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>jclass</type>
                <methodname>java-class-of</methodname>
                <methodparam><parameter>jobj</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns the class of which <parameter>jobj</parameter>
                  is an instance.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          It is also possible to check whether a Java object is an
          instance of a particular Java class and whether instances of
          one Java class can be assigned to variables whose declared
          type is that of another.
          <blockquote>
            <para>
              <indexterm><primary>java-instance?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-instance?</methodname>
                <methodparam><parameter>jclass</parameter></methodparam>
                <methodparam><parameter>jobj</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if <parameter>jobj</parameter> is an
                  instance of <parameter>jclass</parameter> or one of its
                  sub-classes, or, if <parameter>jclass</parameter> is an
                  interface, implements <parameter>jclass</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
          <blockquote>
            <para>
              <indexterm><primary>java-assignable?</primary>
              </indexterm>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-assignable?</methodname>
                <methodparam><parameter>jclass1</parameter></methodparam>
                <methodparam><parameter>jclass2</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if instances of
                  <parameter>jclass2</parameter> can be assigned to
                  variables, fields, parameters whose type has been
                  declared as <parameter>jclass1</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          Unlike in Java, primitive types are sub-types of their
          respective <classname>java.lang</classname> classes. Note
          however that no widening conversion takes place, because
          Java does not define widening conversions for the java.lang
          classes corresponding to the primitive types, e.g. a
          <classname>java.lang.Byte</classname> is not assignable to a
          <classname>java.lang.Integer</classname> and thus, unlike in
          Java, <classname>byte</classname> is not assignable to
          <classname>int</classname>.
        </para>
      </sect3>
      <sect3 id="S2JConversions">
        <title>Converting between Scheme and Java Types</title>
        <para>
          When calling Java methods and constructors through generic
          procedures, or when setting/getting fields of Java objects
          and classes, <emphasis>no</emphasis> automatic conversion
          between Scheme types and Java types is performed, e.g. one
          cannot simply call a Java method that takes an
          <classname>int</classname> with a Scheme number or expect a
          <classname>java.lang.String</classname> returned from a
          method invocation to be converted to a Scheme
          string. Automatic conversion is not done for the following
          reasons:
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                For some Scheme types, such as numbers, the mapping to
                Java types is one-to-many, e.g. a Scheme number could
                be converted to a <classname>byte</classname>,
                <classname>short</classname>,
                <classname>int</classname>, etc. This causes
                ambiguities when automatic conversion of parameters is
                attempted.
              </para>
            </listitem>
            <listitem>
              <para>
                Some Java types have several corresponding Scheme
                types, e.g. a Java array could be represented as
                Scheme list or vector - this causes ambiguities when
                automatic conversion of results is attempted.
              </para>
            </listitem>
            <listitem>
              <para>
                Conversion carries an overhead that can be
                significant. For instance, Java strings have to be
                copied "by value" to Scheme strings since the former
                are immutable and the latter aren't. In a chained-call
                scenario, i.e. where the results of one method
                invocation are passed as arguments to another, the
                conversion is unnecessary and a wasted effort.
              </para>
            </listitem>
            <listitem>
              <para>
                Conversion breaks the object identity relationship. In
                a chained-call scenario, the identities of the objects
                passed to the second call are different from the ones
                returned by the first. This causes problems if the
                called Java code relies on the object identity being
                preserved.
              </para>
            </listitem>
            <listitem>
              <para>
                Conversion conflicts with generic procedures. The
                method selection mechanism employed by generic
                procedures relies on objects having exactly one
                type. Automatic conversion effectively gives objects
                more than one type - their original type and the type
                of the objects they can be converted to. While it
                would be technically possible to devise a method
                selection algorithm that accommodates this, the
                algorithm would impose a substantial overhead on
                generic procedure invocation and also make it
                significantly harder for users to predict which method
                will be selected when invoking a generic procedure with
                a particular set of arguments.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Instead of implicit conversion, the <literal>s2j</literal>
          module provides a general explicit conversion mechanism that
          can be used to explicitly convert from Scheme to Java types
          and visa versa. In fact this procedure can in principle also
          be used to convert between Scheme types and between Java
          types in a future version. The general conversion procedure
          is
        </para>
        <blockquote>
          <para>
            <indexterm><primary>-&gt;</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>proc</type>
              <methodname>-&gt;</methodname>
              <methodparam><parameter>type</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns a procedure that when invoked will convert its
                argument into an object of type
                <parameter>type</parameter>. For example
                <programlisting>
((-&gt; &lt;jstring&gt;) "foo")
                </programlisting>
                converts the Scheme string <literal>"foo"</literal> into a
                Java string. Typically the returned procedure takes just
                one argument - the object to be converted. There are
                however some special cases where additional information is
                needed in order to perform a conversion and this would be
                supplied in additional arguments.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          <function>-&gt;</function> is an ordinary generic procedure,
          so it is actually possible to define custom conversion, e.g.
          <programlisting>
(define-method (-&gt; ((meta &lt;jstring&gt;) _)) -&gt;jstring)
          </programlisting>
        </para>
        <para>
          For most of the conversion procedures returned by
          <function>-&gt;</function> there are top-level bindings
          consisting of the type name prefixed with
          <literal>-&gt;</literal>, e.g. <literal>(-&gt;jint
          2)</literal>. Note that doing this is a lot more efficient
          than using <function>-&gt;</function> since
          <function>-&gt;</function> is defined in terms of the
          specialized conversion procedures, i.e. just like in the
          above example. Also, there are some
          conversion that cannot be accomplished with
          <function>-&gt;</function>. One such case is conversion to
          Java arrays since there is no general array type in Java and
          hence no type object that could be used as the parameter to
          <function>-&gt;</function>. Instead there is
        </para>
        <blockquote>
          <para>
            <indexterm><primary>-&gt;jarray</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jarray</type>
              <methodname>-&gt;jarray</methodname>
              <methodparam><parameter>list-or-vector</parameter></methodparam>
              <methodparam><parameter>jclass</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Converts <parameter>list-or-vector</parameter> into a Java
                array whose element type is <parameter>jclass</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          All Scheme types have a corresponding type objects, which
          are bound to identifiers in the top-level environment,
          eg. <literal>&lt;void&gt;</literal>,
          <literal>&lt;boolean&gt;</literal>,
          <literal>&lt;number&gt;</literal> etc. Hence, for instance
          <programlisting>
((-&gt; &lt;number&gt;) (-&gt;jint 1))
(-&gt;number (-&gt;jint 1))
          </programlisting>
          both convert the Scheme number <literal>1</literal> into a Java
          <classname>int</classname> and back into a Scheme number.
        </para>
      </sect3>
      <sect3 id="S2JExceptions">
        <title>Exceptions</title>
        <para>
          Java exceptions are propagated to scheme and can be caught
          like any other exception, e.g. with
          <function>with/fc</function> as defined in <xref
          linkend="FailureContinuations"/>. For example
          <programlisting>
(define-generic char-at)
;;chain Scheme print-stack-trace to Java printStackTrace
(define-generic print-stack-trace
  (generic-java-procedure '|printStackTrace| print-stack-trace))
(with/fc (lambda (m e) (print-stack-trace m) #f)
  (lambda () (char-at (-&gt;jstring "foo") (-&gt;jint 3))))
          </programlisting>
          will catch the
          <classname>IndexOutOfBoundsException</classname>, print its
          stack trace and return &num;f.
        </para>
        <para>
          In Scheme, Java exceptions can be thrown by raising an error
          containing the Java exception as the message, e.g.
          <programlisting>
(error (make &lt;java.util.NoSuchElementException&gt;))
          </programlisting>
          or
          <programlisting>
(throw (make-error (make &lt;java.util.NoSuchElementException&gt;)))
          </programlisting>
          If this occurs inside a proxy method (see <xref
          linkend="JavaProxies"/>), the exception is propagated to the
          invoking Java code.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Miscellaneous Features</title>
      <para>
      </para>
      <sect3>
        <title>Wrapping Scheme Values</title>
        <para>
          Sometimes we may want to pass Scheme values to Java as
          parameters in method calls and as values for fields without
          converting them into Java objects. For instance, we may want
          to store and retrieve Scheme values in/from an instance of
          a Java collection class such as
          <classname>java.util.HashSet</classname>. This can be done
          with the help of two procedures that wrap and and unwrap
          Scheme values.
        </para>
        <blockquote>
          <para>
            <indexterm><primary>java-wrap</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname>java-wrap</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Wraps a Scheme value so it can be passed in call to a
                Java method / constructor or when setting a field of a
                Java object or class.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>java-unwrap</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>obj</type>
              <methodname>java-unwrap</methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Casts a Java object into a Scheme value, so a Scheme
                value returned by a Java method or when accessing a Java
                field can be used in Scheme code.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          Since all Scheme values are represented internally as Java
          objects anyway, the wrapping and unwrapping preserves object
          identity.
        </para>
        <para>
          At present, the invocation of Java methods and constructors
          via generic procedures automatically wraps Scheme values
          arguments. This is done purely in order to ensure
          consistency with the present type system, which does not
          distinguish between Scheme values and their internal
          representation.
        </para>
      </sect3>
      <sect3>
        <title>Null</title>
        <para>
          In Java, <literal>null</literal> is an untyped object. Any
          object parameter in a method can be set to
          <literal>null</literal> on invocation and any object/class
          field can be assigned a <literal>null</literal> value.
        </para>
        <para>
          By contrast, the Scheme values representing Java
          <literal>null</literal> are typed. This allows generic
          function invocation to use the type information for method
          selection, otherwise it would be impossible to invoke
          methods with <literal>null</literal> parameters.
        </para>
        <blockquote>
          <para>
            <indexterm><primary>java-null</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname>java-null</methodname>
              <methodparam choice="opt">
                <parameter>jclass</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a Scheme value representing a Java
                <literal>null</literal> object of a specific type. If
                <parameter>jclass</parameter> is absent, it defaults
                to <classname>java.lang.Object</classname>.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          For convenience there is a constant <literal>jnull</literal>
          that represents the Java <literal>null</literal> object of
          type <classname>java.lang.Object</classname>.
        </para>
        <para>
          All objects representing Java <literal>null</literal> are
          equal with respect to <function>equal?</function>, but are
          only equal with respect to <function>eq?</function> if they
          have the same type.
        </para>
        <para>
          Method invocation and field access returns
          <literal>null</literal> objects of the method's declared
          return type / the field's declared type. This ensures that
          chained invocation is possible in the presence of
          <literal>null</literal> returns.
        </para>
      </sect3>
      <sect3 id="JavaProxies">
        <title>Proxies</title>
        <para>
          The <literal>s2j</literal> module provides a mechanism by
          which Scheme code can construct objects that implement
          particular Java interfaces, with the methods required by the
          interfaces being implemented in Scheme. This is accomplished
          by means of the following macro
        </para>
        <blockquote>
          <para>
            <indexterm><primary>define-java-proxy</primary>
            </indexterm>
            &syntax;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>define-java-proxy</methodname>
              <methodparam><parameter>func-spec</parameter></methodparam>
              <methodparam><parameter>interface-spec</parameter></methodparam>
              <methodparam rep="repeat">
                <parameter>method-spec</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <simplelist>
                <member>
                  where <parameter>func-spec</parameter> is of the form
                  <literal>(</literal><parameter>name</parameter>
                  <parameter>arg</parameter> ...<literal>)</literal>
                </member>
                <member>
                  and <parameter>interface-spec</parameter> is of the
                  form <literal>(</literal><parameter>jclass</parameter>
                  ...<literal>)</literal> or
                  <parameter>jclass</parameter>
                </member>
                <member>
                  and <parameter>method-spec</parameter> is of the form
                  <literal>(method
                    (</literal><parameter>name</parameter>
                  <literal>(</literal><parameter>type</parameter>
                  <parameter>param</parameter><literal>)</literal>
                  ...<literal>)
                    . </literal><parameter>body</parameter><literal>)</literal>
                </member>
              </simplelist>
              <para>
                Defines a proxy constructor in the current
                environment. A proxy constructor is a procedure that
                when invoked creates a Java object that implements a
                certain set of Java interfaces in terms of Scheme code
                which is parameterized by a set of arguments passed to
                the constructor on invocation. The object resulting from
                invoking the proxy constructor can be passed to any Java
                constructor or method as a parameter whose type is one
                of the interfaces (or super-interface thereof)
                implemented by the proxy. Method invocations by Java (or
                indeed Scheme) on the object result in execution of one
                of the methods declared method bodies, selected based on
                its name and type signature. If no such method is found
                an error is raised.
              </para>
              <para>
                <parameter>name</parameter> is the name to which to bind
                the proxy constructor in the current environment. The
                <parameter>arg</parameter>s parameterize the proxy
                constructor and are bound in the lexical environment of
                <parameter>body</parameter>. <parameter>interface-spec</parameter>
                specifies what interface(s) should be implemented by
                this proxy. All <parameter>jclass</parameter> must be
                Java <emphasis>interfaces</emphasis> - proxies cannot
                sub-class Java <emphasis>classes</emphasis>.  The
                <parameter>name</parameter>s and
                <parameter>type</parameter>s of the methods must
                <emphasis>exactly</emphasis> match those of the methods
                on the Java interfaces. An error is raised at
                declaration-time when this is not the case. This is
                likely to change in a future version and name mangling
                and "best match" policy similar to the one used by
                generic procedures will be employed.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          An example might be helpful at this stage:
          <informalexample>
            <programlisting>
(define &lt;java.util.Comparator&gt; (java-class "java.util.Comparator"))
(define &lt;java.util.Arrays&gt; (java-class "java.util.Arrays"))
(define-java-proxy (comparator fn) &lt;java.util.Comparator&gt;
  (method (compare (&lt;jobject&gt; obj1) (&lt;jobject&gt; obj2))
    (let ((x (java-unwrap obj1))
          (y (java-unwrap obj2)))
      (-&gt;jint (cond ((fn x y) -1)
                    ((fn y x) +1)
                    (else 0))))))
(define-generic sort)
(define (list-sort comp l)
  (let ([a (-&gt;jarray (map java-wrap l) &lt;jobject&gt;)])
    (sort &lt;java.util.Arrays&gt; a comp)
    (map java-unwrap (-&gt;list a))))
(list-sort (comparator &lt;) '(3 4 2 1))
;=&gt; '(1 2 3 4)
(list-sort (comparator string&lt;?) '("foo" "bar" "baz"))
;=&gt;'("bar" "baz" "foo")
            </programlisting>
            <para>
              This defines a proxy constructor
              <function>comparator</function> that implements the
              <classname>java.util.Comparator</classname> interface
              top perform comparison of arbitrary Scheme
              objects. There is only one method that needs to be
              implemented - <function>compare</function> which takes
              two <classname>java.lang.Object</classname>s. The proxy
              is constructor is parameterized with a comparison
              procedure which the implementation of
              <function>compare</function> uses to compare the two
              objects - after unwrapping them and thus obtaining their
              original Scheme representation. The
              <function>list-sort</function> procedure takes a
              comparator as the first parameter and a list as the
              second. It sorts the list using the comparator by
              wrapping all list elements and stuffing them into a Java
              array, calling the <function>sort</function> static
              method on <classname>java.util.Array</classname> and
              then converting the array back into a list with all
              elements unwrapped.
            </para>
          </informalexample>
        </para>
        <note>
          <para>
            Proxies defined using <function>define-java-proxy</function>
            implement the <function>hashCode</function>,
            <function>equals</function> and
            <function>toString</function> methods internally and hence
            defining these methods at the Scheme level has no effect.
          </para>
        </note>
      </sect3>
      <sect3>
        <title>Synchronization</title>
        <para>
          <literal>s2j</literal> provides an equivalent of the
          <literal>synchronized</literal> Java keyword that allows
          threads to synchronize on a particular Java object.
        </para>
        <blockquote>
          <para>
            <indexterm><primary>java-synchronized</primary>
            </indexterm>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname>java-synchronized</methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
              <methodparam><parameter>thunk</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Evaluates <parameter>thunk</parameter> inside a block that
                is synchronized on <parameter>jobj</parameter>, returning
                the result of the evaluation. The result of capturing and
                invoking continuations from within
                <parameter>thunk</parameter> that escape the thunk is undefined.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Reflection</title>
        <para>
          The <literal>s2j</literal> module is based on the native
          <literal>s2j-module</literal> which defines Scheme
          procedures corresponding to almost all methods on
          <classname>java.lang.Class</classname> plus the various
          other reflection classes. The only methods of the Java
          Reflection API that have not been mapped this way are:
          <programlisting>
Class.forName(String,boolean,ClassLoader)
Class.getClassLoader()
Class.getPackage()
Class.getProtectionDomain()
Class.getResource(String)
Class.getResourceAsStream(String)
Class.getSigners()
          </programlisting>
          The majority of procedures in <literal>s2j-module</literal>
          are not exported by <literal>s2j</literal> since direct use
          of the Java Reflection API should not be necessary due to
          the higher-level functionality provided by
          <literal>s2j</literal> and the
          <literal>generic-procedures</literal> modules. It is however
          worth noting that <literal>s2j-module</literal> (and hence
          <literal>s2j</literal>) treat reflected Java fields, methods
          and constructors specially. Specifically, they are all
          represented as self-evaluating objects.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jfield</parameter></methodparam>
              <methodparam><parameter>target</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java object's instance or static
                member field. <parameter>jfield</parameter> must be a
                reflected Java field object. The
                <parameter>target</parameter> is the Java object or class
                on which the field is accessed. The optional
                <parameter>jobj</parameter> is the new value for the
                field.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jmethod</parameter></methodparam>
              <methodparam><parameter>target</parameter></methodparam>
              <methodparam rep="repeat">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Invokes the method represented by the reflected Java
                method object <parameter>jmethod</parameter> on Java
                object supplied as a <parameter>target</parameter> with
                the <parameter>jobj</parameter>s as parameters. If
                <parameter>jmethod</parameter> is a static method,
                <parameter>target</parameter> is ignored and can be any
                Java object, including <constant>null</constant>
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jconstructor</parameter></methodparam>
              <methodparam rep="repeat">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Invokes the constructor represented by the reflected Java
                constructor object <parameter>jconstructor</parameter>
                with the supplied <parameter>jobj</parameter> parameters.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jclass</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new instance of <parameter>jclass</parameter> by
                invoking its default, argument-less constructor.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
    </sect2>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
