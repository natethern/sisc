
<chapter id="JavaInteraction">
  <title>Java Interaction</title>
  <para>
&SISC; can be used as a scripting language for Java, or Java may be
used to provide functionality to Scheme. Such activity is collectively
termed 'bridging'. In &SISC; bridging is accomplished by a Java API
for executing Scheme code and evaluating Scheme expressions, and a
module that provides Scheme-level access to Java objects and
implementation of Java interfaces in Scheme.
</para>
  <sect1 id="JavaToScheme">
    <title>Java-to-Scheme Interface</title>
    <para>
Multiple Scheme applications can run within a single &SISC;
runtime. Each application has its own top level environment and
evaluator. An application is represented by instances of the
<classname>AppContext</classname> class.

A Scheme application can execute in multiple threads. Each thread must
have its own dynamic environment, containing entities such as the current
input and output ports. Dynamic environments are represented by
instances of the <classname>DynamicEnv</classname> class.

A thread can be associated with multiple interpreters. The reason for
there being multiple interpreters is that internal calls need to be
executed by an interpreter different from the one that initiated the
internal call so that the state of the latter can be preserved.

</para>
    <sect2>
      <title>Calling Scheme From Java</title>
      <para>
A call from Scheme to Java can occur in one of two places:
      <itemizedlist>
          <listitem>
            <para>
Within a call from Scheme to Java - we shall call this an
<quote>internal call</quote>.
</para>
          </listitem>
          <listitem>
            <para>
Elsewhere, e.g. as the result of a timer expiration or as part of a
thread created by Java - we shall call this an <quote>external
call</quote>.
</para>
          </listitem>
        </itemizedlist>
The <classname>Context</classname> class is the key point where both
the above call scenarios are managed.
</para>
      <sect3>
        <title>Internal Calls</title>
        <para>
When making an internal call, one typically wants to do that in an
interpreter that shares the same <classname>AppContext</classname> and
<classname>DynamicEnv</classname> as the calling interpreter. One can
get hold of such an interpreter using
<programlisting>
Interpreter r = Context.enter();
</programlisting>
One can determine if a call is internal in the following manner:
<programlisting>
Interpreter current = Context.currentInterpreter();
if (current == null) { ...make external call...}
else { ...make internal call... }
</programlisting>
The calls themselves are made using one of the three
<function>eval</function> methods on the
<classname>Interpreter</classname>:
<itemizedlist>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>String</type>
                  <parameter>expr</parameter>
                </methodparam>
              </methodsynopsis>
            </listitem>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>Value</type>
                  <parameter>val</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  This is the same as calling <literal>(eval
                  </literal><parameter>val</parameter><literal>)
                  </literal> in Scheme.
                </para>
              </blockquote>
            </listitem>
            <listitem>
              <methodsynopsis language="java">
                <modifier>public</modifier>
                <type>Value</type>
                <methodname>eval</methodname>
                <methodparam>
                  <type>Procedure</type>
                  <parameter>proc</parameter>
                </methodparam>
                <methodparam>
                  <type>Value[]</type>
                  <parameter>args</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  This is the same as calling
                  <literal>(</literal><parameter>proc</parameter>
                  <parameter>arg</parameter> ...<literal>) </literal> in
                  Scheme.
                </para>
              </blockquote>
            </listitem>
          </itemizedlist>
          Several such calls can be made on the same interpreter.
        </para>
        <para>
          Before returning from the code that is making the internal
          calls one must call
          <programlisting>
Context.exit()
          </programlisting>
          in order to release the resources associated with the call
          context.
        </para>
      </sect3>
      <sect3>
        <title>External Calls</title>
        <para>
          The main challenge when making external calls is what
          application and dynamic environment to make them
          in. <classname>Context</classname> maintains an application
          registry. To register an application call
          <programlisting>
Context.register("appname", appContext)
          </programlisting>
          The application registry can be used to obtain new
          interpreters that are associated with specific applications
          and have a fresh dynamic environment:
          <programlisting>
Interpreter r = Context.enter("appname");
          </programlisting>
          <classname>AppContext</classname>s are usually created by
          calling their argument-less constructor and are later
          modified by loading a heap image into them. So a typical
          context initialization sequence would be:
          <programlisting>
AppContext ctx = new AppContext();
Context.register("myapp", ctx);
Interpreter r = Context.enter("myapp");
ctx.loadEnv(r, dataInputStream);
Context.exit();
          </programlisting> 
        </para>
        <para>
          Sometimes one may want to use a different mechanism for
          finding applications and dynamic environments. For instance,
          threads created from Scheme should probably execute within
          the application that created them and using a dynamic
          environment that is cloned from the dynamic environment
          present when the thread is started. There is therefore a
          general mechanism for obtaining a new interpreter that uses
          a specific application and dynamic environment:
          <programlisting>
Interpreter r = Context.enter(appContext, dynamicEnv);
          </programlisting>
          External calls are made in the same way as internal calls,
          e.g. using one of the eval methods. Before returning from
          the code that is making the external calls one must call
          <programlisting>
Context.exit()
          </programlisting>
          in order to release the resources associated with the call
          context.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Miscellaneous Features</title>
      <sect3 id="JErrorHandling">
        <title>Error Handling</title>
        <para>
          <literal>Interpreter.eval()</literal> throws a
          <classname>SchemeException</classname> when an evaluation
          causes an exception that is not caught inside the
          evaluation. When making internal calls the exception can be
          propagated to the calling interpreter in one of four ways:
          <itemizedlist>
            <listitem>
              <para>
                by throwing a <classname>RuntimeException</classname>
                - this will be reported as<literal>"Error in
                "</literal><parameter>prim-name</parameter><literal>:
                </literal><parameter>description</parameter><literal>"</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                by calling
                <literal>Module.throwPrimException("</literal><parameter>description</parameter><literal>")</literal>
                - this will be
                reported as <literal>"Error in
                </literal><parameter>prim-name</parameter><literal>:
                </literal><parameter>description</parameter><literal>"</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                by calling
                <literal>throwNestedPrimException("</literal><parameter>description</parameter><literal>",
                </literal><parameter>schemeException</parameter><literal>)</literal>
                - this will be reported as <literal>"Error in
                </literal><parameter>prim-name</parameter><literal>:
                </literal><parameter>description</parameter><literal>\n</literal><parameter>nested-description</parameter><literal>"</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                by calling
                <literal>throwNestedPrimException(</literal><parameter>schemeException</parameter><literal>)</literal>
                - this will be reported as <literal>"Error in
                </literal><parameter>prim-name</parameter><literal>:
                exception during nested
                call\n</literal><parameter>nested-description</parameter><literal>"</literal>.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Scheme code can throw Java exceptions (see <xref
          linkend="S2JExceptions"/>). The
          <literal>s2j</literal>. module contains a static method
          <literal>S2J.javaException(</literal><parameter>schemeException</parameter><literal>)</literal>
          that extracts the Java exception from a
          <literal>SchemeException</literal>, or, if no Java exception
          is present, returns the <literal>SchemeException</literal>.
        </para>
      </sect3>
      <sect3 id="JContinuations">
        <title>Continuations</title>
        <para>
          Continuations do not cross the Scheme/Java boundary. In the
          embedded call scenario invoking a continuation inside the
          embedded call will not discard the computation of the
          caller. The embedded call will return when the continuation
          returns. If the continuation contains the read-eval-print
          loop the return will never happen. Similarly, capturing a
          continuation inside a call (embedded or external) will only
          capture the continuation to point where the call was made.
        </para>
        <para>
          Capturing and invoking a continuation within the
          <emphasis>same</emphasis> call works correctly.
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="SchemeToJava">
    <title>Scheme-to-Java Interface</title>
    <para>
      &requires; 
      <emphasis role="bold">
        (import <emphasis>s2j</emphasis>)
      </emphasis>
    </para>
    <para>
      A significant proportion of the module's functionality is
      offered through tight integration with the 
      <xref linkend="GenericProcedures">generic procedures</xref> mechanism.
    </para>
    <sect2>
      <title>Java Objects</title>
      <para>
        Java objects are exposed to the Scheme world as instances of a
        special data type that is disjoint from all other Scheme
        types.
      </para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>&num;t/&num;f</type>
            <methodname>java-object?</methodname>
            <methodparam><parameter>obj</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              returns &num;t if <parameter>obj</parameter> is a Java
              object, &num;f otherwise.
            </para>
          </blockquote>
        </para>
      </blockquote>
      <sect3>
        <title>Object Types</title>
        <para>
          Some types of Java objects are handled specially, namely
          classes, interfaces, arrays and <constant>null</constant>. A
          set of predicates ascertains whether a Java object is of one
          of these special types.
        </para>
        <blockquote>
          <simplelist>
            <member>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-class?</methodname>
                <methodparam><parameter>obj</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-interface?</methodname>
                <methodparam><parameter>obj</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-array?</methodname>
                <methodparam><parameter>obj</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-null?</methodname>
                <methodparam><parameter>obj</parameter></methodparam>
              </methodsynopsis>
            </member>
          </simplelist>
          <blockquote>
            <para>
              Ascertains whether <parameter>obj</parameter> is a Java
              class, interface, array or is <constant>null</constant>.
            </para>
          </blockquote>
        </blockquote>
        <para>
          Generally all java objects can be invoked as procedures. The result
          of the invocation depends on the type of object and the
          arguments.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
              <methodparam><parameter>fieldname</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java object's instance or static
                member field. <parameter>jobj</parameter> can be any Java
                object. <parameter>fieldname</parameter> denotes the field
                name and must be supplied as a symbol.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jclass</parameter></methodparam>
              <methodparam><parameter>fieldname</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java class' static member
                field. <parameter>jclass</parameter> can be any Java
                class. <parameter>fieldname</parameter> denotes the field
                name and must be supplied as a symbol.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jarray</parameter></methodparam>
              <methodparam><parameter>index</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of a Java array element.
                <parameter>jarray</parameter> can be any Java array
                object. <parameter>index</parameter> can be either a
                number or, for multi-dimensional arrays, a list or vector
                of numbers.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Object Comparison</title>
        <para>
          Comparing Java objects using <function>eq?</function>
          compares the objects using Java's <function>==</function>
          comparison. <function>equal?</function>, on the other hand,
          compares the objects using Java's
          <function>equals</function> method. Applying either
          <function>eq?</function> or <function>equal?</function> to a
          mixture of Java objects and other Scheme objects returns
          &num;f.
        </para>
      </sect3>
      <sect3>
        <title>Object Serialization</title>
        <para>
          The objects representing Java classes, fields, methods and
          constructors can be (de)serialized. Ordinary Java objects
          cannot be (de)serialized.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Instantiating Java Classes and Invoking Methods</title>
      <para>

      </para>
      <sect3>
        <title>Object Creation</title>
        <para>
          Java objects can be created by Scheme code by invoking
          <function>make</function> with a class object as the first
          parameter followed by any number of Java objects, e.g.
          <programlisting>
(define sb (make &lt;jstringbuffer&gt; (-&gt;jstring "foo")))
          </programlisting>
          <constant>&lt;jstringbuffer&gt;</constant> is bound to the
          object representing the Java class
          <classname>java.lang.StringBuffer</classname>. The angle
          brackets are only a notational convention for denoting
          variables bound to class
          objects. <function>-&gt;jstring</function> converts a Scheme
          string into a Java string. In <xref linkend="JavaClasses"/>
          we explain how to get hold of class objects and in <xref
          linkend="S2JConversions"/> we show how to convert between
          Scheme and Java objects.
        </para>
        <para>
          The <function>make</function> generic constructor is chained
          to a generic constructor that is obtained as follows
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>generic-java-constructor</methodname>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a generic constructor that contains all Java
                  constructors of all classes. Its main purpose is to
                  allow new constructors (besides
                  <function>make</function>) to be defined that (like
                  <function>make</function>) are chaining all Java
                  constructors.
                </para>
                <para>
                  If the <parameter>next-proc</parameter> parameter is
                  specified, the generic constructor is chained to
                  that procedure, which must be a generic constructor.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          The types of the parameters passed to
          <function>make</function> determine which constructor is
          invoked. Normally this is a constructor defined in
          Java. Note however that that Scheme code can define new
          constructors or overload/override existing constructors via
          the <function>define-constructor</function> macro defined in
          <xref linkend="GenericProcedures"/>. Due to the implicit or
          explicit chaining of <function>make</function> to
          generic Java constructors, constructors defined in
          Scheme take precedence over constructors defined in
          Java. They are not visible to Java code. They must invoke a
          Java constructor in order to actually create a Java
          object. Typically this is done via the
          <function>next-method</function> feature of the generic
          procedures mechanism.
        </para>
        <para>
          Note that <function>make</function> cannot create Java
          arrays. This is done by a special procedure instead.
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>jarray</type>
                <methodname>java-array-new</methodname>
                <methodparam><parameter>jclass</parameter></methodparam>
                <methodparam><parameter>dimensions</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a Java array. <parameter>jclass</parameter>
                  determines the type of array
                  elements. <parameter>dimensions</parameter> determines
                  the size of the array and can be either a number or, for
                  multi-dimensional arrays, a list or vector of numbers.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3 id="JavaMethodInvocation">
        <title>Method Invocation</title>
        <para>
          Scheme code can invoke Java methods via generic procedures,
          e.g.
          <programlisting>
(define-generic to-string)
(to-string sb)
          </programlisting>
          which calls the <function>toString</function> method on the
          <classname>java.lang.StringBuffer</classname> instance
          defined above.
        </para>
        <para>
          Generic procedures defined with
          <function>define-generic</function> are by default chained
          to special generic procedures obtained as follows:
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>generic-java-procedure</methodname>
                <methodparam><parameter>method-name</parameter></methodparam>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a generic procedure that contains all Java
                  methods of all classes whose name is
                  <parameter>name</parameter>.
                </para>
                <para>
                  If the <parameter>next-proc</parameter> parameter is
                  specified, the generic procedure is chained to it.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          <function>define-generic</function> mangles the name of the
          defined procedure when calling the
          <function>generic-java-procedure</function>. This way,
          generic procedures following the usual Scheme naming
          conventions get chained to generic procedures that invoke
          Java methods with names following usual Java naming
          conventions. The name mangling is performed by 
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>symbol</type>
                <methodname>java-mangle-name</methodname>
                <methodparam><parameter>name</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Converts a Scheme procedure name, supplied as a
                  symbol in <parameter>name</parameter> into a Java
                  method name in accordance with the following rules:
                  <orderedlist spacing="compact">
                    <listitem>
                      <para>
                        Any trailing <literal>!</literal> is removed.
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Any trailing <literal>?</literal> is removed
                        and a leading <literal>is-</literal> added
                        instead.
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Any occurrence of <literal>-</literal> is
                        removed and the character following it is
                        converted to upper case.
                      </para>
                    </listitem>
                  </orderedlist>
                </para>
                <para>
                  With these rules, <function>foo-bar-baz?</function>
                  maps to <function>isFooBarBaz</function>.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          Sometimes the names of Java methods make it inconvenient to
          define generic functions with the right names needed for the
          automatic chaining described above to work. For instance,
          the names might clash with those of well-known Scheme
          procedures. To overcome this problem,
          <function>define-generic</function> can take a second
          argument that makes the chaining explicit. Using the above
          <function>generic-java-procedure</function> it is thus
          possible to avoid name clashes as follows:
          <programlisting>
(define-generic app (generic-java-procedure (java-mangle-name 'append)))
(app sb (->jstring "foo"))
          </programlisting>
          The invocation of <function>app</function> selects the
          appropriate <function>append</function> method on
          <classname>java.lang.StringBuffer</classname>
        </para>
        <para>
          The types of the parameters passed when invoking a generic
          procedure determine which method is invoked. Unlike Java,
          method selection is completely dynamic depending on the
          types of all parameters, including the first one, which, in
          the Java world, corresponds to the target object of a method
          invocation. Also, note that Scheme code can define new
          methods and overload/override existing methods via the
          <function>define-method</function> macro defined in <xref
          linkend="GenericProcedures"/>. These methods are not visible
          to Java code and the implicit (or explicit) chaining of
          ordinary generic procedures to the generic procedures
          obtained from <function>generic-java-procedure</function>
          results in all Scheme-defined methods taking precedence over
          Java methods.
        </para>
        <para>
          Static Java methods can be invoked by calling the
          appropriate generic procedure with a class as the first
          argument. Note that, unlike in Java, it is not possible to
          invoke a static method on an instance. The type signature of
          static Java methods has
          <literal>(</literal><function>meta</function>
          <parameter>class</parameter><literal>)</literal> as the type
          of the first argument (see <xref
          linkend="GenericProcedures"/> for a description of
          <function>meta</function>). Hence, static Java methods can
          be overridden by Scheme methods with a similar type
          signature.
        </para>
      </sect3>
      <sect3 id="JavaClasses">
        <title>Classes</title>
        <para>
          The primary means of getting hold of a Java class is
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>jclass</type>
                <methodname>java-class</methodname>
                <methodparam><parameter>classname</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Resolves <parameter>classname</parameter> to a Java
                  class. <parameter>classname</parameter> can be a string
                  or symbol and must be one of the following:
                  <itemizedlist spacing="compact">
                    <listitem>
                      <para>
                        a fully-qualified name of a Java class or
                        interface
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        the name of a primitive type,
                        e.g. <literal>"int"</literal>
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        one of the above followed by any number of
                        <literal>[]</literal>, denoting an array type
                      </para>
                    </listitem>
                  </itemizedlist>
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          By convention, names of constants bound to class objects are
          constructed by enclosing the fully qualified class name in
          angle brackets, e.g.
          <programlisting>
(define &lt;java.util.Comparator&gt; (java-class "java.util.Comparator"))
          </programlisting>
          An exception are primitive types and classes defined in the
          <classname>java.lang</classname> (excluding the wrapper
          classes for primitive types, such as
          <classname>java.lang.Integer</classname>). The
          <literal>s2j</literal> module exports pre-defined bindings
          for these in an abbreviated notation that only uses the type
          name or down-cased unqualified class name prefixed with the
          letter <literal>j</literal>,
          e.g. <literal>&lt;jint&gt;</literal>,
          <literal>&lt;jobject&gt;</literal>.
        </para>
        <para>
          The class of an object can be obtained with
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>jclass</type>
                <methodname>java-class-of</methodname>
                <methodparam><parameter>jobj</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns the class of which <parameter>jobj</parameter>
                  is an instance.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          It is also possible to check whether a Java object is an
          instance of a particular Java class and whether instances of
          one Java class can be assigned to variables whose declared
          type is that of another.
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-instance?</methodname>
                <methodparam><parameter>jclass</parameter></methodparam>
                <methodparam><parameter>jobj</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if <parameter>jobj</parameter> is an
                  instance of <parameter>jclass</parameter> or one of its
                  sub-classes, or, if <parameter>jclass</parameter> is an
                  interface, implements <parameter>jclass</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>java-assignable?</methodname>
                <methodparam><parameter>jclass1</parameter></methodparam>
                <methodparam><parameter>jclass2</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if instances of
                  <parameter>jclass2</parameter> can be assigned to
                  variables, fields, parameters whose type has been
                  declared as <parameter>jclass1</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          Primitive types are mapped to their respective
          <classname>java.lang</classname> classes. This means,
          amongst other things, that, unlike in Java, primitive types
          are indirect sub-classes of
          <classname>java.lang.Object</classname> and primitive types
          are assignable to their respective
          <classname>java.lang</classname> classes (and visa
          versa). Note however that no widening conversion takes
          place, because Java does not define widening conversions for
          the java.lang classes corresponding to the primitive types,
          e.g. a <classname>java.lang.Byte</classname> is not
          assignable to a <classname>java.lang.Integer</classname> and
          thus, unlike in Java, <classname>byte</classname> is not
          assignable to <classname>int</classname>.
        </para>
      </sect3>
      <sect3 id="S2JConversions">
        <title>Converting between Scheme and Java Types</title>
        <para>
          When calling Java methods and constructors through generic
          procedures, or when setting/getting fields of Java objects
          and classes, <emphasis>no</emphasis> automatic conversion
          between Scheme types and Java types is performed, e.g. one
          cannot simply call a Java method that takes an
          <classname>int</classname> with a Scheme number or expect a
          <classname>java.lang.String</classname> returned from a
          method invocation to be converted to a Scheme
          string. Automatic conversion is not done for the following
          reasons:
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                For some Scheme types, such as numbers, the mapping to
                Java types is one-to-many, e.g. a Scheme number could
                be converted to a <classname>byte</classname>,
                <classname>short</classname>,
                <classname>int</classname>, etc. This causes
                ambiguities when automatic conversion of parameters is
                attempted.
              </para>
            </listitem>
            <listitem>
              <para>
                Some Java types have several corresponding Scheme
                types, e.g. a Java array could be represented as
                Scheme list or vector - this causes ambiguities when
                automatic conversion of results is attempted.
              </para>
            </listitem>
            <listitem>
              <para>
                Conversion carries an overhead that can be
                significant. For instance, Java strings have to be
                copied "by value" to Scheme strings since the former
                are immutable and the latter aren't. In a chained-call
                scenario, i.e. where the results of one method
                invocation are passed as arguments to another, the
                conversion is unnecessary and a wasted effort.
              </para>
            </listitem>
            <listitem>
              <para>
                Conversion breaks the object identity relationship. In
                a chained-call scenario, the identities of the objects
                passed to the second call are different from the ones
                returned by the first. This causes problems if the
                called Java code relies on the object identity being
                preserved.
              </para>
            </listitem>
            <listitem>
              <para>
                Conversion conflicts with generic procedures. The
                method selection mechanism employed by generic
                procedures relies on objects having exactly one
                type. Automatic conversion effectively gives objects
                more than one type - their original type and the type
                of the objects they can be converted to. While it
                would be technically possible to devise a method
                selection algorithm that accommodates this, the
                algorithm would impose a substantial overhead on
                generic procedure invocation and also make it
                significantly harder for users to predict which method
                will be selected when invoking a generic procedure with
                a particular set of arguments.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Instead of implicit conversion, the <literal>s2j</literal>
          module provides a general explicit conversion mechanism that
          can be used to explicitly convert from Scheme to Java types
          and visa versa. In fact this procedure can in principle also
          be used to convert between Scheme types and between Java
          types in a future version. The general conversion procedure
          is
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>proc</type>
              <methodname>-&gt;</methodname>
              <methodparam><parameter>type</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns a procedure that when invoked will convert its
                argument into an object of type
                <parameter>type</parameter>. For example
                <programlisting>
((-&gt; &lt;jstring&gt;) "foo")
                </programlisting>
                converts the Scheme string <literal>"foo"</literal> into a
                Java string. Typically the returned procedure takes just
                one argument - the object to be converted. There are
                however some special cases where additional information is
                needed in order to perform a conversion and this would be
                supplied in additional arguments.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          <function>-&gt;</function> is an ordinary generic procedure,
          so it is actually possible to define custom conversion, e.g.
          <programlisting>
(define-method (-&gt; ((meta &lt;jstring&gt;) _)) -&gt;jstring)
          </programlisting>
        </para>
        <para>
          For most of the conversion procedures returned by
          <function>-&gt;</function> there are top-level bindings
          consisting of the type name prefixed with
          <literal>-&gt;</literal>, e.g. <literal>(-&gt;jint
          2)</literal>. Note that doing this is a lot more efficient
          than using <function>-&gt;</function> since
          <function>-&gt;</function> is defined in terms of the
          specialized conversion procedures, i.e. just like in the
          above example. Also, there are some
          conversion that cannot be accomplished with
          <function>-&gt;</function>. One such case is conversion to
          Java arrays since there is no general array type in Java and
          hence no type object that could be used as the parameter to
          <function>-&gt;</function>. Instead there is
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jarray</type>
              <methodname>-&gt;jarray</methodname>
              <methodparam><parameter>list-or-vector</parameter></methodparam>
              <methodparam><parameter>jclass</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Converts <parameter>list-or-vector</parameter> into a Java
                array whose element type is <parameter>jclass</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          All Scheme types have a corresponding type objects, which
          are bound to identifiers in the top-level environment,
          eg. <literal>&lt;void&gt;</literal>,
          <literal>&lt;boolean&gt;</literal>,
          <literal>&lt;number&gt;</literal> etc. Hence, for instance
          <programlisting>
((-&gt; &lt;number&gt;) (-&gt;jint 1))
(-&gt;number (-&gt;jint 1))
          </programlisting>
          both convert the Scheme number <literal>1</literal> into a Java
          <classname>int</classname> and back into a Scheme number.
        </para>
      </sect3>
      <sect3 id="S2JExceptions">
        <title>Exceptions</title>
        <para>
          Java exceptions are propagated to scheme and can be caught
          like any other exception, e.g. with
          <function>with/fc</function> as defined in <xref
          linkend="FailureContinuations"/>. For example
          <programlisting>
(define-generic char-at)
(define-generic print-stack-trace)
(with/fc (lambda (m e) (print-stack-trace m) #f)
  (lambda () (char-at (-&gt;jstring "foo") (-&gt;jint 3))))
          </programlisting>
          will catch the
          <classname>IndexOutOfBoundsException</classname>, print its
          stack trace and return &num;f.
        </para>
        <para>
          In Scheme, Java exceptions can be thrown by raising an error
          containing the Java exception as the message, e.g.
          <programlisting>
(error (make &lt;java.util.NoSuchElementException&gt;))
          </programlisting>
          or
          <programlisting>
(throw (make-error (make &lt;java.util.NoSuchElementException&gt;)))
          </programlisting>
          If this occurs inside a proxy method (see <xref
          linkend="JavaProxies"/>), the exception is propagated to the
          invoking Java code.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Miscellaneous Features</title>
      <para>
      </para>
      <sect3>
        <title>Wrapping Scheme Objects</title>
        <para>
          Sometimes we may want to pass Scheme objects to Java as
          parameters in method calls and as values for fields without
          converting them into Java objects. For instance, we may want
          to store and retrieve Scheme objects in/from an instance of
          a Java collection class such as
          <classname>java.util.HashSet</classname>. This can be done
          with the help of two procedures that wrap and and unwrap
          Scheme objects.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname>java-wrap</methodname>
              <methodparam><parameter>obj</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Wraps a Scheme object so it can be passed in call to a
                Java method / constructor or when setting a field of a
                Java object or class.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>obj</type>
              <methodname>java-unwrap</methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Casts a java object into a Scheme object, so a Scheme
                object returned by a Java method or when accessing a Java
                field can be used in Scheme code.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          Since all Scheme objects are represented internally as Java
          objects anyway, the wrapping and unwrapping preserves object
          identity.
        </para>
      </sect3>
      <sect3>
        <title>Assignment</title>
        <para>
          Internally, Java objects are represented by a special Scheme
          object containing a reference to the Java object. It is
          possible to create these objects explicitly and to assign
          one to another.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname>java-new</methodname>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new Scheme object, initially representing
                the <literal>null</literal> Java object.
              </para>
            </blockquote>
          </para>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>java-set!</methodname>
              <methodparam><parameter>jobj1</parameter></methodparam>
              <methodparam><parameter>jobj2</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Makes <parameter>jobj1</parameter> refer to the same
                Java object as <parameter>jobj2</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          For convenience there is a constant <literal>jnull</literal>
          that represents the java <literal>null</literal>
          object. Note however that the object isn't truly constant,
          i.e. it is actually possible to make it refer to another
          Java object using <literal>java-set!</literal>. Doing so is
          not recommended, for obvious reasons.
        </para>
      </sect3>
      <sect3 id="JavaProxies">
        <title>Proxies</title>
        <para>
          The <literal>s2j</literal> module provides a mechanism by
          which Scheme code can construct objects that implement
          particular Java interfaces, with the methods required by the
          interfaces being implemented in Scheme. This is accomplished
          by means of the following macro
        </para>
        <blockquote>
          <para>
            &syntax;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>define-java-proxy</methodname>
              <methodparam><parameter>func-spec</parameter></methodparam>
              <methodparam><parameter>interface-spec</parameter></methodparam>
              <methodparam rep="repeat">
                <parameter>method-spec</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <simplelist spacing="compact">
                <member>
                  where <parameter>func-spec</parameter> is of the form
                  <literal>(</literal><parameter>name</parameter>
                  <parameter>arg</parameter> ...<literal>)</literal>
                </member>
                <member>
                  and <parameter>interface-spec</parameter> is of the
                  form <literal>(</literal><parameter>jclass</parameter>
                  ...<literal>)</literal> or
                  <parameter>jclass</parameter>
                </member>
                <member>
                  and <parameter>method-spec</parameter> is of the form
                  <literal>(method
                    (</literal><parameter>name</parameter>
                  <literal>(</literal><parameter>type</parameter>
                  <parameter>param</parameter><literal>)</literal>
                  ...<literal>)
                    . </literal><parameter>body</parameter><literal>)</literal>
                </member>
              </simplelist>
              <para>
                Defines a proxy constructor in the current
                environment. A proxy constructor is a procedure that
                when invoked creates a Java object that implements a
                certain set of Java interfaces in terms of Scheme code
                which is parameterized by a set of arguments passed to
                the constructor on invocation. The object resulting from
                invoking the proxy constructor can be passed to any Java
                constructor or method as a parameter whose type is one
                of the interfaces (or super-interface thereof)
                implemented by the proxy. Method invocations by Java (or
                indeed Scheme) on the object result in execution of one
                of the methods declared method bodies, selected based on
                its name and type signature. If no such method is found
                an error is raised.
              </para>
              <para>
                <parameter>name</parameter> is the name to which to bind
                the proxy constructor in the current environment. The
                <parameter>arg</parameter>s parameterize the proxy
                constructor and are bound in the lexical environment of
                <parameter>body</parameter>. <parameter>interface-spec</parameter>
                specifies what interface(s) should be implemented by
                this proxy. All <parameter>jclass</parameter> must be
                Java <emphasis>interfaces</emphasis> - proxies cannot
                sub-class Java <emphasis>classes</emphasis>.  The
                <parameter>name</parameter>s and
                <parameter>type</parameter>s of the methods must
                <emphasis>exactly</emphasis> match those of the methods
                on the Java interfaces. An error is raised at
                declaration-time when this is not the case. This is
                likely to change in a future version and name mangling
                and "best match" policy similar to the one used by
                generic procedures will be employed.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <para>
          An example might be helpful at this stage:
          <informalexample>
            <programlisting>
(define &lt;java.util.Comparator&gt; (java-class "java.util.Comparator"))
(define &lt;java.util.Arrays&gt; (java-class "java.util.Arrays"))
(define-java-proxy (comparator fn) &lt;java.util.Comparator&gt;
  (method (compare (&lt;jobject&gt; obj1) (&lt;jobject&gt; obj2))
    (let ((x (java-unwrap obj1))
          (y (java-unwrap obj2)))
      (-&gt;jint (cond ((fn x y) -1)
                    ((fn y x) +1)
                    (else 0))))))
(define-generic sort)
(define (list-sort comp l)
  (let ([a (-&gt;jarray (map java-wrap l) &lt;jobject&gt;)])
    (sort &lt;java.util.Arrays&gt; a comp)
    (map java-unwrap (-&gt;list a))))
(list-sort (comparator &lt;) '(3 4 2 1))
;=&gt; '(1 2 3 4)
(list-sort (comparator string&lt;?) '("foo" "bar" "baz"))
;=&gt;'("bar" "baz" "foo")
            </programlisting>
            <para>
              This defines a proxy constructor
              <function>comparator</function> that implements the
              <classname>java.util.Comparator</classname> interface
              top perform comparison of arbitrary Scheme
              objects. There is only one method that needs to be
              implemented - <function>compare</function> which takes
              two <classname>java.lang.Object</classname>s. The proxy
              is constructor is parameterized with a comparison
              procedure which the implementation of
              <function>compare</function> uses to compare the two
              objects - after unwrapping them and thus obtaining their
              original Scheme representation. The
              <function>list-sort</function> procedure takes a
              comparator as the first parameter and a list as the
              second. It sorts the list using the comparator by
              wrapping all list elements and stuffing them into a Java
              array, calling the <function>sort</function> static
              method on <classname>java.util.Array</classname> and
              then converting the array back into a list with all
              elements unwrapped.
            </para>
          </informalexample>
        </para>
        <note>
          <para>
            Proxies defined using <function>define-java-proxy</function>
            implement the <function>hashCode</function>,
            <function>equals</function> and
            <function>toString</function> methods internally and hence
            defining these methods at the Scheme level has no effect.
          </para>
        </note>
      </sect3>
      <sect3>
        <title>Synchronization</title>
        <para>
          <literal>s2j</literal> provides an equivalent of the
          <literal>synchronized</literal> Java keyword that allows
          threads to synchronize on a particular Java object.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>obj</type>
              <methodname>java-synchronized</methodname>
              <methodparam><parameter>jobj</parameter></methodparam>
              <methodparam><parameter>thunk</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Evaluates <parameter>thunk</parameter> inside a block that
                is synchronized on <parameter>jobj</parameter>, returning
                the result of the evaluation. The result of capturing and
                invoking continuations from within
                <parameter>thunk</parameter> that escape the thunk is undefined.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
      <sect3>
        <title>Reflection</title>
        <para>
          The <literal>s2j</literal> module is based on the native
          <literal>s2j-module</literal> which defines Scheme
          procedures corresponding to almost all methods on
          <classname>java.lang.Class</classname> plus the various
          other reflection classes. The only methods of the Java
          Reflection API that have not been mapped this way are:
          <programlisting>
Class.forName(String,boolean,ClassLoader)
Class.getClassLoader()
Class.getPackage()
Class.getProtectionDomain()
Class.getResource(String)
Class.getResourceAsStream(String)
Class.getSigners()
          </programlisting>
          The majority of procedures in <literal>s2j-module</literal>
          are not exported by <literal>s2j</literal> since direct use
          of the Java Reflection API should not be necessary due to
          the higher-level functionality provided by
          <literal>s2j</literal> and the
          <literal>generic-procedures</literal> modules. It is however
          worth noting that <literal>s2j-module</literal> (and hence
          <literal>s2j</literal>) treat reflected Java fields, methods
          and constructors specially. Specifically, they are all
          represented as self-evaluating objects.
        </para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jfield</parameter></methodparam>
              <methodparam><parameter>target</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of Java object's instance or static
                member field. <parameter>jfield</parameter> must be a
                reflected Java field object. The
                <parameter>target</parameter> is the Java object or class
                on which the field is accessed. The optional
                <parameter>jobj</parameter> is the new value for the
                field.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jmethod</parameter></methodparam>
              <methodparam><parameter>target</parameter></methodparam>
              <methodparam rep="repeat">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Invokes the method represented by the reflected Java
                method object <parameter>jmethod</parameter> on Java
                object supplied as a <parameter>target</parameter> with
                the <parameter>jobj</parameter>s as parameters. If
                <parameter>jmethod</parameter> is a static method,
                <parameter>target</parameter> is ignored and can be any
                Java object, including <constant>null</constant>
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jconstructor</parameter></methodparam>
              <methodparam rep="repeat">
                <parameter>jobj</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Invokes the constructor represented by the reflected Java
                constructor object <parameter>jconstructor</parameter>
                with the supplied <parameter>jobj</parameter> parameters.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>jobj</type>
              <methodname></methodname>
              <methodparam><parameter>jclass</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new instance of <parameter>jclass</parameter> by
                invoking its default, argument-less constructor.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </sect3>
    </sect2>
    <sect2 id="GenericProcedures">
      <title>Generic Procedures</title>
      <para>
	&requires; 
	<emphasis role="bold">
	  (import <emphasis>generic-procedures</emphasis>)
	</emphasis>
      </para>
      <para>
        Generic procedures provide a mechanism by which a Scheme
        procedure can select different bodies for execution depending
        on the types of the parameters it was called with. Languages
        like ANSI Lisp and Dylan provide similar
        functionality. Generic procedures have several advantages over
        normal functions:
        <itemizedlist>
          <listitem>
            <para>
              It is not necessary to come up with unique names for
              procedures that perform the same operation on different
              types of objects. This avoids cluttering the name
              space. All these procedures can be defined separately
              but yet be part of the same, single generic procedure.
            </para>
          </listitem>
          <listitem>
            <para>
              The functionality of a generic procedure can be extended
              incrementally through code located in different
              places. This avoids "spaghetti code" where adding a new
              type of objects requires changes to existing pieces of
              code in several locations.
            </para>
          </listitem>
          <listitem>
            <para>
              Code using generic procedures has a high degree of
              polymorphism without having to resort to ugly and
              hard-to-maintain test-type-and-dispatch branching.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <sect3>
        <title>The Type System</title>
        <para>
          Generic procedures require a type system for their
          operation. At present the type system employed by &SISC;'s
          generic procedures is rather basic. This will change in the
          future. Currently, only two kinds of types are supported:
          <simplelist>
            <member>
              Java classes and interfaces1, obtained through the
              mechanisms described in <xref linkend="JavaClasses"/>,
              and
            </member>
            <member>
              Meta types, obtained by invoking
              <function>meta</function>.
            </member>
          </simplelist>
          <function>meta</function> is defined as follows:
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>type</type>
                <methodname>meta</methodname>
                <methodparam><parameter>type</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns the meta type of <parameter>type</parameter>,
                  i.e. a type whose instances are comprised of
                  <parameter>type</parameter> and all its sub-types.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          Types can be compared with
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>type&lt;=</methodname>
                <methodparam><parameter>type1</parameter></methodparam>
                <methodparam><parameter>type2</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if <parameter>type1</parameter> is a
                  sub-type of <parameter>type2</parameter>, &num;f
                  otherwise.
                </para>
              </blockquote>
            </para>
          </blockquote>
          One can test whether an object is an instance of a
          particular type with
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>instance-of?</methodname>
                <methodparam><parameter>obj</parameter></methodparam>
                <methodparam><parameter>type</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns &num;t if <parameter>obj</parameter> is an
                  instance of <parameter>type</parameter>, &num;f
                  otherwise.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3 id="genprocdef">
        <title>Defining Generic Procedures</title>
        <para>
          There are two steps to defining generic procedures -
          defining the generic procedures itself and adding methods to
          it.
        </para>
        <para>
          <blockquote>
            <para>
              &syntax;
              <methodsynopsis language="scheme">
                <void/>
                <methodname>define-generic</methodname>
                <methodparam><parameter>name</parameter></methodparam>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a new generic procedure and binds it to
                  <parameter>name</parameter> in the current lexical
                  environment. <parameter>next-proc</parameter> specifies
                  a procedure to be invoked when an invocation of the
                  generic procedure finds no matching method. This
                  mechanism is known as <emphasis>chaining</emphasis>. By
                  default, <parameter>next-proc</parameter> is set to
                  <literal>(generic-java-procedure
                    '</literal><parameter>name</parameter><literal>)</literal>
                  (see <xref linkend="JavaMethodInvocation"/>), resulting
                  in the invocation of Java methods if no matching Scheme
                  methods are found. Setting
                  <parameter>next-proc</parameter> to &num;f disables
                  chaining; an error will be thrown if an invocation of
                  the generic procedure cannot find a matching method.
                </para>
              </blockquote>
            </para>
          </blockquote>
          Generic procedures can also be constructed procedurally, using
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>make-generic-procedure</methodname>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                Creates a new generic procedure that is chained to
                <parameter>next-proc</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
          There are accessors for the various elements that make up a
          generic procedure:
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>list</type>
                <methodname>generic-procedure-methods</methodname>
                <methodparam><parameter>proc</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns a list of the methods which are part of the
                  generic procedure <parameter>proc</parameter>, in order
                  of their precedence.
                </para>
              </blockquote>
            </para>
          </blockquote>
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc/&num;f</type>
                <methodname>generic-procedure-next</methodname>
                <methodparam><parameter>proc</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns the chainee of the generic procedure
                  <parameter>proc</parameter>, or &num;f if no chainee was
                  specified.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          Methods can be added to generic procedures with
          <blockquote>
            <para>
              &syntax;
              <methodsynopsis language="scheme">
                <void/>
                <methodname>define-method</methodname>
                <methodparam><parameter>signature</parameter></methodparam>
                <methodparam><parameter>.</parameter></methodparam>
                <methodparam><parameter>body</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <simplelist spacing="compact">
                  <member>
                    where <parameter>signature</parameter> is of the
                    form <literal>(</literal><parameter>name</parameter>
                    <literal>(</literal><parameter>type</parameter>
                    <parameter>param</parameter><literal>)</literal>
                    ... [ <literal>.</literal>
                    <parameter>rest</parameter>]<literal>)</literal>
                  </member>
                  <member>
                    and <parameter>body</parameter> can contain anything
                    that is valid inside the body of a
                    <function>lambda</function>.
                  </member>
                </simplelist>
                <para>
                  Adds a method the generic procedure
                  <parameter>name</parameter>. A method has a typed
                  parameter list and a body. Defining a method with the
                  same signature as an existing method overwrites the
                  existing method.
                </para>
              </blockquote>
            </para>
          </blockquote>
          Methods can also be defined procedurally using
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>method</type>
                <methodname>make-method</methodname>
                <methodparam><parameter>proc</parameter></methodparam>
                <methodparam><parameter>types</parameter></methodparam>
                <methodparam><parameter>rest?</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a new method. <parameter>proc</parameter> is a
                  procedure that will be invoked when the method is
                  invoked. <parameter>types</parameter> is a list of
                  types, one for each parameter of the
                  method. <parameter>rest?</parameter> is a boolean that
                  indicates whether the method can take additional
                  (optional) parameters. The combination of
                  <parameter>types</parameter> and
                  <parameter>rest?</parameter> make up the
                  <emphasis>signature</emphasis> of the method.
                </para>
              </blockquote>
            </para>
          </blockquote>
          A method thus defined can be added to a generic procedure
          with
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <void/>
                <methodname>add-method</methodname>
                <methodparam><parameter>proc</parameter></methodparam>
                <methodparam><parameter>method</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Adds the method <parameter>method</parameter> to the
                  generic procedure <parameter>proc</parameter>. If a
                  method with the same signature as an existing method is
                  added, the existing method is replaced with the new
                  method.
                </para>
              </blockquote>
            </para>
          </blockquote>
          There are accessors for the various elements that make up a
          method:
          <blockquote>
            <simplelist>
              <member>
                  &procedure;
                <methodsynopsis language="scheme">
                  <type>proc</type>
                <methodname>method-procedure</methodname>
                  <methodparam><parameter>method</parameter></methodparam>
                </methodsynopsis>
              </member>
              <member>
                  &procedure;
                <methodsynopsis language="scheme">
                  <type>list</type>
                  <methodname>method-types</methodname>
                  <methodparam><parameter>method</parameter></methodparam>
                </methodsynopsis>
              </member>
              <member>
                  &procedure;
                <methodsynopsis language="scheme">
                  <type>&num;t/&num;f</type>
                  <methodname>method-rest?</methodname>
                  <methodparam><parameter>method</parameter></methodparam>
                </methodsynopsis>
              </member>
            </simplelist>
            <blockquote>
              <para>
                Returns the methods procedure, parameter types and rest
                parameter flag respectively.
              </para>
            </blockquote>
          </blockquote>
        </para>
        <para>
          Constructors are defined with
          <blockquote>
            <para>
              &syntax;
              <methodsynopsis language="scheme">
                <void/>
                <methodname>define-constructor</methodname>
                <methodparam><parameter>signature</parameter></methodparam>
                <methodparam><parameter>.</parameter></methodparam>
                <methodparam><parameter>body</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <simplelist spacing="compact">
                  <member>
                    where <parameter>signature</parameter> is of the
                    form <literal>(</literal><parameter>type</parameter>
                    <literal>(</literal><parameter>type</parameter>
                    <parameter>param</parameter><literal>)</literal>
                    ... [ <literal>.</literal>
                    <parameter>rest</parameter>]<literal>)</literal>
                  </member>
                  <member>
                    and <parameter>body</parameter> can contain anything
                    that is valid inside the body of a
                    <function>lambda</function>.
                  </member>
                </simplelist>
                <para>
                  This form is basically identical to the
                  <function>define-method</function> form except it
                  defines a "constructor" method for a specific
                  type. All constructor methods are part of the single
                  generic constructor <function>make</function>.
                </para>
              </blockquote>
            </para>
          </blockquote>
          New generic constructors can be created with
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>make-generic-constructor</methodname>
                <methodparam choice="opt">
                  <parameter>next-proc</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates a generic constructor which is chained to
                  <parameter>next-proc</parameter>, which must be another
                  generic constructor. This procedure is rarely used since
                  the pre-defined <function>make</function> generic
                  constructor typically suffices.
                </para>
              </blockquote>
            </para>
          </blockquote>
          Generic constructors maintain a table of generic procedures
          - one for each class of which instances can be
          constructed. The mapping is performed by
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>constructor</methodname>
                <methodparam><parameter>constr</parameter></methodparam>
                <methodparam><parameter>class</parameter></methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Returns the generic procedure that holds constructor
                  methods for class <parameter>class</parameter> of the
                  generic constructor <parameter>constr</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para>
          An example might be helpful at this stage.
          <programlisting>
(define-constructor (&lt;jstring> (next: next-method)
                               (&lt;jchar&gt; c))
  (next-method (-&gt;jarray (list c) &lt;jchar&gt;)))
(define-generic index-of)
(define-method (index-of (next: next-method)
                         (&lt;jstringbuffer&gt; buf)
                         (&lt;jchar&gt; c))
(define sb (make &lt;jstringbuffer&gt; (-&gt;jstring "foo")))
(-&gt;number (index-of sb (-&lt;jchar #\o))) ;=> 1
          </programlisting>
          This defines a method new constructor on
          <classname>java.lang.String</classname> that constructs a
          string from a single character by constructing a
          single-element array of characters and invoking the existing
          Java constructor with it. (This is done by
          <literal>next-method</literal>, which we explain in more
          detail below).  Furthermore, a new generic function
          <function>index-of</function> is defined and a method is
          added to it that returns the index of a character in a
          <classname>java.lang.StringBuffer</classname>. The method
          invokes the single-character string constructor defined just
          above and passes the resulting string to the existing
          <function>indexOf</function> Java method.
        </para>
      </sect3>
      <sect3>
        <title>Invoking Generic Procedures</title>
        <para>
          Generic procedures are invoked just like ordinary
          procedures. The invocation selects a method whose type
          signature best matches the types of the given parameters. An
          error is reported if there is no such method. The following
          precedence rules apply:
          <itemizedlist>
            <listitem>
              <para>
                Methods with n+1 mandatory parameters take precedence
                over methods with n mandatory parameters.
              </para>
            </listitem>
            <listitem>
              <para>
                Methods without rest arg take precedence over methods
                with rest args.
              </para>
            </listitem>
            <listitem>
              <para>
                A method with n mandatory parameters with or without a
                rest arg takes precedence over another method with n
                mandatory parameters with or without a rest arg, if
                the types of all parameters of the first method are
                sub-types or identical to the types of all parameters
                of the second method.
              </para>
            </listitem>
          </itemizedlist>
          It is possible to call the "next best" matching method from
          within the body of a method. To do so, the first parameter
          declaration must have the form <literal>(next:
          </literal><parameter>next-method</parameter><literal>)</literal>,
          e.g.
          <programlisting>
(define-method (value-of (next: next-method)
                         ((meta &lt;jstring&gt;) s)
                         (&lt;java.lang.Character&gt; c))
  (display "\nin method\n")
  (next-method s c))
          </programlisting>
          <parameter>next-method</parameter> can only invoke methods
          of a lower precedence than the current one. If parameters
          are supplied that do not meet this criteria then the
          procedure chained to the current generic procedure will be
          invoked, if such a procedure is present, and an error will
          be thrown otherwise.
        </para>
      </sect3>
      <sect3>
        <title>Limitations</title>
        <para>
          The generic procedures code is still relatively new and
          suffers from a number of shortcomings.
          <itemizedlist>
            <listitem>
              <para>
                Error reporting is not particularly good. Real-world
                usage will tell what errors crop up frequently and we
                can then put some mechanism in place for reporting
                them in a meaningful way.
              </para>
            </listitem>
            <listitem>
              <para>
                Generic procedures only operate on Java
                objects. &SISC; needs a more complex type system to
                fix this, which is quite hard but most of the code for
                that has already been written.
              </para>
            </listitem>
            <listitem>
              <para>
                Generic procedures are lexically scoped, but their
                methods are not.
              </para>
            </listitem>
          </itemizedlist>
          The last item implies that defining methods in a local scope
          is generally a bad idea. One exception are module
          definitions. It is perfectly safe for modules to define
          private (i.e. not exported) generic functions and add
          methods to them without interfering with other
          modules. However, care must be taken when generic functions
          are imported or exported - methods are added to generic
          function when the module gets <emphasis>defined</emphasis>
          rather then when it gets imported.
        </para>
      </sect3>
    </sect2>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
