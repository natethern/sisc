<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                    "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd" [
 <!ENTITY SISC "<emphasis>SISC</emphasis>">
 <!ENTITY R5RS "R<superscript>5</superscript>RS">
 <!ENTITY syntax "<emphasis>syntax: </emphasis>">
 <!ENTITY returns "<emphasis>returns: </emphasis>">
 <!ENTITY procedure "<emphasis>procedure: </emphasis> ">
 <!ENTITY parameter "<emphasis>parameter: </emphasis>">
 <!ENTITY f "&num;f">
 <!ENTITY requires "<emphasis>Requires: </emphasis>">
 <!ENTITY intro-chapter SYSTEM "intro.xml">
 <!ENTITY inst-chapter SYSTEM "inst.xml">
 <!ENTITY debugging-chapter SYSTEM "debug.xml">
 <!ENTITY scheme-chapter SYSTEM "scheme.xml">
 <!ENTITY library-chapter SYSTEM "library.xml">
 <!ENTITY io-chapter SYSTEM "io.xml">
 <!ENTITY threads-chapter SYSTEM "threads.xml">
 <!ENTITY modules-chapter SYSTEM "modules.xml">
 <!ENTITY genf-chapter SYSTEM "genf.xml">
 <!ENTITY java-chapter SYSTEM "java.xml">
 <!ENTITY index SYSTEM "index.xml">
 <!ENTITY gfdl SYSTEM "fdl.xml">
]>

<book lang="en">
  <!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
  <bookinfo>
    <title>
      &SISC; <emphasis>for Seasoned Schemers</emphasis>
    </title>
    <authorgroup>
      <author>
	<firstname>Scott</firstname>
	<othername>G.</othername>
	<surname>Miller</surname>
      </author>
      <author>
	<firstname>Matthias</firstname>
	<surname>Radestock</surname>
<!-- This doesn't render very well -->
<!--
	<contrib>
	  Documentation for hash tables, generic functions and Scheme/Java bridge
	</contrib>
-->
      </author>
    </authorgroup>
    <date>
      February 2002
    </date>
    <copyright>
      <year>2002</year>
      <holder>Scott G. Miller</holder>, 
      <holder>Matthias Radestock</holder>
    </copyright>
    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation License,
	Version 1.1 or any later version published by the Free Software
	Foundation; with no Invariant Sections, with no Front-Cover
	Texts, and with no Back-Cover Texts.  A copy of the license is
	included in the section entitled "GNU Free Documentation License".
	(<xref linkend="gfdl"/>)
      </para>
    </legalnotice>
      
  </bookinfo>
  &intro-chapter;
  &inst-chapter;
  &scheme-chapter;
  &debugging-chapter;
  &io-chapter;
  &threads-chapter;
  &java-chapter;
  &library-chapter;
  &modules-chapter;
  <appendix id="Errata">
    <title>Errata</title>
    <para>
      This appendix describes where this manual and the implementation
      of SISC depart.  This section should ideally remain small or empty, 
      as it is the goal of the system to conform to this document, 
      not for this document to describe the idiosyncrasies of the system.
    </para>
    <para>
      <orderedlist>
	<listitem>
          <para>
            <xref linkend="BlockIO"/> - Binary data is not correctly
            read or written in all circumstances.  Strings are capable
            of storing binary data, but on some platforms, the I/O
            ports may attempt to apply a characterset mapping to the
            data.  This will be fixed in a future release.
          </para>
        </listitem>
      </orderedlist>
    </para>
  </appendix>
  <appendix>
    <title>&R5RS; Liberties and Violations</title>
    <para>
      This section lists all ways in which &SISC; interprets the
      &R5RS; specification, where the standard is not particular clear.
      Such interpretations may allow non-portable code to be written
      and executed on &SISC; Additionally, all known &R5RS; violations
      are listed.  Actual violations are considered &SISC; bugs, and
      have a high priority for being fixed.  Violations of the
      standard are written in <emphasis role="bold">bold text</emphasis>.
    </para>
    <para>
      <orderedlist>
	<listitem>
	  <para>2.3 - 
	  &SISC; allows identifiers to start with
	    '+', '-', or '.' if they cannot be read as numbers.
	  </para>
	</listitem>
	<listitem>
	  <para>2.3 - 
	    &SISC; uses the reserved characters '[' and ']' as
	    synonyms for '(' and ')' respectively.
	  </para>
	</listitem>
	<listitem>
	  <para>2.3 - 
	    &SISC; does not raise any warning or error when
	    encountering the reserved characters "[]{}|", and allows
	    "{}|" to appear in identifiers.
	  </para>
	</listitem>
	<listitem>
	  <para>4.1.3 - 
	    &SISC; does not distinguish between () and the quoted
	    empty list '().  
	  </para>
	</listitem>
	<listitem>
	  <para>6.2.3 - 
	    The standard desires that that operations such as
	    <function>sqrt</function> try to provide exact results
	    when given exact arguments.  While &SISC; meets the requirement
for <function>sqrt</function>, it is not clear what other mathematical
	    functions should have this behavior.  &SISC; takes no
	    heroic efforts to meet this requirement.
	  </para>
	</listitem>
	<listitem>
	  <para>6.2.6 - 
	    &SISC; allows radixes other than those specified in the
	    contract for <function>number-&gt;string</function> and
	    <function>string-&gt;number</function>.  In particular,
	    any radix up to 36 is allowed, and any unsupported value
	    causes &SISC; to revert to base 10.
	  </para>
	</listitem>
      </orderedlist>
    </para>
  </appendix>
  <appendix id="system-properties">
    <title>Runtime System Properties</title>
    <para>
      System properties are key value pairs can be read by the &SISC;
      runtime to configure various aspects of its behavior.  These
      properties are ordinarily loaded from a file pointed to by the
      Java <literal>sisc.propertyfile</literal> system property.  If
      this property is unset, the file
      <literal>sisc.properties</literal> is read from the current
      directory, if it exists.  The property file consists of zero
      or more Scheme pairs, whose car is the key, and whose cdr is the
      value.  For example:
      <programlisting>
(slib . "/usr/share/slib")
(emitannotations . #t)
      </programlisting>
      Any properties set on the Java commandline override the values
      in the property file.  Boolean values, when on the Java command
      line, should be <literal>true</literal> or
      <literal>false</literal>, not <literal>#t/#f</literal>.
    </para>
    <variablelist>
      <varlistentry>
        <term><envar>sisc.emitannotations</envar></term>
        <listitem>
          <para>
            Specifies the default value of the
            <function>emit-annotations</function> parameter (see <xref
            linkend="passive-debugging"/>).  If
            <literal>true</literal>, annotations will be enabled
            before loading any source files on the command prompt and
            will stay enabled until set via the
            <function>emit-annotations</function> parameter.  If
            <literal>false</literal>, annotations will be disabled
            (the default).
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><envar>sisc.heapfile</envar></term>
        <listitem>
          <para>
            Specifies the path to a &SISC; serialized heap file to use 
            to initialize the interpreter's heap on startup.
            Overrides the default heap file.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><envar>sisc.maxprecision</envar></term>
        <listitem>
          <para>
            Specifies the maximum precision, in decimal places, to be
            maintained by the Quantity lib if using arbitrary
            precision floats.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><envar>sisc.minprecision</envar></term>
        <listitem>
          <para>
            Specifies the minimum precision, in decimal places, to be
            maintained by the Quantity lib if using arbitrary
            precision floats.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><envar>sisc.permitinterrupts</envar></term>
        <listitem>
          <para>
            If set to <literal>true</literal>,
            <function>thread/interrupt</function> will permitted to
            interrupt running <emphasis>Scheme</emphasis> code, in
            addition to sending an interrupt signal to the host
            language.  <emphasis role="bold">Can only be set on the
            command-line</emphasis>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><envar>sisc.propertyfile</envar></term>
        <listitem>
          <para>
            Specifies the property file that will be loaded, which may
            define additional properties that are superceded by those
            issued on the command-line.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </appendix>
  <appendix>
    <title>Backend Details</title>
    <note>
      <para>
        This appendix is under development
      </para>
    </note>
    <para>
      This appendix describes details of &SISC; on particular
      backends.  This is not intended to guide programming.  The
      programmer should code according to the main body of this
      document.  However, this section still describes useful
      performance tips and limitations of &SISC;'s operation.
    </para>
    <sect1>
      <title>Limits</title>
      <para>
        This appendix lays out the various limits in &SISC; running on a
        JVM backend.  These limits are <emphasis>not</emphasis>
        specifications for an expected set of limits on all platforms,
        but serve as a real-world guide.
      </para>
      <table id="JVMLimits">
        <title>&SISC; Limits</title>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
          <colspec colname='Description'/>
          <colspec colname='Limit'/>
          <thead>
            <row>
              <entry>Description</entry>
              <entry>Limit</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Fixed-point Exact Integers</entry>
              <entry>-2<superscript>31</superscript> &lt; n &lt;
              +2<superscript>31</superscript>-1</entry>
            </row>
            <row>
              <entry>AP Exact Integers</entry>
              <entry>
                -2<superscript>(2<superscript>32</superscript>-1)</superscript>
                &lt; x &lt;
                +2<superscript>(2<superscript>32</superscript>-1)</superscript>-1.
              </entry>
            </row>
            <row>
              <entry>Inexacts (<literal>32Float</literal>)</entry>
              <entry>See IEEE 754-1985 Floating Point Standard</entry>
            </row>
            <row>
              <entry>Inexacts (<literal>64Float</literal>)</entry>
              <entry>See IEEE 754-1985 Floating Point Standard</entry>
            </row>
            <row>
              <entry>Inexact Mantissa (<literal>APFloat</literal>)</entry>
              <entry>same as AP Exact Integers</entry>
            </row>
            <row>
              <entry>Inexact Exponent
              (<literal>APFloat</literal>)</entry>
              <entry>same as fixed-point exact integer</entry>
            </row>
            <row>
              <entry>Max vector elements</entry>
              <entry>Same as max fixed-point integer</entry>
            </row>
            <row>
              <entry>Max string elements</entry>
              <entry>Same as max fixed-point integer (?)</entry>
            </row>
            <row>
              <entry>Representable characters</entry>
              <entry>see <xref linkend="Characters"/></entry>
            </row>
            <row>
              <entry>Maximum formal parameters</entry>
              <entry>Same as max fixed-point integer</entry>
            </row>
            <row>
              <entry>Maximum lexical depth</entry>
              <entry>Same as max fixed-point integer</entry>
            </row>
            <row>
              <entry>Maximum symbolic-environment bindings</entry>
              <entry>Same as max fixed-point integer (?)</entry>
            </row>
            <row>
              <entry>Addressable file size</entry>
              <entry>min of 2<superscript>64</superscript>-1 and
                operating system limit</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        Arbitrary precision integers aren't quite arbitrary precision.
        &SISC; has a hard limit to the number of bits in an exact
        integer and thus to the range of representable numbers.  Exact
        integers are stored as two's complement signed integers, with
        a bit limit (including the sign bit) of
        2<superscript>32</superscript>.  This limits the range of
        representable exact integers to the numbers quoted above.
      </para>
      <para>
        Likewise, arbitrary precision inexact numbers (when present)
        have a similar hard limit.  The arbitrary precision inexact is
        constructed with an arbitrary precision exact number with the
        limits described above as the number's mantissa, and
        an exponent whose range is equivalent to that of a  
        fixed-point exact integer.
        The inexact is then then
        <literal>mantissa*10<superscript>exponent</superscript></literal>.
      </para>
    </sect1>
    <sect1>
      <title>Performance and Efficiency considerations</title>
      <sect2>
        <title>Math</title>
        <para>
          The &SISC; numeric library is most efficient when operating
          on fixed bitlength numbers.  Exact numbers are in their
          fixed bitlength mode if they are in the representable range
          for fixed exact integers, as described in <xref
          linkend="JVMLimits"/>.  Fixed bitlength inexact numbers are
          only available in the <literal>64Float</literal> and
          <literal>32Float</literal> libraries.  For &SISC; on Java,
          the <literal>64Float</literal> library is generally more
          efficient than the <literal>32Float</literal> library, while
          both are more efficient than the <literal>APFloat</literal>
          library.
        </para>
        <para>
          Fixed bitlength exact integers are only used for whole
          numbers.  Rational numbers use arbitrary precision
          components and thus are less efficient than whole fixed
          integers.
        </para>
        <para>
          Arbitrary precision inexact numbers are progressively slower
          as the bitlength of the mantissa and the scale of the
          exponent increase.  Using the precision constraints can
          prevent an unbounded increase in the scale of arbitrary
          precision inexacts which will very rapidly slow
          calculations.
        </para>
      </sect2>
      <sect2>
        <title>Strings</title>
        <para>
          At the time of this writing, the Scheme string type can be
          represented either as a character array, a native string, 
          or simultaneously as both.  The character array
          representation allows efficient, constant time modification
          of a mutable string (using <function>string-set!</function>
          for example). The native string representation allows
          efficient output to ports, string comparison, and substring
          operations.  
        </para>
        <para>
          By default, &SISC; allows the Scheme string to contain both
          representations simultaneously, ensuring that there is not a 
          costly representation conversion necessary to perform
          certain operations.  However, in this default mode, strings
          may occupy twice the memory as a string in a single
          representation.  If a program uses many strings or several
          very large strings, the programmer may wish to create 
          strings that may only be in one representation at any given 
          time.  &SISC; provides a parameter to control this behavior.
        </para>
        <para>
	  <blockquote>
	    <para>
              <indexterm><primary>compact-string-rep</primary>
              </indexterm>
	      &parameter;
	      <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>compact-string-rep</methodname>
                <methodparam choice="opt"> 
                  <parameter>boolean</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  This parameter, if set <literal>&num;t</literal>,
                  will force strings to be represented either as a
                  character array, or as a native string, but never
                  both.  If false, simultaneous representations are 
                  possible.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect2>
      <sect2>
        <title>Interrupts</title>
        <para>
          Interrupts allow running Scheme code to be forcibly broken 
          from another thread, causing the Scheme code to raise an
          error.  The interrupt signal handling code does add an
          appreciable overhead (usually between 2-10% depending on the
          JVM) to execution, and is thus disabled by default.  It can
          be enabled using the <envar>sisc.permitinterrupts</envar>
          system property.
        </para>
      </sect2>
    </sect1>
  </appendix>
  &gfdl;
  &index;
</book>
