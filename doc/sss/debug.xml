<chapter id="Debugging">
  <title>
    Debugging Facilities
  </title>
  <para>
    No Scheme system would be complete without facilities to assist
    the programmer in debugging his or her code.  &SISC; provides aid
    for passive debugging (requiring no action on the part of the
    programmer) and active debugging (requiring code instrumentation to
    facilitate debugging).  
  </para>
  <sect1 id="passive-debugging">
    <title>
      Passive Debugging
    </title>
    <para>
      Passive debugging facilities are provided that collect
      information on an error that occurred at runtime and was not
      caught by the executing code.  The programmer can then inspect
      the last error, obtain information about the call stack of
      the error, or even attempt to restart the computation.
    </para>
    <blockquote>
      <para>
        <indexterm><primary>get-last-exception</primary>
        </indexterm>
        &procedure;
        <methodsynopsis language="scheme">
          <type>exception</type>
          <methodname>get-last-exception</methodname>
          <void/>
        </methodsynopsis>
        <blockquote>
          <para>
            Retrieves the last exception that occurred
            in &SISC;.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para>
      One of the most common desires is to obtain a trace of the
      call stack, to determine what sequence of calls resulted in the
      error. &SISC; provides procedures for accessing the call stack of
      <emphasis>any</emphasis> continuation.
    </para>
    <blockquote>
      <para>
        <indexterm><primary>stack-trace</primary>
        </indexterm>
        &procedure;
        <methodsynopsis language="scheme">
          <type>list</type>
          <methodname>stack-trace</methodname>
          <methodparam><parameter>continuation</parameter></methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            Returns the stack trace for
            <parameter>continuation</parameter> in form of a
            list. Each element in the list is a pair that represents
            one level in the call stack, starting from the top. The
            car of an element a is a &SISC; virtual machine
            expression while the cdr is an association list identifying
            the corresponding Scheme code source location using the
            following keys: <literal>source-file</literal>,
            <literal>line-number</literal>,
            <literal>column-number</literal>.
          </para>
        </blockquote>
      </para>
      <para>
        <indexterm><primary>print-stack-trace</primary>
        </indexterm>
        &procedure;
        <methodsynopsis language="scheme">
          <void/>
          <methodname>print-stack-trace</methodname>
          <methodparam><parameter>continuation</parameter></methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            Displays the call stack of the
            <parameter>continuation</parameter> in a human-readable
            form.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para>
      The error message, location information and call stack
      associated with an exception can be displayed in
      human-readable form using the following procedure.
    </para>
    <blockquote>
      <para>
        <indexterm><primary>print-exception</primary>
        </indexterm>
        &procedure;
        <methodsynopsis language="scheme">
          <void/>
          <methodname>print-exception</methodname>
          <methodparam><parameter>exception</parameter>
          </methodparam>
          <methodparam choice="opt"><parameter>stack-trace?</parameter>
          </methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            Displays the error message and location of
            <parameter>exception</parameter>. A stack trace is
            displayed if <parameter>stack-trace?</parameter> is absent
            or set to &num;t. Furthermore the procedure calls itself
            recursively in order to displays that information for
            nested exceptions.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para>
      In order to obtain the source file location of a call, your
      Scheme code must have been loaded while &SISC;'s reader had
      <emphasis>annotations</emphasis> enabled.  Annotations are a
      means of attaching metadata to compiled Scheme code.  To allow
      the reader to attach annotations related to the source file
      position of the code it reads, enable the emission of
      annotations with the <function>emit-annotations</function>
      parameter.
    </para>
    <blockquote>
      <para>
        <indexterm><primary>emit-annotations</primary>
        </indexterm>
        &parameter;
        <methodsynopsis language="scheme">
          <type>&num;t/&num;f</type>
          <methodname>emit-annotations</methodname>
          <methodparam choice="opt">
            <parameter>enabled</parameter>
          </methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            If set to true, this parameter causes source files loaded
            with <function>load</function> or
            <function>import</function>, as well as source entered in
            the console, to be annotated by the reader.  This
            parameter defaults to <literal>&num;f</literal> each time
            &SISC; starts.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para>
      In addition, setting the <literal>sisc.emitannotations</literal> 
      system property to <literal>true</literal>
      will enable annotations.  This method must be used to annotate
      any source passed to &SISC; on the command line.  See <xref
      linkend="running-sisc"/> for information on passing system
      properties options to the &SISC; startup script.
    </para>
  </sect1>
  <sect1 id="ActiveDebugging">
    <title>
      Active Debugging
    </title>
    <para>
      &requires; 
      <emphasis role="bold">
	(import <emphasis>debugging</emphasis>)
      </emphasis>
    </para>
    <para>
      &SISC; provides active debugging aids; procedures and syntax
      that can be used in source code to assist in tracing the
      activities of running Scheme code.
    </para>
    <para>
      <blockquote>
	<para>
          <indexterm><primary>trace-lambda</primary>
          </indexterm>
	  &syntax;
	  <methodsynopsis language="scheme">
	    <type>procedure</type>
	    <methodname>trace-lambda</methodname>
	    <methodparam>
	      <parameter>trace-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>formals</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>body</parameter>
	    </methodparam>	
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      When replaced with a trace-lambda, all calls to a lambda
	      defined procedure are traced on the console.
	      <parameter>trace-name</parameter> is an identifier which
              will disambiguate the procedure in the trace. 
              <parameter>formals</parameter> and
	      <parameter>body</parameter> have identical semantics to 
              <function>lambda</function>.
	    </para>
	  </blockquote>
	</para>
	<para>
          <indexterm><primary>trace-let</primary>
          </indexterm>
	  &syntax;
	  <methodsynopsis language="scheme">
	    <type>value</type>
	    <methodname>trace-let</methodname>
	    <methodparam>
	      <parameter>loop-identifier</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>formal-bindings</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>body</parameter>
	    </methodparam>	
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Replaces a named-let expression in a similar manner to
	      trace-lambda.  
	    </para>
	  </blockquote>
	</para>
	<para>
          <indexterm><primary>trace</primary>
          </indexterm>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>trace</methodname>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>symbol</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Begins traces on the procedures named by the symbols
	      given.  The procedures must be defined in the top-level
	      environment.
	    </para>
            <para>
              If no procedures are given, a message is displayed
              indicating the names of top-level procedures currently
              being traced.
            </para>
	  </blockquote>
	</para>
	<para>
          <indexterm><primary>untrace</primary>
          </indexterm>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>untrace</methodname>
	    <methodparam>
	      <parameter>symbol</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>symbol</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Stops tracing the top-level procedures named by the
	      symbols given.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      <function>trace-lambda</function> and
      <function>trace-let</function> are useful for debugging
      anonymous lambdas and named-lets
      respectively. <function>trace</function> and
      <function>untrace</function> ar useful for tracing any top-level
      bound procedure, including calls to builtin procedures and
      stored continuations.
    </para>
    <para>
      When a function is traced, each call to the function will be
      displayed to the console with the function's trace identifier
      and the values of the operands the function is being applied to.
      Each nested call is indented slightly, so as to illustrate the
      depth of calls.  When the function application returns, the
      value of the function-call is displayed at the same indentation
      as the call itself.  Once indented to a certain depth, the same
      indentation is kept for further nesting, but the depth of the
      call is displayed as an integer preceding the call.
    </para>
    <note>
      <para>
        Tracing a function installs instrumentation code around
        the procedure which does not preserve the continuation
        of a call to that function.  Thus, tail calls made in 
        a traced function are no longer tail calls.  This may
        affect the memory usage characteristics of running code.
      </para>
    </note>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-indent-data:t
End:
-->
