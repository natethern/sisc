<chapter id="Debugging">
  <title>
    Debugging Facilities
  </title>
  <para>
    No Scheme system would be complete without facilities to assist
    the programmer in debugging his or her code.  &SISC; provides aid
    for passive debugging (requiring no action on the part of the
    programmer) and active debugging (requiring code instrumentation to
    facilitate debugging).  
  </para>
  <sect1 id="passive-debugging">
    <title>
      Passive Debugging
    </title>
    <para>
      Passive debugging facilities are provided that collect
      information on an error that occurred at runtime and was not
      caught by the executing code.  The programmer can then inspect
      the last error, obtain information about the call stack of
      the error, or even attempt to restart the computation.
    </para>
    <blockquote>
      <para>
        &procedure;
        <methodsynopsis language="scheme">
          <type>error-record</type>
          <methodname>get-last-error</methodname>
          <void/>
        </methodsynopsis>
        <blockquote>
          <para>
            Retrieves the error record of the last error that occurred
            in &SISC;.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para> 
      An error record is a structure containing properties of the error 
      that occurred (as described in <xref linkend="ErrorRecords"/>), 
      including the error continuation and the error value or message.
      With these two values, one may perform many of
      the actions that can be accomplished in the error-handler of a
      <literal>with-failure-continuation</literal> expression.
    </para>
    <para>
      One of the most common desires is to obtain a trace of the
      call-stack, to determine what sequence of calls resulted in the
      error.  This can be done with the
      <function>stack-trace</function>.
    </para>
    <blockquote>
      <para>
        &procedure;
        <methodsynopsis language="scheme">
          <void/>
          <methodname>stack-trace</methodname>
          <methodparam><parameter>error-record</parameter>
          </methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            Displays a trace of the call-stack for the provided
            error-record to the console.  If available, line numbers,
            column numbers, and the source file of the Scheme source
            where each call is located will be displayed.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para>
      In order to obtain the source file location of a call, your
      Scheme code must have been loaded while &SISC;'s reader had
      <emphasis>annotations</emphasis> enabled.  Annotations are a
      means of attaching metadata to compiled Scheme code.  To allow
      the reader to attach annotations related to the source file
      position of the code it reads, enable the emission of
      annotations with the <function>emit-annotations</function>
      parameter.
    </para>
    <blockquote>
      <para>
        &parameter;
        <methodsynopsis language="scheme">
          <type>&num;t/&num;f</type>
          <methodname>emit-annotations</methodname>
          <methodparam choice="opt">
            <parameter>enabled</parameter>
          </methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            If set to true, this parameter causes source files loaded
            with <function>load</function> or
            <function>import</function>, as well as source entered in
            the console, to be annotated by the reader.  This
            parameter defaults to <literal>&num;f</literal> each time
            &SISC; starts.
          </para>
        </blockquote>
      </para>
    </blockquote>
    <para>
      In addition, setting the Java system property
      <literal>sisc.emitannotations</literal> to <literal>true</literal>
      will enable annotations.  This method must be used to annotate
      any source passed to &SISC; on the command line.  See <xref
      linkend="running-sisc"/> for information on passing Java options to
      the &SISC; startup script.
    </para>
  </sect1>
  <sect1 id="ActiveDebugging">
    <title>
      Active Debugging
    </title>
    <para>
      &requires; 
      <emphasis role="bold">
	(import <emphasis>debugging</emphasis>)
      </emphasis>
    </para>
    <para>
      &SISC; provides active debugging aids; procedures and syntax
      that can be used in source code to assist in tracing the
      activities of running Scheme code.
    </para>
    <para>
      <blockquote>
	<para>
	  &syntax;
	  <methodsynopsis language="scheme">
	    <type>procedure</type>
	    <methodname>trace-lambda</methodname>
	    <methodparam>
	      <parameter>trace-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>formals</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>body</parameter>
	    </methodparam>	
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      When replaced with a trace-lambda, all calls to a lambda
	      defined procedure are traced on the console.
	      <parameter>trace-name</parameter> is a symbol to identify
	      the procedure in the trace. <parameter>formals</parameter>
              and <parameter>body</parameter> have identical
	      semantics to lambda.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &syntax;
	  <methodsynopsis language="scheme">
	    <type>value</type>
	    <methodname>trace-let</methodname>
	    <methodparam>
	      <parameter>loop-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>formal-bindings</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>body</parameter>
	    </methodparam>	
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Replaces a named-let expression in a similar manner to
	      trace-lambda.  
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>trace</methodname>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>symbol</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Begins traces on the procedures named by the symbols
	      given.  The procedures must be defined in the top-level
	      environment.
	    </para>
            <para>
              If no procedures are given, a message is displayed
              indicating the names of top-level procedures currently
              being traced.
            </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>untrace</methodname>
	    <methodparam>
	      <parameter>symbol</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>symbol</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Stops tracing the top-level procedures named by the
	      symbols given.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      <function>trace-lambda</function> and
      <function>trace-let</function> are useful for debugging
      anonymous lambdas and named-lets
      respectively. <function>trace</function> and
      <function>untrace</function> ar useful for tracing any top-level
      bound procedure, including calls to builtin procedures and
      stored continuations.
    </para>
    <para>
      When a function is traced, each call to the function will be
      displayed to the console with the function's name and the values
      of the operands the function is being applied to.  Each nested
      call is indented slightly, so as to illustrate the depth of
      calls.  When the function application returns, the value of the
      function-call is displayed at the same indentation as the call
      itself.  Once indented to a certain depth, the same indentation
      is kept for further nesting, but the depth of the call is
      displayed as an integer preceding the call.
    </para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
End:
-->
