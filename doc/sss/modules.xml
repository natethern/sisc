<chapter id="Modules">
  <title>
    Modules and Libraries
  </title>
  <sect1 id="SchemeModules">
    <title>
      Modules
    </title>
    <para>
      Modules provide an additional level of scoping control, allowing
      symbolic and syntactic bindings to be bundled in a named or
      anonymous package.  The package can then be imported into any
      scope, making the bindings contained in the module visible in
      only that scope.
    </para>
    <para>
      &SISC;'s modules are provided by the portable syntax-case macro
      expander by R. Kent Dybvig and Oscar Waddell.  A comprehensive
      explanation of the provided module system is best found in the
      <ulink url="http://www.scheme.com/csug.html">
        <citetitle>Chez Scheme Users Guide</citetitle>
      </ulink>, specifically 
      <ulink url="http://www.scheme.com/csug/syntax.html#g2187">
        <citetitle>Section 9.3, Modules</citetitle>
      </ulink>.  What follows is an informal introduction to that module 
      system.
    </para>
    <sect2 id="ModuleOverview">
      <title>Overview</title>
      <para>
        The basic unit of modularization in &SISC; is a module.
        A typical module definition has this appearance:
      </para>
        <programlisting id="typicalmodule">
(module foo
    (bar baz)
  (import boo1)
  (import boo2)
  (include "file.scm")
  (define (bar x) ...)
  (define-syntax baz ...)
  (define (something-else ...) ...)
  (do-something)
  (do-something-else))
        </programlisting>
      <para>
        A module definition consists of a name
        (<literal>foo</literal>), a list of exports
        (<literal>bar</literal> and <literal>baz</literal>) and a
        body.
        Expressions which can appear in the body of a module are the
        same as those which can appear in a
        <function>lambda</function> body.  The
        <function>import</function> form imports bindings from a named
        module (in this case <literal>boo1</literal> and
        <literal>boo2</literal>) into the current lexical scope.  The
        <function>include</function> form performs a textual inclusion
        of the source code found in the named file
        (<literal>file.scm</literal>).  In other words, it works as if
        the contents of the file had appeared literally in place of
        the <function>include</function> statement.
     </para> 
     <para>
       All identifiers appearing in the export list must be
       <function>define</function>d or
       <function>define-syntax</function>ed in the body of the module,
       or <function>import</function>ed from another module.
     </para>
    </sect2>
    <sect2 id="ModuleStyle">
      <title>Style</title>
      <para>
        It is recommended to clearly separate modularization from
        actual code.  The best way to accomplish this is to
        <itemizedlist>
          <listitem>
            <para>List all imports in the module body rather than in
            included files</para>
          </listitem>
          <listitem>
            <para>Include all files directly from the module body,
            avoiding nested includes</para>
          </listitem>
          <listitem>
            <para>Place all definitions and expressions in included
            files, avoiding them in the module body</para>
          </listitem>
        </itemizedlist>
      </para>            
      <para>
        There are several reasons for this.  First, it makes
        refactoring easier, as one can move relevant code from module
        to module merely by rewriting the module defintions, leaving
        the implementation code unchanged.  Second, it makes debugging
        easier, as one can load the implementation code directly into
        the Scheme system to have access to all bindings, or load the
        module definition to view the finished, encapsulated
        exports. Finally, it stylistically seperates interface (the
        modules) from implementation (the included Scheme source).
      </para>
    </sect2>
    <sect2 id="ModularizingCode">
      <title>Modularizing Existing Code</title>
      <para>
        Since module bodies are treated like the bodies of
        <function>lambda</function>s, the &R5RS; rules of how internal
        definitions are treated apply to all the definitions in the
        module body (both ordinary and syntax), including all code
        <function>include</function>d from files.  This is often a source
        of errors when moving code from the top-level into a module
        because:
      <itemizedlist>
          <listitem><para><emphasis>All</emphasis> definitions must
        appear <emphasis>before all</emphasis> expressions,</para>
          </listitem>
          <listitem>
            <para>The list of definitions is translated into
          <function>letrec</function>/<function>letrec-syntax</function>,
          which means it must be possible to evaluate each right-hand
          side without assigning or referring to the value of any of
          the variables being defined.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        This often necessitates re-arranging the code and the
        introduction of <function>set!</function> expressions.  Here
        is an example of a sequence of top-level
        definitions/expressions and how they need to be rewritten so
        that they may appear in a module body: 
      </para>
        <programlisting>
(define (foo) 1)
(define bar (foo))
(do-some-stuff)
(define (baz) (bar))
==>
(define (foo) 1)
(define bar)
(define (baz) (bar))
(set! bar (foo))
(do-some-stuff)
        </programlisting>
      <para>
       The general strategy is to go through the list of
       expressions/definitions from top to bottom and build two lists
       - one of definitions and one of expressions - as follows:
      <itemizedlist>
          <listitem><para>If a non-definition is encountered, append it
        to the expression list</para>
          </listitem>
          <listitem><para>If a "naked" definition (i.e. a definition
          whose right-hand side is not a function) that refers to a
          binding defined within the module is encountered, append an
          empty definition to the definition list and append a
          <function>set!</function> with the right-hand side
          expression to the expression list</para>
          </listitem>
          <listitem><para>Otherwise, i.e. for an ordinary definition,
          append it to the definition list</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        The concatenation of the resulting definition list with the
        expression list makes a suitable module body.
      </para>
    </sect2>
    <sect2 id="ModuleEvaluation">
      <title>Evaluation</title>
      <para>
        Modules are lexically scoped.  It is possible to define
        modules inside <function>lambda</function>s and inside other
        modules and to export modules from modules.  Example:
      </para>
      <programlisting>
(define (f c)
  (module foo
      (bar)
    (module bar
        (baz)
      (define (baz x y) (- x y))
      (display "defining baz\n")))
  (if (> c 0)
      (let ((a 1))
         (import foo)
         (let loop ((b c))
            (import bar)
            (if (> b 0) (loop (baz b a)) (f (- c 1)))))))
      </programlisting>
      <para>
        The expressions in a module body get executed at the time and
        in the context of module definition. So, in the above example,
        the body of bar containing the display statement is executed
        once for every call to <function>f</function> rather than once
        for every iteration of the inner loop containing the import of
        the <literal>bar</literal> module.
      </para>
      <para>
        There are quite a few more things you can do with modules. For
        instance one can define anonymous modules, which are a short
        cut for defining a named module and then importing it, import
        selected bindings from a module and renaming them rather then
        importing all bindings as is etc etc. For more details again
        refer to the Chez Scheme user manual.
      </para>
    </sect2>
  </sect1>
  <sect1> 
    <title>Libraries</title>
    <para>
      Libraries provide a means of encapsulating code that can be
      shared by many, independently developed applications.
    </para>
    <para>
      Library modules are special modules. They are defined at the top
      level and have a globally unique name (i.e. just like a Java 
      package name).
    </para>
    <para>
     Library modules can be <emphasis>compiled</emphasis> into a
     compiled library using the mechanism from <xref
     linkend="CreatingLibraries"/>.
     Loading the resulting library makes the library module available 
     to the loading code.
    </para>
    <para>
     Library modules should not depend on any top-level definitions outside
     the standard &SISC; top-level, except the definition of other library
     modules. Otherwise it is not possible to use the libraries portably.
    </para>
    <para>
     Library modules should not contain any mutable state that is affecting
     their behaviour. For instance, consider an OO library that assigns a
     unique number to all classes defined when using it. If two library
     modules used that OO library module, were compiled independently and
     then loaded, the ids of classes defined in the first library module
     would overlap with those defined in the second library module.
    </para>
    <para>
     Libraries can be packaged with supporting code (e.g. ordinary Java
     code and native modules) and other libraries into jar files. A typical
     structure for such a jar file would be
    </para>
    <programlisting>
com/foo/lib1.scm
com/foo/lib1/module.scc
com/foo/lib1/Class1.class
com/foo/lib1/Class2.class
com/foo/lib2.scm
com/foo/lib2/module.scc
com/foo/lib2/Class1.class
com/foo/lib2/Class2.class
com/foo/lib3.scm
com/foo/lib3/module.scc
com/foo/lib3/Class1.class
com/foo/lib3/Class2.class
    </programlisting>
    <para>
     The <literal>.scm</literal> files contain code to auto-load any
     libraries a library module depends on and load the
     <literal>module.scc</literal>
     (compiled module). For example, lib1.scm could look like this:
    </para>
    <programlisting>
(require-library 'com/foo/lib2)
(require-library 'com/foo/lib3)
(require-library 'some/other/library)
(load "lib1/module.scc")
    </programlisting>
    <para>
     It is usually a good idea to name the library modules after the
     path names in the jar, for example
     <literal>com/foo/lib{1,2,3}</literal> in the above example.
    </para> 
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
End:
-->
