<chapter id="SchemeLanguage">
  <title>
    Scheme Language
  </title>
  <para>
    In this chapter we will examine the language that &SISC;
    interprets, which is a superset of the
    &R5RS; Scheme Standard.
  </para>
  <sect1 id="Types">
    <title>
      Types
    </title>
    <sect2 id="Numbers">
      <title>
	Numbers
      </title>
      <para>
	The full Scheme number tower is supported:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Integers
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Floating Point numbers 
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Rational numbers
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Complex numbers
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Depending on the numeric library compiled into &SISC;,
	floating point numbers have either 32 or 64 bit IEEE
	precision, or arbitrary precision. Regardless, &SISC;'s
	complex numbers have floating point components of the same
	precision as the reals. Integers have arbitrary precision in
	all numeric libraries, and rational numbers are built with
	arbitrary precision components.
      </para>
      <sect3 id="NumericConstants">
	<title>
	  Numeric constants
	</title>
	<para>
	  The precision specifying exponents (<computeroutput>S, F,
	    L, </computeroutput>and
	  <computeroutput>D</computeroutput>) 
	  are ignored in &SISC;, all inexact numbers are kept
	  in the precision of the numeric library.  The exponents
	  are read and used to scale the real number as expected.
	  In the case of
	  arbitrary precision floats, specific precision constraints
	  are maintained to prevent a runaway increase of
	  precision. The parameterized functions
	  <function>min-precision</function> and
	  <function>max-precision</function> specify the
	  constraints:
	</para>
	<para>
	  <blockquote>
	    <para>
	      &parameter;
	      <methodsynopsis language="scheme">
		<methodtype>integer</methodtype>
		<methodname>min-precision</methodname>
		<methodparam choice="opt">
		  <parameter>digits</parameter>
		</methodparam>
	      </methodsynopsis>
	      <blockquote>
		<para>
		  Sets or displays the minimum precision constraint, an
		  integer.
		</para>
	      </blockquote>
	    </para>
	    <para>
	      &parameter;
	      <methodsynopsis language="scheme">
		<methodtype>integer</methodtype>
		<methodname>max-precision</methodname>
		<methodparam choice="opt">
		  <parameter>digits</parameter>
		</methodparam>
	      </methodsynopsis>
	      <blockquote>
		<para>
		  Sets or displays the maximum precision constraint,
		  an integer.
		</para>
	      </blockquote>
	    </para>
	  </blockquote>
	</para>
	<para>
	  All four base specifiers (<computeroutput>&num;x, &num;o,
	    &num;d, &num;b</computeroutput>) are supported for
	  integers and rationals. Only decimal 
	  (<computeroutput>&num;d</computeroutput>), the
	  default, is supported for floating point and complex
	  numbers.
	</para>
      </sect3>
      <sect3 id="Exactness">
	<title>
	  Exactness
	</title>
	<para>
	  Exactness and inexactness contagion behaves as
	  expected. Rational's are made inexact through
	  division. Floats are made exact by conversion to a
	  rational number. &SISC; attempts as accurate a conversion as
	  possible, by converting the decimal portion of the number
	  to a ratio with a denominator of the form 10^n, where n is
	  the scale of the floating point number. Then the fraction
	  is reduced as usual.
	</para>
	<para>
	  Since complex numbers must have floating point components
	  currently, conversion to an exact merely rounds the
	  components to integers. 
	</para>
      </sect3>
    </sect2>
    <sect2 id="Characters">
      <title>
	Characters
      </title>
      <para>
	&SISC;'s characters are based on the Java character type. As
	such, the full range of unicode characters are
	supported. Unicode characters can be created with
	<function>number-&gt;character</function> or 
	<computeroutput>&num;&bsol;nnnn</computeroutput>, where <computeroutput>nnnn</computeroutput> is an
	octal number in the range 0000 -&gt; ffff. 
      </para>
      <para>
	Characters are compared with respect to the locale detected
	by the Java VM.
      </para>
    </sect2>
    <sect2 id="Symbols">
      <title>
	Symbols
      </title>
      <para>
	&SISC;'s symbols are ordinarily case-insensitive. &SISC;
	maintains pointer equality between symbols with like
	contents, unless the symbol is created
	<emphasis>uninterned</emphasis>. An uninterned symbol is one
	which is guaranteed to be pointer distinct from any other
	symbol in the Scheme system, even another with the same
	contents. Uninterned symbols can be generated with:
      </para>
      <indexterm>
	<primary>string-&gt;uninterned-symbol</primary>
      </indexterm>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <methodtype>symbol</methodtype>
	      <methodname>string-&gt;uninterned-symbol</methodname>
	      <methodparam>
		<parameter>string</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Converts the provided string into an uninterned, pointer
		distinct symbol.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
	&SISC; also allows symbols to be created that
	<emphasis>are</emphasis> case-sensitive. This can be done
	one of two ways. The first involves setting the reader to
	produce cased symbols via the procedure
      </para>
      <para>
	<blockquote>
	  <para>
	    &parameter;
	    <methodsynopsis language="scheme">
	      <methodtype>#t/#f</methodtype>
	      <methodname>case-sensitive</methodname>
	      <methodparam choice="opt">
		<parameter>boolean</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Sets or retrieves the reader's case sensitivity.
	      </para>
	      </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
	The second method is via a non-standard symbol syntax. If a
	symbol is enclosed in pipe ('|') characters, the reader will
	treat that individual symbol as cased.  The syntax extends the
	&R5RS; grammar with the following production:
      </para>
      <programlisting>
&lt;cased symbol&gt; --> |&lt;identifier&gt;|
      </programlisting>
      <example>
	<title>Case sensitive Symbol literals</title>
	<programlisting>
(eq? 'a '|A|) ; => #f
(eq? 'a '|a|) ; => #t
(eq? '|A| '|a|) ; => #f
	</programlisting>
      </example>
    </sect2>
    <sect2 id="Strings">
      <title>
	Strings
      </title>
      <para>
	Strings are built from unicode characters, and are compared
	according to the locale's rules.
      </para>
    </sect2>
    <sect2 id="Vectors">
      <title>
	Vectors
      </title>
      <para>
	&SISC; supports the length prefix method of creating Vector
	constants. For example, '<computeroutput>&num;5(x)</computeroutput>'
	creates a vector constant containing five identical
	symbols.  In addition, the length-prefix form is used when
	printing vectors, and if elements repeat at the end of a
	Vector, only the last unique element is printed.  This form
	is referred to as the <emphasis>compact</emphasis> vector 
	representation.  The unprefixed form with all elements
	displayed is called the <emphasis>verbose</emphasis> representation.
      </para>
      <para>
	Vectors are displayed differently depending on the call
	used.  When called with
	<function>display</function>, in addition to the
	ordinary &R5RS; rules regarding the output of values
	displayed with <function>display</function>,
	the verbose representation is displayed. Using 
	<function>write</function>, on the other hand
	produces the compact representation.
      </para>
      <para>
	Displaying a vector with
	<function>pretty-print</function> may output
	either the verbose or compact representation of a vector.
	The behavior of pretty-print is controlled by the parameter
	<function>vector-length-prefixing</function>.
	If set to &num;t, pretty-print will emit the compact representation.
	If &num;f, the verbose representation is produced.  By default,
	<function>vector-length-prefixing</function> is true.
      </para>
      <para>
	<blockquote>
	  <para>
	    &parameter;
	    <methodsynopsis language="scheme">
	      <methodtype>#t/#f</methodtype>
	      <methodname>vector-length-prefixing</methodname>
	      <methodparam choice="opt">
		<parameter>boolean</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		If set to true, this parameter will instruct the
		pretty-printer to emit length prefixed,
		trailing-duplicate-eliminated vectors in its output.  If
		false, ordinary full-length vectors without prefixes will be
		emitted.
              </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
    </sect2>
    <sect2 id="Boxing">
      <title>
	Boxes
      </title>
      <para>
	&SISC; supports boxes, a container for a
	Scheme value. Boxing is often used to implement
	call-by-reference semantics. Boxes are created and accessed
	using the following three functions:
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>box</type>
	      <methodname>box</methodname>
	      <methodparam>
		<parameter>value</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Creates a box filled with the given value.
	      </para>
	    </blockquote>
	  </para>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>value</type>
	      <methodname>unbox</methodname>
	      <methodparam>
		<parameter>box</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Returns the value contained in the given box.
	      </para>
	    </blockquote>
	  </para>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>undefined</type>
	      <methodname>set-box!</methodname>
	      <methodparam>
		<parameter>box</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>value</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Replaces the value contained in the given box with the
		value provided.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
	In addition to the <function>box</function> function for
	creating boxes, &SISC; provides an external representation for
	boxes and boxed values. It extends the &R5RS; grammar with the 
	following:
      </para>
      <programlisting>
&lt;boxed value&gt; --&gt; &num;&amp;&lt;datum&gt;
      </programlisting>
      <para>
	This syntax denotes a boxed value, with
	<computeroutput>&lt;datum&gt;</computeroutput> as the contained
	value.
      </para>
      <para>
        Boxes, like pairs, are only equal in the sense of
        <function>eq?</function> and <function>eqv?</function> when a
        box is compared with itself.  A box is equal to another in the
        sense of <function>equal?</function> if the value contained
        within the box is <function>equal?</function> to the value
        contained in the other.
      </para>
    </sect2>
    <sect2 id="CircularStructures">
      <title>
	Circular structures
      </title>
      <para>
	&SISC; provides a parse-time syntax for 
	creating data (primarily vectors and lists) that contain
	references to themselves.  This can be useful to create streams,
	graphs, and other self-referencing structures while
	maintaining readability and avoiding complex construction
	code.
      </para>
      <para> 
	The reader syntax has two parts, defining a pointer, and
	later referencing the pointer to create the circular
	reference.
      </para>
      <para>
	Below is an additional production in the &R5RS;
	formal syntax (specifically section 7.1.2, external
	representations) to support circular structures:
      </para>
      <programlisting>
&lt;pointer definition&gt; --> #&lt;uinteger 10&gt;=&lt;datum&gt;
&lt;pointer reference&gt; --> #&lt;uinteger 10&gt;#
      </programlisting>
      <para>
	The first form instructs the reader to create a pointer
	identified by the specified integer, which maps to the datum
	that follows, and is active during the reading of the datum
	on the right-hand side of the definition.  
      </para>
      <para>
	If a second definition occurs during the reading of the
	datum with the same integral identifier, the previous
	definition is overwritten for the duration of the read.  The
	definitions are <emphasis>not</emphasis> scoped in any way.
	The pointer identifiers should be kept unique by the
	programmer to prevent any unintended effects of identifier
	collisions. 
      </para>
      <para>
	The second form references a previously created pointer 
	definition.  It is an error to reference an undefined
	pointer.  The reader will handle a valid reference by
	placing a pointer at the current read position back to the
	location of the definition. 
      </para>
      <para>
	At this point some examples might be helpful:
      </para>
      <example>
	<title>Circular Structures</title>
	<programlisting>
(define x '#0=(1 2 . #0#))
(caddr x)        ; => 1
(list-ref x 15)  ; => 2
	
(define y '(1 2 #1=#(3 4) . #1#))
(eq? (caddr y) (cdddr y)) ; => #t
	</programlisting>
      </example>
      <para>
        The Read-Eval-Print-Loop will attempt to check the structure
	it is about to print for circularities before printing.  If a
	cycle is found in the structure, the REPL will refuse to
	print, instead warning the user that the structure contains a
	cycle.  If a circular structure is printed with
	<function>display</function>, <function>write</function>, etc,
	it may cause the environment to enter an infinite loop which
	may or may cause the Scheme system to exit with an error. 
      </para>
      <para>
        No support yet exists for printing circular lists or other
        compound cyclic structures, though such functionality may
        exist in future releases.
      </para>
    </sect2>
    <sect2 id="ImmutableTypes">
      <title>
	Immutable types
      </title>
      <para>
	&SISC; follows the &R5RS;
	recommendation of immutable list, string, and vector
	constants. Quoted lists and vectors are
	immutable. Attempting to modify elements in these constants
	will raise an error. String constants are immutable as well
	when created with
	<function>symbol-&gt;string</function>.
      </para>
    </sect2>
  </sect1>
  <sect1 id="ErrorHandling">
    <title>
      Error handling
    </title>
    <para>
      &SISC; provides a sophisticated mechanism for handling errors
      raised during the execution of a program.  During the
      execution of any program, there is always a continuation that
      represents the <emphasis>rest</emphasis> of a computation.  In
      addition, one can imagine all the activities that will occur
      as a result of an error.  This sequence of actions is
      explicitly represented in &SISC; as a <emphasis>failure
	continuation</emphasis>. 
    </para>
    <sect2 id="FailureContinuations">
      <title>
	Failure continuations
      </title>
      <para>
	Similar to
	<function>call-with-current-continuation</function>,
	&SISC; provides a function,
	<function>call-with-failure-continuation</function>,
	that allows a programmer to define the sequence of actions
	that should occur as a result of an error in a called expression.
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>value</type>
	      <methodname>call-with-failure-continuation</methodname>
	      <methodparam>
		<parameter>thunk</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>handler</parameter>
	      </methodparam>
	    </methodsynopsis>
	  </para>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>value</type>
	      <methodname>call/fc</methodname>
	      <methodparam>
		<parameter>thunk</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>handler</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		<function>call-with-failure-continuation</function>
		takes as arguments a thunk (a zero-argument procedure) to
		be evaluated.  If during the
		evaluation of the thunk an error is raised, the second,
		three argument procedure is called with values describing
		the error and its context.  If no error occurs, the
		value of evaluating the thunk becomes the value of the
		call/fc expression.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
    </sect2>
    <sect2 id="ErrorHandlers">
      <title>
	Error handlers
      </title>
      <para>
	The error handler required as an argument to
	<function>call-with-failure-continuation</function>
	must take three parameters.  The first, a string, is a value
	containing information about the error that occured.  This is
	often a string containing the error message.  The
	second is a procedure encapsulating the continuation that was
	in place at the site of the error.  This continuation is
	referred to as the <emphasis>error continuation</emphasis>
	The third, the <emphasis>failure-continuation</emphasis> is
	a procedure that when invoked calls the failure continuation
	of the <function>call/fc</function> expression.  
      </para>
      <para>
	When an error occurs, the error handler may choose one of
	three courses in dealing with the error.  First, the handler
	may choose to return an alternate value as the result of the
	<function>call/fc</function> expression.
	Second, the handler may restart the computation from the
	error site by invoking the error continuation with a value
	that should be returned in place of the expression that
	caused the error.  Finally, the handler may choose to
	propagate the error (or a new error) to the failure
	continuation of the <function>call/fc</function>
	expression.  To do this, the handler invokes the
	failure-continuation with the provided or new message and
	the provided error-continuation or a different continuation
	captured by other means.
      </para>
      <para>
	At this point, a few examples may be helpful:
      </para>
      <informalexample>
	<programlisting>
(+ 1 (/ 1 0) 3)
; => <emphasis>A divide by zero error is raised</emphasis>
	</programlisting>
      </informalexample>
      <example>
	<title>Return a new value</title>
<programlisting>
(call-with-failure-continuation
  (lambda ()
    (+ 1 (/ 1 0) 3))
  (lambda (message error-k failure-k)
    'error))     
; => <emphasis>The symbol</emphasis> 'error
	</programlisting>
      </example>
      <example>
	<title>Restart with a different value</title>
	<programlisting>
(call-with-failure-continuation
   (lambda ()
     (+ 1 (/ 1 0) 3))
   (lambda (message error-k failure-k)
    (error-k 2)))
; => 6
	</programlisting>
      </example>
      <example>
	<title>Propagate the error</title>
	<programlisting>
(call-with-failure-continuation
  (lambda ()
    (+ 1 (/ 1 0) 3))
  (lambda (message error-k failure-k)
    (failure-k message error-k)))
; => <emphasis>A divide by zero error is raised</emphasis>
	</programlisting>
      </example>
    </sect2>
    <sect2>
      <title>Raising Errors</title>
      <para>
	Explicit errors are raised using the
	<function>error</function> function.  
      </para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>error</methodname>
	    <methodparam>
	      <parameter>location</parameter>
	    </methodparam>
	    <methodparam choice="opt">
	      <parameter>message</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>arguments</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Raises an error whose location is
	      <parameter>location</parameter>, and whose error
	      message, if present, is <parameter>message</parameter>.
	      If provided, the error message is a format-string that
	      is processed, with the optional
	      <parameter>argument</parameter>s, as with
	      <function>format</function> in <!--<xref linkend="format"/> -->.
	    </para>
	  </blockquote>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>error</methodname>
	    <methodparam>
	      <parameter>message</parameter>
	    </methodparam>
	    <methodparam choice="opt" rep="repeat">
	      <parameter>arguments</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Raises an error whose location undefined, and 
	      and whose error is <parameter>message</parameter>.
	      The error message is a format-string that
	      is processed, with the optional
	      <parameter>argument</parameter>s, as with
	      <function>format</function> in <!--<xref linkend="format"/> -->.
	    </para>
	  </blockquote>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>error</methodname>
	    <methodparam>
	      <parameter>error-value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Raises an error whose location undefined, and 
	      and whose error-value is any arbitrary Scheme value.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </sect2>
  </sect1>
  <sect1>
    <title><function>dynamic-wind</function></title>
    <para>
      &R5RS; does not specify the behavior of
      <function>dynamic-wind</function> in the case
      where an error is raised somewhere in a call to the
      <emphasis>during</emphasis> thunk.  &SISC; chooses to view
      an error raised in that section as an instance of the
      dynamic extent being exited.  In other words, if an error is
      raised in the dynamic extent of a dynamic-wind expression,
      &SISC; will ensure that the <emphasis>after</emphasis> thunk
      is evaluated before the error is propagated to the
      failure-continuation of the dynamic-wind expression.
    </para>
    <example>
      <title>Errors and <function>dynamic-wind</function></title>
      <programlisting>
(define x 0)
(dynamic-wind (lambda () (set! x (+ x 1)))
              (lambda () (/ 1 0))
              (lambda () (set! x (+ x 1))))

; => A divide by zero error is raised, and the value of x is 2
      </programlisting>
    </example>
    <para>
      If an error is raised in either the
      <emphasis>before</emphasis> or <emphasis>after</emphasis>
      thunks, no additional measures are taken.  The error is
      propagated to the failure-continuation of the dynamic-wind
      as if the dynamic-wind call was an ordinary function
      application.  Explicitly, if an error is raised from
      <emphasis>before</emphasis>, neither
      <emphasis>during</emphasis> nor <emphasis>after</emphasis>
      will be executed.  If an error is raised in
      <emphasis>after</emphasis>, the results of evaluating
      <emphasis>before</emphasis> and <emphasis>during</emphasis>
      remain valid.  
    </para>
    <para>
      Also noteworthy is what happens if a continuation is invoked
      that exits from either the <emphasis>before</emphasis> or
      <emphasis>after</emphasis> thunks.  Such a case is treated
      just as if a continuation was invoked during the evaluation
      of an operand to an application.  This is to say that no
      additional steps will be taken by &SISC;.  If
      <emphasis>before</emphasis> is escaped by a continuation invocation,
      neither <emphasis>during</emphasis> nor <emphasis>after</emphasis>
      will be executed.  If <emphasis>after</emphasis> is escaped,
      the results of <emphasis>before</emphasis> and
      <emphasis>during</emphasis> remain valid.
    </para>
    <para>
      In summary, extraordinary evaluation is only possible during
      the evaluation of the <emphasis>during</emphasis> thunk. The
      <emphasis>before</emphasis> and <emphasis>after</emphasis>
      thunks are evaluated with the dynamic environment and
      dynamic-wind stack of the call to dynamic-wind itself.
    </para>
  </sect1>
  <sect1 id="SymbolicEnvironments">
    <title>
      Symbolic Environments
    </title>
    <para>
      Symbolic environments (sometimes referred to as property lists) 
      provide additional named global environments useful for storing 
      program specific data without exposing it to the general
      purpose top-level environment.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>a value, or &num;f if unbound</type>
	    <methodname>getprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>environment-name</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Attempts a lookup of variable-name in the symbolic environment
	      named by environment-name.  If found, the value is returned.
	      If not bound, &num;f is returned.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>putprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>environment-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Sets the value of the variable named by variable name in the
	      symbolic environment named by environment-value to the provided
	      value.  Any previous value is forgotten.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      In addition, the top-level Scheme environment is a symbolic
      environment in &SISC; that can be accessed using getprop and putprop, 
      by ommitting the <parameter>environment-name</parameter> parameter.  
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>a value, or &num;f if unbound</type>
	    <methodname>getprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Attempts a lookup of variable-name in the top-level environment.
	      If found, the value is returned.  If not bound, &num;f
	      is returned.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>putprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Sets the value of the variable named by variable name in the
	      top-level environment to the provided value.  
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      Finally, &SISC; adheres strictly to &R5RS; when it comes to
      using <function>set!</function> to modify the
      contents of a top-level variable.  If an attempt to set an
      undefined variable is made, an error will be raised.  This
      differs from some Scheme systems that will silently create the
      binding and set it to the new value.
    </para>
  </sect1>
  <sect1>
    <title>
      Syntactic Extension
    </title>
    <para>
      &SISC; provides a hygenic macro system that fully conforms to
      the &R5RS; standard.  The macro system is provided by the
      portable syntax-case macro expander
      <citation>Expander</citation>, and as such also a more flexible 
      macro definition system called
      <function>syntax-case</function>.  A full description of the
      capabilities of the expander is best found in the 
      <ulink url="http://www.scheme.com/csug.html">
	<citetitle>Chez Scheme Users Guide</citetitle>
      </ulink>, specifically 
      <ulink url="http://www.scheme.com/csug/syntax.html#g2154">
	<citetitle>Section 9.2, Syntax-Case</citetitle>
      </ulink>.  
    </para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
End:
-->
