<chapter id="SchemeLanguage">
  <title>
    Scheme Language
  </title>
  <para>
    In this chapter we will examine the language that &SISC;
    interprets, which is a superset of the
    &R5RS; Scheme Standard.
  </para>
  <sect1 id="Types">
    <title>
      Types
    </title>
    <sect2 id="Numbers">
      <title>
	Numbers
      </title>
      <para>
	The full Scheme number tower is supported:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Integers
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Floating Point numbers 
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Rational numbers
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Complex numbers
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Depending on the numeric library compiled into &SISC;,
	floating point numbers have either 32 or 64 bit IEEE
	precision, or arbitrary precision. Regardless, &SISC;'s
	complex numbers have floating point components of the same
	precision as the reals. Integers have arbitrary precision in
	all numeric libraries, and rational numbers are built with
	arbitrary precision components.
      </para>
      <sect3 id="NumericConstants">
	<title>
	  Numeric constants
	</title>
	<para>
	  The precision specifying exponents (<computeroutput>S, F,
	    L, </computeroutput>and
	  <computeroutput>D</computeroutput>) 
	  are ignored in &SISC;, all inexact numbers are kept
	  in the precision of the numeric library.  The exponents
	  are read and used to scale the real number as expected.
	  In the case of
	  arbitrary precision floats, specific precision constraints
	  are maintained to prevent a runaway increase of
	  precision. The parameterized functions
	  <function>min-precision</function> and
	  <function>max-precision</function> specify the
	  constraints:
	</para>
	<para>
	  <blockquote>
	    <para>
	      &parameter;
	      <methodsynopsis language="scheme">
		<type>integer</type>
		<methodname>min-precision</methodname>
		<methodparam choice="opt">
		  <parameter>digits</parameter>
		</methodparam>
	      </methodsynopsis>
	      <blockquote>
		<para>
		  Sets or displays the minimum precision constraint, an
		  integer.
		</para>
	      </blockquote>
	    </para>
	    <para>
	      &parameter;
	      <methodsynopsis language="scheme">
		<type>integer</type>
		<methodname>max-precision</methodname>
		<methodparam choice="opt">
		  <parameter>digits</parameter>
		</methodparam>
	      </methodsynopsis>
	      <blockquote>
		<para>
		  Sets or displays the maximum precision constraint,
		  an integer.
		</para>
	      </blockquote>
	    </para>
	  </blockquote>
	</para>
	<para>
	  All four base specifiers (<computeroutput>&num;x, &num;o,
	    &num;d, &num;b</computeroutput>) are supported for
	  integers and rationals. Only decimal 
	  (<computeroutput>&num;d</computeroutput>), the
	  default, is supported for floating point and complex
	  numbers.
	</para>
      </sect3>
      <sect3 id="Exactness">
	<title>
	  Exactness
	</title>
	<para>
	  Exactness and inexactness contagion behaves as
	  expected. Rational's are made inexact through
	  division. Floats are made exact by conversion to a
	  rational number. &SISC; attempts as accurate a conversion as
	  possible, by converting the decimal portion of the number
	  to a ratio with a denominator of the form 10^n, where n is
	  the scale of the floating point number. Then the fraction
	  is reduced as usual.
	</para>
	<para>
	  Since complex numbers must have floating point components
	  currently, conversion to an exact merely rounds the
	  components to integers. 
	</para>
      </sect3>
    </sect2>
    <sect2 id="Characters">
      <title>
	Characters
      </title>
      <para>
	&SISC;'s characters are based on the Java character type. As
	such, the full range of unicode characters are
	supported. Unicode characters can be created with
	<function>number-&gt;character</function> or 
	<computeroutput>&num;&bsol;nnnnnn</computeroutput>, where <computeroutput>nnnn</computeroutput> is an
	octal number in the range 000000 -&gt; 177777.  At least two zeros must
        be specified to distinguish from the '0' character.
      </para>
      <para>
	Characters are compared with respect to the locale detected
	by the Java VM.
      </para>
    </sect2>
    <sect2 id="Symbols">
      <title>
	Symbols
      </title>
      <para>
	&SISC;'s symbols are ordinarily case-insensitive. &SISC;
	maintains pointer equality between symbols with like
	contents, unless the symbol is created
	<emphasis>uninterned</emphasis>. An uninterned symbol is one
	which is guaranteed to be pointer distinct from any other
	symbol in the Scheme system, even another with the same
	contents. Uninterned symbols can be generated with:
      </para>
      <indexterm>
	<primary>string-&gt;uninterned-symbol</primary>
      </indexterm>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>symbol</type>
	      <methodname>string-&gt;uninterned-symbol</methodname>
	      <methodparam>
		<parameter>string</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Converts the provided string into an uninterned, pointer
		distinct symbol.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
	&SISC; also allows symbols to be created that
	<emphasis>are</emphasis> case-sensitive. This can be done
	one of two ways. The first involves setting the reader to
	produce cased symbols via the procedure
      </para>
      <para>
	<blockquote>
	  <para>
	    &parameter;
	    <methodsynopsis language="scheme">
	      <type>#t/#f</type>
	      <methodname>case-sensitive</methodname>
	      <methodparam choice="opt">
		<parameter>boolean</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Sets or retrieves the reader's case sensitivity.
	      </para>
	      </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
	The second method is via a non-standard symbol syntax. If a
	symbol is enclosed in pipe ('|') characters, the reader will
	treat that individual symbol as cased.  The syntax extends the
	&R5RS; grammar with the following production:
      </para>
      <programlisting>
&lt;cased symbol&gt; --> |&lt;identifier&gt;|
      </programlisting>
      <example>
	<title>Case sensitive Symbol literals</title>
	<programlisting>
(eq? 'a '|A|) ; => #f
(eq? 'a '|a|) ; => #t
(eq? '|A| '|a|) ; => #f
	</programlisting>
      </example>
    </sect2>
    <sect2 id="Strings">
      <title>
	Strings
      </title>
      <para>
	Strings are built from unicode characters, and are compared
	according to the locale's rules.
      </para>
    </sect2>
    <sect2 id="Lists">
      <title>
        Pairs and Lists
      </title>
      <para>
	A function is provided to determine if a given pair is a <emphasis>proper list</emphasis>.
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>#t/#f</type>
	      <methodname>proper-list?</methodname>
	      <methodparam>
		<parameter>datum</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>        
                Returns <literal>#t</literal> if the given argument is
                a <emphasis>proper-list</emphasis>.  That is, if the
                argument is a pair, whose <literal>cdr</literal> is
                either the empty-list or also a proper-list, and which
                contains no references to itself (is not circular).
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="Vectors">
      <title>
	Vectors
      </title>
      <para>
	&SISC; supports the length prefix method of creating Vector
	constants. For example, '<computeroutput>&num;5(x)</computeroutput>
	creates a vector constant containing five identical
	symbols.  In addition, the length-prefix form is used when
	printing vectors, and if elements repeat at the end of a
	Vector, only the last unique element is printed.  This form
	is referred to as the <emphasis>compact</emphasis> vector 
	representation.  The unprefixed form with all elements
	displayed is called the <emphasis>verbose</emphasis> representation.
      </para>
      <para>
	Vectors are displayed differently depending on the call
	used.  When called with
	<function>display</function>, in addition to the
	ordinary &R5RS; rules regarding the output of values
	displayed with <function>display</function>,
	the verbose representation is displayed. Using 
	<function>write</function>, on the other hand
	produces the compact representation.
      </para>
      <para>
	Displaying a vector with
	<function>pretty-print</function> may output
	either the verbose or compact representation of a vector.
	The behavior of pretty-print is controlled by the parameter
	<function>vector-length-prefixing</function>.
	If set to &num;t, pretty-print will emit the compact representation.
	If &num;f, the verbose representation is produced.  By default,
	<function>vector-length-prefixing</function> is true.
      </para>
      <para>
	<blockquote>
	  <para>
	    &parameter;
	    <methodsynopsis language="scheme">
	      <type>#t/#f</type>
	      <methodname>vector-length-prefixing</methodname>
	      <methodparam choice="opt">
		<parameter>boolean</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		If set to true, this parameter will instruct the
		pretty-printer to emit length prefixed,
		trailing-duplicate-eliminated vectors in its output.  If
		false, ordinary full-length vectors without prefixes will be
		emitted.
              </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
    </sect2>
    <sect2 id="Boxing">
      <title>
	Boxes
      </title>
      <para>
	&SISC; supports boxes, a container for a
	Scheme value. Boxing is often used to implement
	call-by-reference semantics. Boxes are created and accessed
	using the following three functions:
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>box</type>
	      <methodname>box</methodname>
	      <methodparam>
		<parameter>value</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Creates a box filled with the given value.
	      </para>
	    </blockquote>
	  </para>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>value</type>
	      <methodname>unbox</methodname>
	      <methodparam>
		<parameter>box</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Returns the value contained in the given box.
	      </para>
	    </blockquote>
	  </para>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>undefined</type>
	      <methodname>set-box!</methodname>
	      <methodparam>
		<parameter>box</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>value</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Replaces the value contained in the given box with the
		value provided.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
	In addition to the <function>box</function> function for
	creating boxes, &SISC; provides an external representation for
	boxes and boxed values. It extends the &R5RS; grammar with the 
	following:
      </para>
      <programlisting>
&lt;boxed value&gt; --&gt; &num;&amp;&lt;datum&gt;
      </programlisting>
      <para>
	This syntax denotes a boxed value, with
	<computeroutput>&lt;datum&gt;</computeroutput> as the contained
	value.
      </para>
      <para>
	Boxes are a distinct first class type.  The
	<function>box?</function> predicate tests a value to see if is
	a box.
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>#t/#f</type>
	      <methodname>box?</methodname>
	      <methodparam>
		<parameter>value</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		Returns <literal>#t</literal> only if the given value
		is a box.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
      <para>
        Boxes, like pairs, are only equal in the sense of
        <function>eq?</function> and <function>eqv?</function> when a
        box is compared with itself.  A box is equal to another in the
        sense of <function>equal?</function> if the value contained
        within the box is <function>equal?</function> to the value
        contained in the other.
      </para>
    </sect2>
    <sect2 id="Parameters">
      <title>
        Parameters
      </title>
      <para>
        A parameter is a named thread-local variable that is accessed through
        a function.  The function, when given no arguments, returns
        the current value of the parameter.  When given an argument,
        the value of the parameter is set to the provided value.  
      </para>
      <para>
        Parameters are constructed with the
        <function>parameterize</function> procedure:
      </para>
      <para>
        &procedure;
        <methodsynopsis language="scheme">
          <type>parameter</type>
          <methodname>parameterize</methodname>
          <methodparam choice="opt">
            <parameter>initial-value</parameter>
          </methodparam>
          <methodparam choice="opt">
            <parameter>constraint</parameter>
          </methodparam>
        </methodsynopsis>
        <blockquote>
          <para>
            Creates a parameter function.  If given, the
            <parameter>initial-value</parameter> argument specifies
            the value of the parameter.  If not provided, the initial
            value is unspecified.
            <parameter>constraint</parameter>, if given, is a
            predicate that returns <literal>#t</literal> if a value to
            which the parameter is being set is a legal value for the
            parameter.  If the constraint returns
            <literal>#f</literal>, an error is raised and the
            parameter retains its old value.
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2 id="CircularStructures">
      <title>
	Circular structures
      </title>
      <para>
	&SISC; provides a parse-time syntax for 
	creating data (primarily vectors and lists) that contain
	references to themselves.  This can be useful to create streams,
	graphs, and other self-referencing structures while
	maintaining readability and avoiding complex construction
	code.
      </para>
      <para> 
	The reader syntax has two parts, defining a pointer, and
	later referencing the pointer to create the circular
	reference.
      </para>
      <para>
	Below is an additional production in the &R5RS;
	formal syntax (specifically section 7.1.2, external
	representations) to support circular structures:
      </para>
      <programlisting>
&lt;pointer definition&gt; --> #&lt;uinteger 10&gt;=&lt;datum&gt;
&lt;pointer reference&gt; --> #&lt;uinteger 10&gt;#
      </programlisting>
      <para>
	The first form instructs the reader to create a pointer
	identified by the specified integer, which maps to the datum
	that follows, and is active during the reading of the datum
	on the right-hand side of the definition.  
      </para>
      <para>
	If a second definition occurs during the reading of the
	datum with the same integral identifier, the previous
	definition is overwritten for the duration of the read.  The
	definitions are <emphasis>not</emphasis> scoped in any way.
	The pointer identifiers should be kept unique by the
	programmer to prevent any unintended effects of identifier
	collisions. 
      </para>
      <para>
	The second form references a previously created pointer 
	definition.  It is an error to reference an undefined
	pointer.  The reader will handle a valid reference by
	placing a pointer at the current read position back to the
	location of the definition. 
      </para>
      <para>
	At this point some examples might be helpful:
      </para>
      <example>
	<title>Circular Structures</title>
	<programlisting>
(define x '#0=(1 2 . #0#))
(caddr x)        ; => 1
(list-ref x 15)  ; => 2
	
(define y '(1 2 #1=#(3 4) . #1#))
(eq? (caddr y) (cdddr y)) ; => #t
	</programlisting>
      </example>
      <para>
        The Read-Eval-Print-Loop will attempt to check the structure
	it is about to print for circularities before printing.  If a
	cycle is found in the structure, the REPL will refuse to
	print, instead warning the user that the structure contains a
	cycle.  If a circular structure is printed with
	<function>display</function>, <function>write</function>, etc,
	it may cause the environment to enter an infinite loop which
	may or may cause the Scheme system to exit with an error. 
      </para>
      <para>
        No support yet exists for printing circular lists or other
        compound cyclic structures, though such functionality may
        exist in future releases.
      </para>
    </sect2>
    <sect2 id="ImmutableTypes">
      <title>
	Immutable types
      </title>
      <para>
	&SISC; follows the &R5RS;
	recommendation of immutable list, string, and vector
	constants. Quoted lists and vectors are
	immutable. Attempting to modify elements in these constants
	will raise an error. String constants are immutable as well
	when created with
	<function>symbol-&gt;string</function>.
      </para>
    </sect2>
    <sect2 id="comments">
      <title>Comments</title>
      <para>
        In addition to the single line comments of the Scheme
        standard, &SISC; supports <emphasis>s-expression
        commenting</emphasis>.  An s-expression comment is used to
        comment out an entire s-expression.  To do this, the sharp
        sequence <literal>#;</literal> is used.  It extends the &R5RS;
        grammar with the following production:
        <programlisting>
&lt;expression-comment&gt; --&gt; #;&lt;datum&gt;
        </programlisting>
      </para>
      <para>
        The reader, upon encountering this sharp sequence, will read
        and discard the next datum.
      </para>
    </sect2>
  </sect1>
  <sect1 id="ControlFeatures">
    <title>
      Control Features
    </title>
    <para>
      In addition to the &R5RS; standard control features, two
      additional forms, 
      <function>when</function> and <function>unless</function>, are
      supported by &SISC;.
    </para>
    <para>
      <blockquote>
        <para>
          &syntax;
          <methodsynopsis language="scheme">
            <type>value</type>
            <methodname>when</methodname>
            <methodparam>
              <parameter>condition</parameter>
            </methodparam>
            <methodparam>
              <parameter>expression</parameter>
            </methodparam>
            <methodparam choice="opt" rep="repeat">
              <parameter>expressions</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Evaluates <parameter>condition</parameter>, an
              expression.  If true, the expressions that follow are
              evaluated, in order, the value of the last being
              returned.  If not true, the result is unspecified.
            </para>
          </blockquote>
        </para>
        <para>
          &syntax;
          <methodsynopsis language="scheme">
            <type>value</type>
            <methodname>unless</methodname>
            <methodparam>
              <parameter>condition</parameter>
            </methodparam>
            <methodparam>
              <parameter>expression</parameter>
            </methodparam>
            <methodparam choice="opt" rep="repeat">
              <parameter>expressions</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Evaluates <parameter>condition</parameter>, an
              expression.  If false, the expressions that follow are
              evaluated, in order, the value of the last being
              returned.  If true, the result is unspecified.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </para>
  </sect1>
  <sect1 id="ErrorHandling">
    <title>
      Error handling
    </title>
    <para>
      &SISC; provides a sophisticated mechanism for handling errors
      raised during the execution of a program.  During the
      execution of any program, there is always a continuation that
      represents the <emphasis>rest</emphasis> of a computation.  In
      addition, one can imagine all the activities that will occur
      as a result of an error.  This sequence of actions is
      explicitly represented in &SISC; as a <emphasis>failure
	continuation</emphasis>. 
    </para>
    <para>
      Two values must be applied to a failure continuation.  The first
      is an error record, a datastructure which describes the error 
      (and may contain information about the name of the function that 
      generated the
      error, a descriptive message about the error, etc.).  The second
      is the continuation of the expression that raised the error.
      All errors raised in &SISC; automatically and implicitly obtain
      and apply these values to the active failure continuation.  
      Applying the error record and error continuation to the failure 
      continuation will not return
      to the continuation of the application, unless that continuation
      was captured and later invoked in a non-local entrance.
    </para>
    <para>
      The currently active failure continuation may be obtained explicitly
      using the <function>call-with-failure-continuation</function>
      procedure.  This continuation may be applied to appropriate
      values at any time in the future.
    </para>
    <para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>value</type>
	      <methodname>call-with-failure-continuation</methodname>
	      <methodparam>
		<parameter>procedure</parameter>
            </methodparam>
          </methodsynopsis>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>value</type>
	      <methodname>call/fc</methodname>
	      <methodparam>
		<parameter>procedure</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Calls the given one-argument procedure with the
              currently active failure continuation.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </para>
    <sect2 id="FailureContinuations">
      <title>
	Adding Failure Continuations
      </title>
      <para>
        A programmer may wish to augment current failure
	continuation, choosing a different set of actions to occur for
	a body of code if it raises an error.  To facilitate this,
	&SISC; provides the
	<function>with-failure-continuation</function> procedure.
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>value</type>
	      <methodname>with-failure-continuation</methodname>
	      <methodparam>
		<parameter>handler</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>thunk</parameter>
	      </methodparam>
	    </methodsynopsis>
	  </para>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type>value</type>
	      <methodname>with/fc</methodname>
	      <methodparam>
		<parameter>handler</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>thunk</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <blockquote>
	      <para>
		<function>with-failure-continuation</function>
		takes as arguments a thunk (a zero-argument procedure) to
		be evaluated.  The thunk will be evaluated in the
		continuation of the <function>with/fc</function>
		function, and with a failure continuation defined by
		the provided error handler.  If during the
		evaluation of the thunk an error is raised, the first,
		two argument procedure is called with values describing
		the error and its context.  If no error occurs, 
                value of the thunk is applied to the continuation of
                the <function>with/fc</function> expression.
	      </para>
	    </blockquote>
	  </para>
	</blockquote>
      </para>
      <sect3>
        <title>Failure Continuations and
          <function>call/cc</function></title>
        <para>
          Failure continuations exist as an attribute of the ordinary
          continuations of Scheme expressions.  Because of this, the
          invocation of a continuation may cause a different failure
          continuation to become active in the region of the invoked
          continuation.  Specifically, the failure continuation in place
          at the <function>call/cc</function> expression will be
          reinstated when that continuation is later invoked.
        </para>
        <para>
          Similarly, invoking a continuation that escapes a region of
          code will cause any created failure continuations to be
          abandonned, unless the region is itself captured in a
          continuation and later invoked.
        </para>
      </sect3>
    </sect2>
    <sect2 id="ErrorHandlers">
      <title>
	Error Handlers and <function>throw</function>
      </title>
      <para>
	The error handler required as an argument to
	<function>with-failure-continuation</function>
	must accept two value.  The first is a value
	containing information about the error that occurred.  This is
	often an association list containing a number of attributes 
        of the error.  The
	second is a procedure encapsulating the continuation that was
	in place at the site of the error.  This continuation is
	referred to as the <emphasis>error continuation</emphasis>
      </para>
      <para>
	When an error occurs, the error handler may choose one of
	three courses in dealing with the error.  First, the handler
	may choose to return an alternate value to be applied to the
	continuation of the <function>with/fc</function> expression.
	Second, the handler may restart the computation from the
	error site by invoking the error continuation with a value
	that should be returned in place of the expression that
	caused the error.  Finally, the handler may choose to
	propagate the error (or a new error) to the failure
	continuation of the <function>with/fc</function>
	expression.  This can be done with the
	<function>throw</function> function described below.
      </para>
      <para>
	<blockquote>
	  <para>
	    &procedure;
	    <methodsynopsis language="scheme">
	      <type><emphasis>does not return</emphasis></type>
	      <methodname>throw</methodname>
	      <methodparam>      
                <parameter>error-record</parameter>
              </methodparam>
	      <methodparam choice="opt">      
                <parameter>error-continuation</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Apples the given error record to the current failure 
                continuation.
                If provided, the error continuation is designated
                by the optional parameter.  If not, the continuation of 
                the throw expression is used.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        If invoked from an error-handler with the values of the handler's 
        formal parameters, throw has the effect of
        propogating the error in a manner that is equivalent to the
        absence of the modified failure-continuation. 
      </para>
      <para>
        <function>throw</function> could be defined in terms of
        <function>call-with-failure-continuation</function>
        as:
        <programlisting>
(define throw 
  (lambda (error . args)
    (call-with-failure-continuation
      (lambda (fk)
         (if (null? args)
             (call-with-current-continuation (lambda (k) (fk error k)))
             (fk error (car args)))))))
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>Error Records</title>
      <para>
        An error record is the value usually propogated with an error
        in SISC.  It is a datastructure containing such information as
        the location of the error, a descriptive message about the
        error, and possibly other error metadata.  
      </para>
      <sect3>
        <title>Creating Error Records</title>
        <para>
          Error records can be created in advance of actually 
          raising an error with the <function>make-error</function> function.
        </para>
        <para>
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>error-record</type>
                <methodname>make-error</methodname>
                <methodparam choice="opt">
                  <parameter>location</parameter>
                </methodparam>
                <methodparam choice="opt">
                  <parameter>message</parameter>
                </methodparam>
                <methodparam choice="opt" rep="repeat">
                  <parameter>arguments</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Constructs an error record whose location, if provided, is
                  <parameter>location</parameter>, a symbol; and whose error
                  message, if present, is <parameter>message</parameter>.
                  If provided, the error message is a format-string that
                  is processed, with the optional
                  <parameter>argument</parameter>s, as with the
                <function>format</function> function in SRFI 28.
                </para>
              </blockquote>
              &procedure;
              <methodsynopsis language="scheme">
                <type>error-record</type>
                <methodname>make-error</methodname>
                <methodparam choice="opt">
                  <parameter>location</parameter>
                </methodparam>
                <methodparam>
                  <parameter>error-value</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates an error record whose location, if present, is the
                  symbol <parameter>location</parameter>, and 
                  and whose error-value is any arbitrary Scheme value.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
      </sect3>
      <sect3>
        <title>Nested Errors</title>
        <para>
          In addition, an error record may be created that adds
          additional information to an error record that was already
          created.  This is useful when an error was caught in an
          error handler, and one wishes to raise an error from the
          handler that contains additional information about the local
          location or error message as well as the error that was
          caught.
        </para>
        <para>
          <blockquote>
            <para>
              &procedure;
              <methodsynopsis language="scheme">
                <type>error-record</type>
                <methodname>make-nested-error</methodname>
                <methodparam>
                  <parameter>local-error</parameter>
                </methodparam>
                <methodparam>
                  <parameter>parent-error</parameter>
                </methodparam>
              </methodsynopsis>
              <blockquote>
                <para>
                  Creates an error record which has
                  <parameter>parent-error</parameter> as the root
                  cause of an error-record created and passed as 
                  <parameter>local-error</parameter>.
                </para>
              </blockquote>
            </para>
          </blockquote>
        </para>
        <para> 
          An example of the creating, throwing, and display of a
          nested error follows.
        </para>
        <informalexample>
          <programlisting>
(with-failure-continuation
  (lambda (m e)
    (throw (make-nested-error 
            (make-error 'foo "could not call bar.")) m))
  (lambda ()
    (error 'bar "something went wrong.")))
;=> Error in nested call from foo: could not call bar.
;    Error in bar: something went wrong.
          </programlisting>
        </informalexample>
      </sect3>
    </sect2>
    <sect2>
      <title>Standard <function>error</function> function</title>
      <para>
        For convenience and compatibility with SRFI-23, the function
        <function>error</function> is provided.  Its syntax is
        identical to <function>make-error</function>, but it
        immediately applies the resulting error record to the current
        failure continuation with the current continuation as the
        error continuation.
      </para>
      <para>
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type><emphasis>does not return</emphasis></type>
              <methodname>error</methodname>
              <methodparam choice="opt">
                <parameter>location</parameter>
              </methodparam>
              <methodparam choice="opt">
                <parameter>message</parameter>
              </methodparam>
              <methodparam choice="opt" rep="repeat">
                <parameter>arguments</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Raises an error record whose location, if provided, is
                <parameter>location</parameter>, a symbol; and whose error
                message, if present, is <parameter>message</parameter>.
                If provided, the error message is a format-string that
                is processed, with the optional
                <parameter>argument</parameter>s, as with the
                <function>format</function> function in SRFI 28.
              </para>
            </blockquote>
            &procedure;
            <methodsynopsis language="scheme">
              <type><emphasis>does not return</emphasis></type>
              <methodname>error</methodname>
              <methodparam choice="opt">
                <parameter>location</parameter>
              </methodparam>
              <methodparam>
                <parameter>error-value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Raises an error record whose location, if present, is the
                symbol <parameter>location</parameter>, and 
                and whose error-value is any arbitrary Scheme value.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        <function>error</function> can be implemented in terms of
        <function>throw</function> and <function>make-error</function>:
        <programlisting>
(define error
  (lambda args
    (throw (apply make-error args))))
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>Examples</title>
      <para>
	At this point, a few examples may be helpful:
      </para>
      <informalexample>
	<programlisting>
(+ 1 (/ 1 0) 3)
; => <emphasis>A divide by zero error is raised</emphasis>
	</programlisting>
      </informalexample>
      <example>
	<title>Return a new value</title>
<programlisting>
(with-failure-continuation
  (lambda (message error-k)
    'error)
  (lambda ()
    (+ 1 (/ 1 0) 3)))
; => <emphasis>The symbol</emphasis> 'error
	</programlisting>
      </example>
      <example>
	<title>Restart with a different value</title>
	<programlisting>
(with-failure-continuation
   (lambda (message error-k)
    (error-k 2))
   (lambda ()
     (+ 1 (/ 1 0) 3)))
; => 6
	</programlisting>
      </example>
      <example>
	<title>Propagate the error</title>
	<programlisting>
(with-failure-continuation
  (lambda (message error-k)
    (rethrow message error-k))
  (lambda ()
    (+ 1 (/ 1 0) 3)))
; => <emphasis>A divide by zero error is raised</emphasis>
	</programlisting>
      </example>
    </sect2>
  </sect1>
  <sect1>
    <title><function>dynamic-wind</function></title>
    <para>
      &R5RS; does not specify the behavior of
      <function>dynamic-wind</function> in the case
      where an error is raised somewhere in a call to the
      <emphasis>during</emphasis> thunk.  &SISC; chooses to view
      an error raised in that section as an instance of the
      dynamic extent being exited.  In other words, if an error is
      raised in the dynamic extent of a dynamic-wind expression,
      &SISC; will ensure that the <emphasis>after</emphasis> thunk
      is evaluated before the error is propagated to the
      failure-continuation of the dynamic-wind expression.
    </para>
    <example>
      <title>Errors and <function>dynamic-wind</function></title>
      <programlisting>
(define x 0)
(dynamic-wind (lambda () (set! x (+ x 1)))
              (lambda () (/ 1 0))
              (lambda () (set! x (+ x 1))))

; => A divide by zero error is raised, and the value of x is 2
      </programlisting>
    </example>
    <para>
      If an error is raised in either the
      <emphasis>before</emphasis> or <emphasis>after</emphasis>
      thunks, no additional measures are taken.  The error is
      propagated to the failure-continuation of the dynamic-wind
      as if the dynamic-wind call was an ordinary function
      application.  Explicitly, if an error is raised from
      <emphasis>before</emphasis>, neither
      <emphasis>during</emphasis> nor <emphasis>after</emphasis>
      will be executed.  If an error is raised in
      <emphasis>after</emphasis>, the results of evaluating
      <emphasis>before</emphasis> and <emphasis>during</emphasis>
      remain valid.  
    </para>
    <para>
      Also noteworthy is what happens if a continuation is invoked
      that exits from either the <emphasis>before</emphasis> or
      <emphasis>after</emphasis> thunks.  Such a case is treated
      just as if a continuation was invoked during the evaluation
      of an operand to an application.  This is to say that no
      additional steps will be taken by &SISC;.  If
      <emphasis>before</emphasis> is escaped by a continuation invocation,
      neither <emphasis>during</emphasis> nor <emphasis>after</emphasis>
      will be executed.  If <emphasis>after</emphasis> is escaped,
      the results of <emphasis>before</emphasis> and
      <emphasis>during</emphasis> remain valid.
    </para>
    <para>
      In summary, extraordinary evaluation is only possible during
      the evaluation of the <emphasis>during</emphasis> thunk. The
      <emphasis>before</emphasis> and <emphasis>after</emphasis>
      thunks are evaluated with the dynamic environment and
      dynamic-wind stack of the call to dynamic-wind itself.
    </para>
  </sect1>
  <sect1 id="SymbolicEnvironments">
    <title>
      Symbolic Environments
    </title>
    <para>
      Symbolic environments (sometimes referred to as property lists) 
      provide additional named global environments useful for storing 
      program specific data without exposing it to the general
      purpose top-level environment.
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>a value, or &num;f if unbound</type>
	    <methodname>getprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>environment-name</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Attempts a lookup of variable-name in the symbolic environment
	      named by environment-name (both are symbols).  If found,
	      the value is returned.
	      If not bound, &num;f is returned.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>putprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>environment-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Sets the value of the variable named by variable name in the
	      symbolic environment named by environment-value to the provided
	      value (both are symbols).  Any previous value is forgotten.
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      In addition, the top-level Scheme environment is a symbolic
      environment in &SISC; that can be accessed using getprop and putprop, 
      by omitting the <parameter>environment-name</parameter> parameter.  
    </para>
    <para>
      <blockquote>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>a value, or &num;f if unbound</type>
	    <methodname>getprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Attempts a lookup of variable-name in the top-level environment.
	      If found, the value is returned.  If not bound, &num;f
	      is returned.
	    </para>
	  </blockquote>
	</para>
	<para>
	  &procedure;
	  <methodsynopsis language="scheme">
	    <type>undefined</type>
	    <methodname>putprop</methodname>
	    <methodparam>
	      <parameter>variable-name</parameter>
	    </methodparam>
	    <methodparam>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <blockquote>
	    <para>
	      Sets the value of the variable named by variable name in the
	      top-level environment to the provided value.  
	    </para>
	  </blockquote>
	</para>
      </blockquote>
    </para>
    <para>
      Finally, &SISC; adheres strictly to &R5RS; when it comes to
      using <function>set!</function> to modify the
      contents of a top-level variable.  If an attempt to set an
      undefined variable is made, an error will be raised.  This
      differs from some Scheme systems that will silently create the
      binding and set it to the new value.
    </para>
  </sect1>
  <sect1>
    <title>
      Syntactic Extension
    </title>
    <para>
      &SISC; provides a hygienic macro system that fully conforms to
      the &R5RS; standard.  The macro system is provided by the
      portable syntax-case macro expander.  In addition to &R5RS;
      macros, the expander provides a more flexible 
      macro definition tool called
      <function>syntax-case</function>.  A full description of the
      capabilities of the expander is best found in the 
      <ulink url="http://www.scheme.com/csug.html">
	<citetitle>Chez Scheme Users Guide</citetitle>
      </ulink>, specifically 
      <ulink url="http://www.scheme.com/csug/syntax.html#g2154">
	<citetitle>Section 9.2, Syntax-Case</citetitle>
      </ulink>.  
    </para>
  </sect1>
  <sect1 id="MiscellaneousFunctions">
    <title>
      Miscellaneous Functions
    </title>
    <para>
      The remaining functions in this chapter are not easily classified, but 
      nevertheless are useful and worth describing.
    </para>
    <para>
      <blockquote>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>#t/#f</type>
            <methodname>circular?</methodname>
            <methodparam>
              <parameter>datum</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns <literal>#t</literal> if the given datum
              is circular.  A datum is circular if it is a compound
              datum (lists or vectors for example), and one of its
              elements is a reference to itself, or a reference to a
              sub-element which creates a cycle.
            </para>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>procedure</type>
            <methodname>compose</methodname>
            <methodparam choice="opt" rep="repeat">
              <parameter>function</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              <function>compose</function> takes zero or more
              functions and returns a new procedure that will apply to
              its arguments the arguments to
              <function>compose</function> in reverse order.  If no
              functions are provided, the identity function is
              returned.
            </para>
            <para>
              For example, the function <function>caddr</function>
              could be simply defined as:
            </para>
            <programlisting>
(define caddr (compose car cdr cdr))
            </programlisting>
          </blockquote>
        </para>
        <para>
          &procedure;
          <methodsynopsis language="scheme">
            <type>pair</type>
            <methodname>iota</methodname>
            <methodparam>
              <parameter>n</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              The <function>iota</function> function produces a list
              whose elements are the integers 0 to
              <parameter>n</parameter>-1 inclusive.
            </para>
          </blockquote>
        </para>
        <para>
          &syntax;
          <methodsynopsis language="scheme">
            <type>list</type>
            <methodname>time</methodname>
            <methodparam choice="opt">
              <parameter>iterations</parameter>
            </methodparam>
            <methodparam>
              <parameter>expression</parameter>
            </methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Evaluates the given expression
              <parameter>iterations</parameter> times, or if
              <parameter>iterations</parameter> is not provided, only
              once.  When complete, a list is returned of the
              following form:
              <programlisting>
(result (<emphasis>n</emphasis> ms))
              </programlisting>
              where <emphasis>n</emphasis> is the number of
              milliseconds taken to evaluate the expression.  If more
              than one iteration ocurred, then the average number of
              milliseconds elapsed is returned.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
