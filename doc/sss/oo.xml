<chapter id="OO">
  <title>Object Oriented Programming</title>
    <para>
        &requires; 
      <emphasis role="bold">
        (import <emphasis>generic-procedures</emphasis>)
      </emphasis>
    </para>
  <sect1 id="TypeSystem">
    <title>Type System</title>
    <para>
      The &SISC; type system supports the following kinds of types:
      <itemizedlist>
        <listitem>
          <para>
            Scheme-level classes, as described in <xref
            linkend="SchemeClasses"/>
            </para>
        </listitem>
        <listitem>
          <para>
            Java classes and interfaces, obtained through the
            mechanisms described in <xref linkend="JavaClasses"/>.
          </para>
        </listitem>
        <listitem>
          <para>
            Meta types, obtained by invoking
            <function>meta</function>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>&lt;top&gt;</literal> and
            <literal>&lt;bot&gt;</literal>. All types are
            sub-types of <literal>&lt;top&gt;</literal> and
            super-types of <literal>&lt;bot&gt;</literal>.
          </para>
        </listitem>
      </itemizedlist>
      <function>meta</function> is defined as follows:
      <blockquote>
        <para>
          <indexterm><primary>meta</primary>
          </indexterm>
            &procedure;
          <methodsynopsis language="scheme">
            <type>type</type>
            <methodname>meta</methodname>
            <methodparam><parameter>type</parameter></methodparam>
          </methodsynopsis>
          <blockquote>
            <para>
              Returns the meta type of <parameter>type</parameter>,
              i.e. a type whose instances are comprised of
              <parameter>type</parameter> and all its sub-types.
            </para>
          </blockquote>
        </para>
      </blockquote>
    </para>
    <sect2>
      <title>Type Operations</title>
      <para>
        Types can be compared with
        <blockquote>
          <para>
            <indexterm><primary>type&lt;=</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>type&lt;=</methodname>
              <methodparam><parameter>type1</parameter></methodparam>
              <methodparam><parameter>type2</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>type1</parameter> is a
                sub-type of <parameter>type2</parameter>, &num;f
                otherwise.
              </para>
              <para>
                Meta types are compared by comparing their underlying
                types.
              </para>
            </blockquote>
          </para>
        </blockquote>
        The type of an object can be obtained with
        <blockquote>
          <para>
            <indexterm><primary>type-of</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>type</type>
              <methodname>type-of</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the type of <parameter>value</parameter>. The
                type of an object (Scheme or Java) is represented by
                its class (Scheme or Java). The type of a class
                (Scheme or Java) is represented by its meta type.  The
                type of any other Scheme value is represented by its
                corresponding &SISC; Java class.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2>
      <title>Class Operations</title>
      <para>
        For types that are classes, the following operations are
        supported:
        <blockquote>
          <para>
            <indexterm><primary>class-direct-superclasses</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>class-direct-superclasses</methodname>
              <methodparam><parameter>class</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the list of classes of which
                <parameter>class</parameter> is a direct
                descendant. If <parameter>class</parameter> is a
                Java class or interface the list comprises the
                superclass and superinterfaces in exactly the order
                specified in the class/interface declaration.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>class-direct-slot-names</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>class-direct-slot-names</methodname>
              <methodparam><parameter>class</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the list of slot names (as symbols) directly
                defined by <parameter>class</parameter>. If
                <parameter>class</parameter> is a Java class or
                interface the list comprises the names of
                the static and normal fields specified in the
                class/interface declaration.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>class-precedence-list</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>class-precedence-list</methodname>
              <methodparam><parameter>class</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the class precedence list for class
                <parameter>class</parameter>. The class precedence
                list for a class <varname>C</varname> is a total
                ordering on <varname>C</varname> and its
                superclasses that is consistent with the local
                precedence order of <varname>C</varname> and with
                the class precedence lists of its superclasses.
              </para>
              <para>
                Two
                lists are consistent if for every
                <varname>A</varname> and <varname>B</varname> that
                are each members of both lists, either
                <varname>A</varname> precedes <varname>B</varname>
                in both or <varname>B</varname> precedes
                <varname>A</varname> in both.
              </para>
              <para>
                The local precedence order of a class
                <varname>C</varname> consists of the class itself
                followed by the direct superclasses as returned by
                <function>class-direct-superclasses</function>.
              </para>
              <para>
                The exact algorithm for computing the class
                precedence list is the same as that employed by
                Dylan, Goo and others. When there are
                <emphasis>several</emphasis> possible total
                orderings, one is chosen deterministically. When
                there is <emphasis>no</emphasis> possible total
                ordering, an error is signalled. The details of the
                algorithm are beyond the scope of this document. The
                interested reader is referred to the Dylan
                documentation and the &SISC; source code.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
    <sect2>
      <title>Predicates</title>
      <para>
        One can test whether an object is an instance of a
        particular type with
        <blockquote>
          <para>
            <indexterm><primary>instance-of?</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>instance-of?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
              <methodparam><parameter>type</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is an
                instance of <parameter>type</parameter>, &num;f
                otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
        Two predicates are provided that determine whether a value
        is an object or a class respectively.
        <blockquote>
          <para>
            <indexterm><primary>object?</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>object?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is an
                object (Scheme or Java), &num;f otherwise. Note that
                classes are objects.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>class?</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>class?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                class (Scheme or Java), &num;f otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
  </sect1>
  <sect1 id="GenericProcedures">
    <title>Generic Procedures</title>
    <para>
      Generic procedures provide a mechanism by which a Scheme
      procedure can select different bodies for execution depending on
      the types of the parameters it was called with. Languages like
      ANSI Lisp and Dylan provide similar functionality. Generic
      procedures have several advantages over normal functions:
      <itemizedlist>
        <listitem>
          <para>
            It is not necessary to come up with unique names for
            procedures that perform the same operation on different
            types of objects. This avoids cluttering the name
            space. All these procedures can be defined separately
            but yet be part of the same, single generic procedure.
          </para>
        </listitem>
        <listitem>
          <para>
            The functionality of a generic procedure can be extended
            incrementally through code located in different
            places. This avoids "spaghetti code" where adding a new
            type of objects requires changes to existing pieces of
            code in several locations.
          </para>
        </listitem>
        <listitem>
          <para>
            Code using generic procedures has a high degree of
            polymorphism without having to resort to ugly and
            hard-to-maintain test-type-and-dispatch branching.
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <sect2 id="genprocdef">
      <title>Defining Generic Procedures</title>
      <para>
        There are two steps to defining generic procedures -
        defining the generic procedures itself and adding methods to
        it.
      </para>
      <para>
        <blockquote>
          <para>
            <indexterm><primary>define-generic</primary>
            </indexterm>
              &syntax;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>define-generic</methodname>
              <methodparam><parameter>name</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>next-proc</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new generic procedure and binds it to
                <parameter>name</parameter> in the current lexical
                environment. <parameter>next-proc</parameter> specifies
                a procedure to be invoked when an invocation of the
                generic procedure finds no matching method. This
                mechanism is known as <emphasis>chaining</emphasis>. By
                default, <parameter>next-proc</parameter> is set to
                <literal>(generic-java-procedure
                  '</literal><parameter>name</parameter><literal>)</literal>
                (see <xref linkend="JavaMethodInvocation"/>), resulting
                in the invocation of Java methods if no matching Scheme
                methods are found. Setting
                <parameter>next-proc</parameter> to &num;f disables
                chaining; an error will be thrown if an invocation of
                the generic procedure cannot find a matching method.
              </para>
            </blockquote>
          </para>
        </blockquote>
        Generic procedures can also be constructed procedurally, using
        <blockquote>
          <para>
            <indexterm><primary>make-generic-procedure</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>proc</type>
              <methodname>make-generic-procedure</methodname>
              <methodparam choice="opt">
                <parameter>next-proc</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new generic procedure that is chained to
                <parameter>next-proc</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
        There are accessors for the various elements that make up a
        generic procedure:
        <blockquote>
          <para>
            <indexterm><primary>generic-procedure-methods</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>list</type>
              <methodname>generic-procedure-methods</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns a list of the methods which are part of the
                generic procedure <parameter>proc</parameter>, in order
                of their precedence.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>generic-procedure-next</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>proc/&num;f</type>
              <methodname>generic-procedure-next</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the chainee of the generic procedure
                <parameter>proc</parameter>, or &num;f if no chainee was
                specified.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        Methods can be added to generic procedures with
        <blockquote>
          <para>
            <indexterm><primary>define-method</primary>
            </indexterm>
              &syntax;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>define-method</methodname>
              <methodparam><parameter>signature</parameter></methodparam>
              <methodparam><parameter>.</parameter></methodparam>
              <methodparam><parameter>body</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <simplelist>
                <member>
                  where <parameter>signature</parameter> is of the
                  form <literal>(</literal><parameter>name</parameter>
                  <literal>(</literal><parameter>type</parameter>
                  <parameter>param</parameter><literal>)</literal>
                  ... [ <literal>.</literal>
                  <parameter>rest</parameter>]<literal>)</literal>
                </member>
                <member>
                  and <parameter>body</parameter> can contain anything
                  that is valid inside the body of a
                  <function>lambda</function>.
                </member>
              </simplelist>
              <para>
                Adds a method the generic procedure
                <parameter>name</parameter>. A method has a typed
                parameter list and a body. Defining a method with the
                same signature as an existing method overwrites the
                existing method.
              </para>
              <note>
                <para>
                  <function>define-method</function> is a macro that
                  expands into a function call rather than a
                  definition. This means any usage inside a function
                  must occur <emphasis>after</emphasis> all
                  definitions. Otherwise a syntax error will be raised.
                </para>
              </note>
            </blockquote>
          </para>
        </blockquote>
        Methods can also be defined procedurally using
        <blockquote>
          <para>
            <indexterm><primary>make-method</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>method</type>
              <methodname>make-method</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
              <methodparam><parameter>types</parameter></methodparam>
              <methodparam><parameter>rest?</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a new method. <parameter>proc</parameter> is a
                procedure that will be invoked when the method is
                invoked. <parameter>types</parameter> is a list of
                types, one for each parameter of the
                method. <parameter>rest?</parameter> is a boolean that
                indicates whether the method can take additional
                (optional) parameters. The combination of
                <parameter>types</parameter> and
                <parameter>rest?</parameter> make up the
                <emphasis>signature</emphasis> of the method.
              </para>
            </blockquote>
          </para>
        </blockquote>
        A method thus defined can be added to a generic procedure
        with
        <blockquote>
          <para>
            <indexterm><primary>add-method</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>add-method</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
              <methodparam><parameter>method</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Adds the method <parameter>method</parameter> to the
                generic procedure <parameter>proc</parameter>. If a
                method with the same signature as an existing method is
                added, the existing method is replaced with the new
                method.
              </para>
            </blockquote>
          </para>
        </blockquote>
        There are accessors for the various elements that make up a
        method:
        <blockquote>
          <simplelist>
            <member>
              <indexterm><primary>method-procedure</primary>
              </indexterm>
                &procedure;
              <methodsynopsis language="scheme">
                <type>proc</type>
                <methodname>method-procedure</methodname>
                <methodparam><parameter>method</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              <indexterm><primary>method-types</primary>
              </indexterm>
                &procedure;
              <methodsynopsis language="scheme">
                <type>list</type>
                <methodname>method-types</methodname>
                <methodparam><parameter>method</parameter></methodparam>
              </methodsynopsis>
            </member>
            <member>
              <indexterm><primary>method-rest?</primary>
              </indexterm>
                &procedure;
              <methodsynopsis language="scheme">
                <type>&num;t/&num;f</type>
                <methodname>method-rest?</methodname>
                <methodparam><parameter>method</parameter></methodparam>
              </methodsynopsis>
            </member>
          </simplelist>
          <blockquote>
            <para>
              Returns the methods procedure, parameter types and rest
              parameter flag respectively.
            </para>
          </blockquote>
        </blockquote>
      </para>
      <para>
        An example might be helpful at this stage.
        <programlisting>
(define-generic app (generic-java-procedure 'append))
(define-method (app (next: next-method)
  (&lt;jstringbuffer&gt; buf) . rest)
  (for-each (lambda (x) (next-method buf x)) rest)
  buf)
(define sb (make &lt;jstringbuffer&gt;))
(-&gt;string (app sb (-&gt;jstring "foo") (-&gt;jint 1) (-&gt;jstring "bar"))) ;=&gt; "foo1bar"
        </programlisting>
        This defines a new generic procedure
        <function>app</function> which is chained to a generic
        procedure representing the Java <function>append</function>
        methods. The explicit chaining is done in order to avoid a
        name clash with Scheme's <function>append</function>
        procedure. A method is defined on the generic procedure that
        appends the contents of any number of arguments to a
        <classname>java.lang.StringBuffer</classname>. It does this
        by calling the Java method for appending a single object
        using the <function>next-method</function> mechanism which
        we will describe later.
      </para>
    </sect2>
    <sect2 id="genconstrdef">
      <title>Defining Constructors</title>
      <para>
        Constructors are defined with
        <blockquote>
          <para>
            <indexterm><primary>define-constructor</primary>
            </indexterm>
              &syntax;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>define-constructor</methodname>
              <methodparam><parameter>signature</parameter></methodparam>
              <methodparam><parameter>.</parameter></methodparam>
              <methodparam><parameter>body</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <simplelist>
                <member>
                  where <parameter>signature</parameter> is of the
                  form <literal>(</literal><parameter>type</parameter>
                  <literal>(</literal><parameter>type</parameter>
                  <parameter>param</parameter><literal>)</literal>
                  ... [ <literal>.</literal>
                  <parameter>rest</parameter>]<literal>)</literal>
                </member>
                <member>
                  and <parameter>body</parameter> can contain anything
                  that is valid inside the body of a
                  <function>lambda</function>.
                </member>
              </simplelist>
              <para>
                This form is basically identical to the
                <function>define-method</function> form except it
                defines a "constructor" method for a specific
                type. All constructor methods are part of the single
                generic constructor called by <function>make</function>.
              </para>
              <note>
                <para>
                  <function>define-constructor</function> is a macro that
                  expands into a function call rather than a
                  definition. This means any usage inside a function
                  must occur <emphasis>after</emphasis> all
                  definitions. Otherwise a syntax error will be raised.
                </para>
              </note>
            </blockquote>
          </para>
        </blockquote>
        New generic constructors can be created with
        <blockquote>
          <para>
            <indexterm><primary>make-generic-constructor</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>proc</type>
              <methodname>make-generic-constructor</methodname>
              <methodparam choice="opt">
                <parameter>next-proc</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Creates a generic constructor which is chained to
                <parameter>next-proc</parameter>, which must be
                another generic constructor. This procedure is
                rarely used since the pre-defined generic
                constructor called by <function>make</function>
                typically suffices.
              </para>
            </blockquote>
          </para>
        </blockquote>
        Generic constructors maintain a table of generic procedures
        - one for each class of which instances can be
        constructed. The mapping is performed by
        <blockquote>
          <para>
            <indexterm><primary>constructor</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>proc</type>
              <methodname>constructor</methodname>
              <methodparam><parameter>constr</parameter></methodparam>
              <methodparam><parameter>class</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns the generic procedure that holds constructor
                methods for class <parameter>class</parameter> of the
                generic constructor <parameter>constr</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        After <function>make</function> has invoked the generic
        constructor, it calls the <function>initialize</function>
        generic procedure with the result of the constructor
        invocation an the arguments supplied to
        <function>make</function>. The main purpose of
        <function>initialize</function> is to facilitate the
        definition of post-creation object initialization,
        particularly the invocation of initialization code for
        superclasses.
      </para>
      <para>
        The <function>initialize</function> generic procedure is
        chained to a procedure that accepts any number of arguments
        and returns nothing. As a result it is not necessary to
        define methods for <function>initialize</function> unless
        post-creation initialization is required. Furthermore, it is
        always possible to invoke the "next best" matching method
        (as described below) from the body of an
        <function>initialize</function> method.
      </para>
      <para>
        An example might be helpful at this stage.
        <programlisting>
(define-constructor (&lt;jstring&gt; (&lt;jchar&gt; c))
  (make &lt;jstring&gt; (-&gt;jarray (list c) &lt;jchar&gt;)))
(-&gt;string (make &lt;jstring&gt; (-&gt;jchar #\o))) ;=&gt; "o"
(define-constructor (&lt;jstringbuffer&gt; (next: next-method) . rest)
  (next-method))
(define-method (initialize (&lt;jstringbuffer&gt; sb) . rest)
  (apply app sb rest))
(-&gt;string (make &lt;jstringbuffer&gt; (-&gt;jstring "foo") (-&gt;jint 1) (-&gt;jstring "bar"))) ;=&gt; "foo1bar"
        </programlisting>
        First this defines a method new constructor on
        <classname>java.lang.String</classname> that constructs a
        string from a single character by constructing a
        single-element array of characters and invoking the existing
        Java constructor with it. Second, a new constructor is
        defined for <classname>java.lang.StringBuffer</classname>
        that takes any number of arguments and calls
        <classname>StringBuffer</classname>'s the null-arg
        constructor. An initialization method is defined that
        appends all the arguments to a
        <classname>StringBuffer</classname> instance. The subsequent
        call to <function>make</function> invokes the defined
        constructor method which in turn invokes the null-arg
        constructor defined in Java. Then <function>make</function>
        calls <function>initialize</function>, resulting in the
        invocation of the defined method. The end result is a
        <classname>StringBuffer</classname> instance containing the
        concatenation of the three arguments passed to
        <function>make</function>.
      </para>
    </sect2>
    <sect2>
      <title>Invoking Generic Procedures</title>
      <para>
        Generic procedures are invoked just like ordinary
        procedures. The invocation computes a list of applicable
        methods (i.e. methods whose type signature matches that of
        the argument types) sorted by specificity and invokes the
        first. An error is reported if there is no such method. The
        algorithm for determining the relative specificity of two
        methods <varname>A</varname> and <varname>B</varname> with
        respect to a particular set of arguments is the same as that
        employed by Dylan, Goo and others:
        <blockquote>
          <para>
            The method <varname>A</varname> is more specific than
            the method <varname>B</varname> if and only if
            <varname>A</varname> precedes <varname>B</varname> in at
            least one argument position, and <varname>B</varname>
            does not precede <varname>A</varname> in any argument
            position. Similarly, <varname>B</varname> is more
            specific than <varname>A</varname> if and only if
            <varname>B</varname> precedes <varname>A</varname> in at
            least one argument position, and <varname>A</varname>
            does not precede <varname>B</varname> in any argument
            position. If neither of these cases apply then
            <varname>A</varname> and <varname>B</varname> are
            ambiguous methods.
          </para>
          <para>
            In order to determine the precedence at a particular
            argument position, the types associated with that
            position in the method signatures of the two methods are
            compared. If the types are the same then the position
            provides no information about the order of the two
            methods. If one of the types is a subtype of the other
            then the former type's method precedes the
            other. Otherwise, the precedence is determined by the
            order of the types in the class precedence list of the
            type of the argument in the position in question.
          </para>
          <para>
            In a method with a rest parameter, the type associated
            with an argument position in the rest part is considered to
            be a supertype of all other types.
          </para>
        </blockquote>
        The algorithm is encapsulated by the following procedures:
        <blockquote>
          <para>
            <indexterm><primary>applicable-methods</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>list list</type>
              <methodname>applicable-methods</methodname>
              <methodparam><parameter>proc</parameter></methodparam>
              <methodparam><parameter>types</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns two values: the list of applicable methods
                of generic procedure <parameter>proc</parameter>
                when applied to arguments of types
                <parameter>types</parameter> (a list) ordered by
                specificity, and the corresponding list of ambiguous
                methods.
              </para>
            </blockquote>
          </para>
        </blockquote>
        <blockquote>
          <para>
            <indexterm><primary>method-applicable?</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>method-applicable?</methodname>
              <methodparam><parameter>method</parameter></methodparam>
              <methodparam><parameter>types</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Determines whether the types in
                <parameter>types</parameter> (a list) match the type
                signature of <parameter>method</parameter>, i.e. if
                it is possible to invoke
                <parameter>method</parameter> with arguments of the
                specified <parameter>types</parameter>.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        It is possible to call the "next best" matching method from
        within the body of a method. To do so, the first parameter
        declaration must have the form <literal>(next:
        </literal><parameter>next-method</parameter><literal>)</literal>,
        e.g.
        <programlisting>
(define-method (value-of (next: next-method)
                         ((meta &lt;jstring&gt;) s)
                         (&lt;java.lang.Character&gt; c))
  (display "\nin method\n")
  (next-method s c))
        </programlisting>
        <parameter>next-method</parameter> should only be called
        with arguments that would result in the same ordered
        sequence of applicable methods as the original arguments.
        The behavior of <parameter>next-method</parameter> when
        invoked with arguments that do not meet this criteria is
        undefined.
      </para>
      <para>
        If <parameter>next-method</parameter> is called when there
        are no more applicable methods left, the chainee of the
        generic procedure is invoked if present and an error is
        raised otherwise.
      </para>
    </sect2>
  </sect1>
  <sect1 id="SchemeClasses">
    <title>Scheme Classes</title>
    <para>
      A Scheme object is a collection of key/value pairs, where the
      keys are symbols and values can be any Scheme values. Every
      Scheme object is an instance of exactly one Scheme class.
      Scheme classes have zero or more superclasses. The combination
      of a Scheme class and its superclasses defines the set of keys
      for instances of the class and the initial values they contain.
    </para>
    <para>
      Scheme classes are themselves Scheme objects which are instances
      of the class <literal>&lt;class&gt;</literal>.
    </para>
    <sect2>
      <title>Defining Classes</title>
      <para>
        Scheme classes are defined with
        <blockquote>
          <para>
            <indexterm><primary>make-class</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>class</type>
              <methodname>make-class</methodname>
              <methodparam><parameter>superclasses</parameter></methodparam>
              <methodparam><parameter>slots</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns a new Scheme class, an instance of
                <literal>&lt;class&gt;</literal>.
                <parameter>superclasses</parameter> is the list of
                direct superclasses of the new class, and
                <parameter>slots</parameter> contains an alist of
                key/value pairs which are the direct slot names and
                their initial values.
              </para>
            </blockquote>
          </para>
        </blockquote>        
      </para>
      <para>
        A macro simplifies the common task of binding a variable to a
        newly created class:
        <blockquote>
          <para>
            <indexterm><primary>define-class</primary>
            </indexterm>
              &syntax;
            <methodsynopsis language="scheme">
              <void/>
              <methodname>define-class</methodname>
              <methodparam><parameter>name-and-super</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>slots</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <simplelist>
                <member>
                  where <parameter>name-and-super</parameter> is of
                  the form
                  <literal>(</literal><parameter>name</parameter>
                  <parameter>superclass</parameter>
                  <literal>...</literal><literal>)</literal>
                </member>
                <member>
                  and <parameter>slots</parameter> contains one or
                  more two-element lists of the form
                  <literal>(</literal><parameter>key</parameter>
                  <parameter>value</parameter><literal>)</literal>.
                </member>
              </simplelist>
              <para>
                Creates a new Scheme class and binds it to the
                variable <parameter>name</parameter>. The optional
                <parameter>superclass</parameter>es are the direct
                superclasses of the new class and the list of
                <parameter>key</parameter>s and
                <parameter>value</parameter>s define the direct slots
                and their initial values.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <para>
        The list of slots and their initial values of instances of a
        class is determined by collecting all slots and initial values
        from the class precedence list. Should a slot name appear more
        than once then the initial value is the one found earlier in
        the list.
      </para>
      <example>
        <title>Class Definition</title>
        <programlisting>
(define-class (&lt;foo&gt;) (x #f) (y 1))
(define-class (&lt;bar&gt;) (y 2)  (z #f))
(define-class (&lt;baz&gt; &lt;foo&gt; &lt;bar&gt;) (a 1) (b 2) (c #f))
(type&lt;= &lt;baz&gt; &lt;foo&gt;) ;=&gt; #t
(type&lt;= &lt;baz&gt; &lt;bar&gt;) ;=&gt; #t
(type&lt;= &lt;foo&gt; &lt;bar&gt;) ;=> #f
        </programlisting>
      </example>
    </sect2>
    <sect2>
      <title>Instantiating Classes</title>
      <para>
        The normal way to instantiate a class is to call
        <function>make</function>. Classes define a default
        constructor that takes care of creating a new instance of the
        class and initialising the slots to the values specified in
        the class definition. The default constructor takes any number
        of arguments, all of which are ignored.
      </para>
      <para>
        It is possible to override the default constructor by defining
        a constructor with <function>define-constructor</function>.
        This is rarely needed though since in most cases the
        post-creation object initialisation carried out by the
        <function>initialize</function> generic procedure suffices.
      </para>
      <example>
        <title>Class Instantiation</title>
        <programlisting>
(define-method (initialize (&lt;foo&gt; o) (&lt;top&gt; v))
  (o 'x v))
(define-method (initialize (&lt;bar&gt; o) (&lt;top&gt; v))
  (o 'z v))
(define-method (initialize (&lt;baz&gt; o) (&lt;top&gt; v))
  (o 'c v))

(define foo (make &lt;foo&gt; 1))
(define bar (make &lt;bar&gt; 2))
(define baz (make &lt;baz&gt; 3))
        </programlisting>
      </example>
      <para>
        Scheme objects can also be created directly using
        <blockquote>
          <para>
            <indexterm><primary>make-object</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>object</type>
              <methodname>make-object</methodname>
              <methodparam><parameter>class</parameter></methodparam>
              <methodparam><parameter>slots</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns a new Scheme object, which is an instance of
                <parameter>class</parameter> and has slots with
                initial values defined by the
                <parameter>slots</parameter> association list.
              </para>
              <para>
                No constructor and initialisation methods are
                invoked. The slots must comprise exactly the slots
                defined by <parameter>class</parameter> and its
                superclasses.
              </para>
            </blockquote>
          </para>
        </blockquote> 
      </para>
    </sect2>
    <sect2>
      <title>Slot Access</title>
      <para>
        The slots of a Scheme object can be accessed by invoking the
        object as a procedure.
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname></methodname>
              <methodparam><parameter>sobj</parameter></methodparam>
              <methodparam><parameter>fieldname</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of the Scheme object
                <parameter>sobj</parameter>'s slot
                <parameter>fieldname</parameter> (a symbol).
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <example>
        <title>Simple Slot Access</title>
        <programlisting>
(foo 'x) ;=&gt; 1
(bar 'y) ;=&gt; 2
(baz 'z) ;=&gt; #f
(map foo '(x y)) ;=&gt; (1 1)
(map bar '(y z)) ;=&gt; (2 2)
(map baz '(x y z a b c)) ;=&gt; (#f 1 #f 1 2 3)
        </programlisting>
      </example>
      <para>
        Often programs require access to object fields that are deeply
        nested inside some containment hierarchy or reference
        chain. This can be accomplished succinctly using the following
        operation:
        <blockquote>
          <para>
            &procedure;
            <methodsynopsis language="scheme">
              <type>value</type>
              <methodname></methodname>
              <methodparam><parameter>sobj</parameter></methodparam>
              <methodparam><parameter>slot-list</parameter></methodparam>
              <methodparam choice="opt">
                <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Gets or sets the value of nested Scheme object's slot.
                <parameter>sobj</parameter> is the Scheme object on
                which to start the
                lookup. <parameter>slot-list</parameter> is a list of
                slot, supplied as symbols, and must contain at least
                one element. If <parameter>slot-list</parameter>
                contains more than one element then a nested lookup is
                performed, i.e. the first slot name is looked up on
                the <parameter>sobj</parameter>, the second slot nanme
                is looked up on the resulting object, and so on until
                the final slot name in the list, which is retrieved
                from or set on the object resulting from the preceding
                lookup.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
      <example>
        <title>Nested Slot Access</title>
        <programlisting>
(baz '(c) bar)
(bar '(z) foo)
(baz '(c z x) 2) ;=&gt; 1
(baz '(c z x)) ;=&gt; 2
        </programlisting>
      </example>
    </sect2>
    <sect2>
      <title>Predicates</title>
      <para>
        Two predicates exist to determine whether a value is a Scheme
        class or Scheme object respectively.
        <blockquote>
          <para>
            <indexterm><primary>scheme-object?</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>scheme-object?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                Scheme object, &num;f otherwise.
              </para>
            </blockquote>
          </para>
          <para>
            <indexterm><primary>scheme-class?</primary>
            </indexterm>
              &procedure;
            <methodsynopsis language="scheme">
              <type>&num;t/&num;f</type>
              <methodname>scheme-class?</methodname>
              <methodparam><parameter>value</parameter></methodparam>
            </methodsynopsis>
            <blockquote>
              <para>
                Returns &num;t if <parameter>value</parameter> is a
                Scheme class, &num;f otherwise.
              </para>
            </blockquote>
          </para>
        </blockquote>
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Limitations</title>
    <para>
      <itemizedlist>
        <listitem>
          <para>
            The type of Scheme values other than objects is their
            &SISC; class. This makes it impossible to distinguish
            between Scheme values and their internal
            representation. &SISC; needs a more complex type system to
            fix this, which is quite hard but most of the code for
            that has already been written.
          </para>
        </listitem>
        <listitem>
          <para>
            Objects (Java and Scheme), including classes, are not a
            distinct type from procedures,
            i.e. <function>procedure?</function> will return &num;t
            for objects.
          </para>
        </listitem>
        <listitem>
          <para>
            Error reporting in generic procedure dispatch is not
            particularly good. Real-world usage will tell what errors
            crop up frequently and we can then put some mechanism in
            place for reporting them in a meaningful way.
          </para>
        </listitem>
        <listitem>
          <para>
            Generic procedures are lexically scoped, but their methods
            are not. Hence defining methods in a local scope is
            generally a bad idea. One exception are module
            definitions. It is perfectly safe for modules to define
            private (i.e. not exported) generic functions and add
            methods to them without interfering with other
            modules. However, care must be taken when generic
            functions are imported or exported - methods are added to
            generic function when the module gets
            <emphasis>defined</emphasis> rather then when it gets
            imported.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
sgml-parent-document:("sss.xml" "chapter")
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
