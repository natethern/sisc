How to modularize and package SISC Scheme code
==============================================

Modules
-------
The basic unit of modularization in SISC is a module. SISC uses the
module system that comes with Dybvig&Waddell's Portable Syntax Case
macro expander package. A typical module definition looks like this

(module foo
    (bar baz)
  (import boo1)
  (import boo2)
  (include "file.scm")
  (define (bar x) ...)
  (define-syntax baz ...)
  (define (something-else ...) ...)
  (do-some-stuff)
  (do-some-more-stuff))

A module definition consists of a name (foo), a list of exports (bar
and baz) and a body. The stuff that can appear in the body is the same
as what can appear inside the body of a lambda. The import form
imports the bindings from the named module (boo1 and boo2) into the
current lexical scope. The include form performs a textual inclusion
of the source code found in the named file (file.scm), i.e. it works
as if the code had appeared literally instead of the include.

All the identifiers appearing in the export list must be
define(-syntax)-ed in the body of the module or import-ed from another
module.

It is recommended to clearly separate modularization from the actual
code. The best way to accomplish is is to

* list all imports in the module body rather than included files

* include all files directly from the module body, avoiding nested
  includes

* place all definitions and expressions in included files, avoiding
  them in the module body


Modularizing existing code
--------------------------
Since module bodies are treated like bodies of lambdas, the R5RS rules
of how internal definitions are treated apply to all the
define(-syntax)es in a module body, including code include-ed from
files. This is often the source of errors when moving code from the
top-level into a module because

a) *all* definitions must appear *before* *all* expressions,

b) the list of definitions is translated into letrec/letrec-syntax,
which means  it must be possible to evaluate each right-hand side without
assigning or referring to the value of any of the variables being
defined.

This often necessitates re-arranging the code and introduction of set!
expressions. Here is an example of a sequences of top-level
definitions/expressions and how they need to be rewritten so they can
appear in a module body.

(define (foo) 1)
(define bar (foo))
(do-some-stuff)
(define (baz) (bar))
==>
(define (foo) 1)
(define bar)
(define (baz) (bar))
(set! bar (foo))
(do-some-stuff)

The general strategy is to go through the list of
expressions/definitions from top to bottom and build two lists - one
of definitions and one of expressions - as follows:

* If a non-definition is encountered append it to the expression list

* If a "naked" definition (i.e. a definition whose
right-hand-side is not a function) that refers to a binding defined
within the module is encountered append an empty definition to the
definition list and append a set! with the right-hand-side expression
to the expression list

* Else, i.e. for an ordinary definition, append it to the definition
list.

The concatenation of the resulting definition list with the expression
list makes a suitable module body.


Module Evaluation
-----------------
Modules are lexically scoped. It is possible to define modules inside
lambdas and inside other modules and to export modules from
modules. Example:

(define (f c)
  (module foo
      (bar)
    (module bar
        (baz)
      (define (baz x y) (- x y))
      (display "defining baz\n")))
  (if (> c 0)
      (let ((a 1))
         (import foo)
         (let loop ((b c))
            (import bar)
            (if (> b 0) (loop (baz b a)) (f (- c 1)))))))

The expressions in a module body get executed at the time and in the
context of module definition. So, in the above example, the body of
bar containing the display statement is executed once for every call
to f rather than once for every iteration of the inner loop containing
the import of the bar module.

There are quite a few more things you can do with modules. For
instance one can define anonymous modules, which are a short cut for
defining a named module and then importing it, import selected
bindings from a module and renaming them rather then importing all
bindings as is etc etc. For more details see the section on modules in
the Chez Scheme user manual.


Library Modules
---------------
Libraries provide a means of encapsulating code that can be
shared by many, independently developed applications.

Library modules are special modules. They are defined at the top level
and have a globally unique name (i.e. just like a Java package name).

Library modules can be *compiled* into a loadable library. This is
done using the create-library-from-module procedure. Loading the
resulting library makes the library module available to the loading
code.

Library modules should not depend on any top-level definitions outside
the standard SISC top-level, except the definition of other library
modules. Otherwise it is not possible to use the libraries portably.

Library modules should not contain any mutable state that is affecting
their behaviour. For instance, consider an OO library that assigns a
unique number to all classes defined when using it. If two library
modules used that OO library module, were compiled independently and
then loaded, the ids of classes defined in the first library module
would overlap with those defined in the second library module.

Libraries can be packaged with supporting code (e.g. ordinary Java
code and native modules) and other libraries into jar files. A typical
structure for such a jar file would be

com/foo/lib1.scm
com/foo/lib1/module.sll
com/foo/lib1/Class1.class
com/foo/lib1/Class2.class
com/foo/lib2.scm
com/foo/lib2/module.sll
com/foo/lib2/Class1.class
com/foo/lib2/Class2.class
com/foo/lib3.scm
com/foo/lib3/module.sll
com/foo/lib3/Class1.class
com/foo/lib3/Class2.class

The .scm files contain code to auto-load any libraries a library
module depends on and load the module.sll (compiled library
module). For example, lib1.scm could look like this:

(require-library "com/foo/lib2")
(require-library "com/foo/lib3")
(require-library "some/other/library")
(load "lib1/module.sll")

It is usually a good idea to name library modules after path names in
the jar i.e. com/foo/lib{1,2,3} in the above example.
