Scheme -> Java Interface
========================
(available by importing the s2j module)

Generic Functions
-----------------
(define-generic <name> [<fname>])
Create a new generic function and bind it to <name>. The name of the
generic function is <fname>, which defaults to <name>.

Generic functions implictly include all java methods (in all classes)
whose mangled name matches the generic function name. Name mangling is
done as follows:
1) a '-' is inserted between a lower-case character and an upper-case
character. Non-alphabetic characters are considered to be lower-case
characters. 
2) the whole name is downcased
==> "fooBarBaz" becomes "foo-bar-baz", "FooBar" becomes "foo-bar"
3) a '!' is appended if the original name started with "set" followed
by an upper-case character.


(define-method (<genf> [(next: <next-method>)]
                       (<type> <param>) ... [ . <rest>]) . <body>)

Adds a method the generic function <genf>. A method has a typed
parameter list and a body. When a generic function is invoked, the
method is called whose type signature best matches the types of the
given parameters. An error is reported if there is no such method.
<type> must be a java class object (see below).

The <next-method> parameter, if supplied in the definition of a
method, will be bound to the "next best" matching method. It can be
invoked with parameters or without parameters, in which case the
parameters of the orignal invocation are used.

The following precedence rules apply to method selection:
* Scheme methods with the same signature as java methods *always* take
precedence (i.e. are a better match) than the java methods.
* Defining a Scheme method with the same signature as an existing Scheme
method overwrites the existing method.
* Methods with n+1 mandatory parameters take precedence over methods
with n mandatory parameters.
* Methods without rest arg take precedence over methods with rest args.


(define-constructor (<type> (<type> <param>) ...) . <body>)

This form is basically the same as the define-method form except it
defines a "constructor" method for a specific type. All constructor
methods are part of the single generic constructor function MAKE.


Proxies
-------
(define-java-proxy (<name> <arg> ...)
                   [(<interface> ...) | <interface>]
  (method (<name> (<type> <param>) ...) . <body>) ...)

This defines a function bound to <name> with parameters <arg> ... that
when invoked creates a Java object that implements all the
<interface>s. The names and signatures of the methods must match the
java names (after mangling) and signatures of the methods declared by
the <interface>s. Note that <arg>s and the special SELF parameter will
be bound in the <body>s of the methods.


Java Objects
------------
(java-class [<string> | <symbol>]) => <class>
The string/symbol must be a fully-qualified name of a Java class or
interface, or a primitive type (e.g. "int") or an array types
(e.g. "int[][]").

Instances of a class can be created with the generic MAKE function.

(java-wrap <obj>) => <jobj>
(java-unwrap <jobj>) => <obj>
These first function wraps a Scheme so it can be passed in call to a
java method / constructor or when setting a field of a java object or
class. The second function "casts" a java object into a Scheme object
and is used when java methods return Scheme objects or java fields
containg Scheme objects are fetched.

Generally all java objects are self-evaluating. The result of the
evaluation depends on the type of object and the arguments:
(<jobj> '<fieldname> [<value>]) => <value>
  gets/sets field - works for both static and instance fields
(<array> <index> [<value>]) => <value>
  gets/sets array element. <index> can be either a number or a
  list/vector of numbers (for multi-dimensional arrays). 
(<class> '<fieldname> [<value>]) => <value>
  gets/sets static field
(<field> <jobj> [<value>]) => <value>
  gets/sets field - works for both static and instance fields
(<method> <jobj> <parameter> ...) => <value>
  invokes method on object with parameters
(<constructor> <parameter> ...) => <value>
  invokes constructor with parameters
(<class>) => <jobj>
  creates a new instance using the default argument-less constructor.

eq? is mapped to Java's == and equal? is mapped to Java's equals.

The objects representing Java classes, fields, methods and
constructors can be (de)serialized. Ordinary Java objects cannot be
(de)serialized.

(java-array-new <class> <dimensions>) => <array>
creates a java array. <dimensions> is a vector/list of numbers or a
number.

(java-synchronized <jobj> <thunk>)
Evaluates thunk inside a synchronized(<jobj>) { } block, return the
result of the evaluation. The result of capturing and invoking
continuations from within <thunk> that escape it is undefined.


Types of Java Objects
---------------------
(java-class-of <jobj>) => <class>
returns the class of the java object

(java-object? <obj>) => #t/#f
tests whether <obj> is a java object, including a class, interface,
array, null or ordinary object.

(java-class? <obj>) => #t/#f
tests whether <obj> is a java class.

(java-interface? <obj>) => #t/#f
tests whether <obj> is a java interface.

(java-array? <obj>) => #t/#f
tests whether <obj> is a java array.

(java-null? <obj>) => #t/#f
tests whether <obj> is the java null object.

(java-instance? <class> <jobj>) => #t/#f
tests whether <jobj> is an instance of <class>

(java-assignable? <class1> <class2>)
tests whether <class2> is assignable to <class1>


Type conversions
----------------
The S2J interface performs *no* automatic conversion between Scheme
types and Java types, e.g. one cannot simply call a Java method that
takes an int with a Scheme number. Automatic conversion is not done
for the following reasons:

- For some Scheme types, such as numbers, the mapping to Java types is
one-to-many, e.g. a Scheme number could be converted to a byte, short,
int, etc.

- Some Java types have several corresponding Scheme types, e.g. a Java
array could be represented as Scheme list or vector - this causes
ambiguities when automatic conversion of results is attempted

- Conversion carries an overhead that can be significant. For
instance, Java strings have to be copied "by value" to Scheme
strings. In a chained-call scenario, i.e. where the results of one J2S
called are passed as arguments to another, the conversion is
unnecessary.

- Conversion conflicts with generic functions.

Instead a general conversion function can be used to explicitly
convert from Scheme to Java types and visa versa. In fact this
function can in principle also be used to convert between Scheme types
and between Java types in a future version. The general conversion
function pattern is:
  ((-> <type-obj>) <arg> ... <obj>)

i.e. the -> function takes a type and returns a function that that
converts objects to a specific type. The <arg> ... list is normally
empty. Its purpose is to supply additional information needed for the
conversion.

The -> is an ordinary generic function, so it is actually possible to
define custom conversion functions.

For most of the conversion functions returned by (-> <type-obj>) there
are top-level bindings consisting of the type name prefixed with ->,
e.g.
  (->jint 2)

Note that doing this is a lot more efficient than using the generic ->
function. That is because the generic conversion is defined in terms
of the specialized conversions rather than the other way round

All Scheme types have a corresponding type objects, which are bound to
identifiers in the top-level environment, eg. <void>, <procedure>,
<boolean>, <number> etc.

Java types are represented by their corresponding Java classes. All
primitive types and some other common Java types (most of the ones in
java.lang) are bound to identifiers in the top-level environment with
a "j" prefix, e.g. <jint>, <jstring>.


Exceptions
----------
Java exceptions are propagated to scheme and can be caught with,
e.g. call/fc.


Fixes to the Java Type System
-----------------------------
Primitive types are mapped to their respective java.lang classes. This
means, amongst other things, that
* primitive types are indirect sub-classes of java.lang.Object
* primitive types are assignable to their respective java.lang classes
and visa versa.

Note however that no widening conversion takes place, because Java
does not define widening conversions for the java.lang classes
corresponding to the primitive types, e.g. a java.lang.Byte is not
assignable to a java.lang.Integer.


Under the Hood
--------------
The j2s-module is a native sisc module that basically defines scheme
functions corresponding to all methods on java.lang.Class plus the
various other reflection classes. This completeness is not strictly
necessary but greatly improves readability and performance. The only
methods of the reflection API that have not been mapped this way are:

Class.forName(String,boolean,ClassLoader)
Class.getClassLoader()
Class.getPackage()
Class.getProtectionDomain()
Class.getResource(String)
Class.getResourceAsStream(String)
Class.getSigners()


Issues
------

* Proxies implement the hashCode, equals? and toString methods
internally and hence these methods cannot be defined at the Scheme
level. FIX: this is hard to fix.

Shortcomings of generic functions:

* error reporting is not particularly good. FIX: real-world usage will
tell what errors crop up frequently and we can then put some mechanism
in place for reporting them in a meaningful way.

* only operate on java objects. FIX: need a more complex type
system. This is quite hard but I've got most of the code for that
already written.

* not garbage collected.

* not properly lexically scoped. Generic functions are lexically
scoped but their methods are not.

The last two items imply that defining generic functions or their
methods in a local scope is generally a bad idea. One exception are
module definitions. It is perfectly safe for modules to define private
(i.e. not exported) generic functions and add methods to them without
interfering with other modules. However, care must be taken when
generic functions are imported or exported - methods are added to
generic function when the module gets *defined* rather then when it
gets imported.
