<!doctype book public "-//OASIS//DTD DocBook V3.1//EN">

<book lang="en">
<!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
 <bookinfo>
  <title>
  SISC</emphasis> <emphasis>for Seasoned Schemers</emphasis>
 </title>
 <author>
  
 </author>
 <firstname>
  Scott
 </firstname>
 <surname>
  Miller
 </surname>
 <date>
  Jan 2002
 </date>
 </bookinfo>
 <chapter>
  <title>
  Introduction
 </title>
 <para>
  SISC</emphasis> is a lightweight, platform independent Scheme system whose primary goals are rapid execution of the complete R^{5}RS and future Scheme standards, plus a useful superset for real-world application development. 
 </para>
  <sect1>
   <title>
   Features
  </title>
  <itemizedlist>
   <listitem>
   <para>
   Full R^{5}RS compliance
   </para>
  </listitem>
   <listitem>
   <para>
   Efficient number tower, with support for integers, floating-point numbers, rationals, and complex numbers of arbitrary precision
   </para>
  </listitem>
   <listitem>
   <para>
   Lightweight Scheme engine, requiring less than 200 kilobytes of code.
   </para>
  </listitem>
   <listitem>
   <para>
   Runtime extensiblity through a scopable module system, which may add new functions and first-class types.
   </para>
  </listitem>
  </itemizedlist>
  </sect1>
  <sect1>
   <title>
   About this document
  </title>
  <para>
   This document explains the SISC Scheme system. It assumes knowledge of the Scheme language. As such, when discussing the Scheme language, we will focus primarily on differences between the Scheme standard and the language implemented by SISC. 
  </para>
  <para>
   Secondly, SISC implements the R5RS standard. As such, any code written to that standard should run without reading any further.
  </para>
  </sect1>
 </chapter>
 <chapter>
  <title>
  Installation and Invocation
 </title>
  <sect1>
   <title>
   Required Environment
  </title>
  </sect1>
  <sect1>
   <title>
   The Read-Eval-Print-Loop
  </title>
  </sect1>
 </chapter>
 <chapter>
  <title>
  Scheme Language
 </title>
  <sect1>
   <title>
   Types
  </title>
   <sect2>
    <title>
    Numbers
   </title>
   <para>
    The full Scheme number tower is supported:
   </para>
   <itemizedlist>
    <listitem>
    <para>
    Integers
    </para>
   </listitem>
    <listitem>
    <para>
    Floating Point numbers 
    </para>
   </listitem>
    <listitem>
    <para>
    Rational numbers
    </para>
   </listitem>
    <listitem>
    <para>
    Complex numbers
    </para>
   </listitem>
   </itemizedlist>
   <para>
    Depending on the numeric library compiled into SISC, floating point numbers have either 32 or 64 bit IEEE precision, or arbitrary precision. Regardless, SISC's complex numbers have floating point components of the same precision as the reals. Integers have arbitrary precision in all numeric libraries, and rational numbers are built with arbitrary precision components.
   </para>
    <sect3>
     <title>
     Numeric constants
    </title>
    <para>
     Precision specifiers (&num;e, &num;s, &num;f, &num;d, &num;l) are ignored in SISC, all inexact numbers are kept in the precision of the numeric library. In the case of arbitrary precision floats, specific precision constraints are maintained to prevent runaway expansion of precision. The parameterized functions min-precision and max-precision specify the constraints.
    </para>
    <para>
     All four base specifiers (&num;x, &num;o, &num;d, &num;b) are supported for integers and rationals. Only decimal (&num;d), the default, is supported for floating point and complex numbers.
    </para>
    </sect3>
    <sect3>
     <title>
     Exactness
    </title>
    <para>
     Exactness and inexactness contagion behaves as expected. Rational's are made inexact through division. Floats are made exact by conversion to a rational number. SISC attempts as accurate a conversion as possible, by converting the decimal portion of the number to a ratio with a denominator of the form 10^n, where n is the scale of the floating point number. Then the fraction is reduced as usual.
    </para>
    <para>
     Since complex numbers must have floating point components currently, conversion to an exact merely rounds the components to integers. 
    </para>
    </sect3>
   </sect2>
   <sect2>
    <title>
    Characters
   </title>
   <para>
    SISC's characters are based on the Java character type. As such, the full range of unicode characters are supported. Unicode characters can be created with number-&gt;character or &num;&bsol;nnnn, where nnnn is an octal number in the range 0000 -&gt; ffff. 
   </para>
   <para>
    Characters are compared with respect to the locale detected by the Java VM.
   </para>
   </sect2>
   <sect2>
    <title>
    Symbols
   </title>
   <para>
    SISC's symbols are case-insensitive. An uninterned symbol (one which is distinct from all other symbols including those with the same characters) can be created using string-&gt;uninterned-symbol.
   </para>
   </sect2>
   <sect2>
    <title>
    Strings
   </title>
   <para>
    Strings are built from unicode characters, and are compared according to the locale's rules.
   </para>
   </sect2>
   <sect2>
    <title>
    Lists
   </title>
   </sect2>
   <sect2>
    <title>
    Vectors
   </title>
   <para>
    SISC supports the length prefix method of creating Vector constants. For example:
   </para>
   <programlisting>
<![ CDATA [#5(x)
]]>   </programlisting>
   <para>
    creates a vector constant containing five identical symbols.
   </para>
   </sect2>
   <sect2>
    <title>
    Immutable types
   </title>
   <para>
    SISC follows the R5RS recommendation of immutable list, string, and vector constants. Quoted lists and vectors are immutable. Attempting to modify elements in these constants will raise an error. String constants are immutable as well when created with symbol-&gt;string.
   </para>
   </sect2>
  </sect1>
  <sect1>
   <title>
   Error handling
  </title>
  </sect1>
  <sect1>
   <title>
   Symbolic Environments
  </title>
  </sect1>
  <sect1>
   <title>
   Boxing
  </title>
  <para>
   SISC </emphasis>supports boxes, a container for a Scheme value. Boxing is often used to implement call-by-reference semantics. Boxes are created and accessed using the following three functions:
  </para>
  <programlisting>
<![ CDATA [<anchor id="box" ></anchor>procedure</emphasis>: (box value)
]]><![ CDATA [returns</emphasis>: a box containing the given value
]]><![ CDATA [ 
]]><![ CDATA [Creates a box filled with the given value.
]]><![ CDATA [ 
]]><![ CDATA [<anchor id="unbox" ></anchor>procedure: </emphasis>(unbox box)
]]><![ CDATA [returns: </emphasis>the value contained in the given box
]]><![ CDATA [ 
]]><![ CDATA [Returns the contents of a box.
]]><![ CDATA [ 
]]><![ CDATA [<anchor id="set-box!" ></anchor>procedure: </emphasis>(set-box! box value)
]]><![ CDATA [returns: </emphasis>undefined
]]><![ CDATA [ 
]]><![ CDATA [Replaces the value contained in the given box with a given value.
]]>  </programlisting>
  </sect1>
 </chapter>
 <chapter>
  <title>
  SISC </emphasis>Library Functions
 </title>
  <sect1>
   <title>
   Debugging
  </title>
  </sect1>
  <sect1>
   <title>
   Logical Operations
  </title>
  </sect1>
  <sect1>
   <title>
   Operating System interface
  </title>
  </sect1>
 </chapter>
 <chapter>
  <title>
  I/O
 </title>
  <sect1>
   <title>
   Port Input/Output
  </title>
  </sect1>
  <sect1>
   <title>
   File-system interface
  </title>
  </sect1>
  <sect1 id="NetIO">
   <title>
   Networking
  </title>
  </sect1>
 </chapter>
 <chapter>
  <title>
  Threads and Concurrency
 </title>
 </chapter>
 <chapter>
  <title>
  The Module System
 </title>
 <para>
  The Module system consists of two components. The first is the module syntax extension provided by R. Kent Dybvig's syntax expander &lsqb;REF&rsqb;. This level provides the ability to scope Scheme code into importable modules with selectable exports. 
 </para>
 <para>
  The second is the Java level <emphasis>SISC</emphasis> API for native extensions to the language. A <emphasis>SISC</emphasis> module defines new types and functions. Each <emphasis>SISC</emphasis> module can be queried from Scheme, and imported into the runtime environment as a whole, or packaged via the same export mechanism as native Scheme code.
 </para>
 </chapter>
 <chapter id="Java Interaction">
  <title>
  Java Interaction
 </title>
 <para>
  SISC</emphasis> can be used as a scripting language for Java, or Java may be used to provide functionality to Scheme. Such activity is collectively termed 'bridging'. <emphasis>SISC </emphasis>provides an API that may be called from Java to execute Scheme code or evaluate Scheme expressions. In addition, the J2S module provides Scheme level control of Java objects, methods, and fields. Finally, the two can be combined in a number of complex ways to intertwine the two languages.
 </para>
  <sect1>
   <title>
   Java to Scheme call API
  </title>
   <sect2>
    <title>
    Error Handling
   </title>
   </sect2>
   <sect2>
    <title>
    Continuations
   </title>
   </sect2>
  </sect1>
  <sect1>
   <title>
   Scheme level Java manipulation
  </title>
  </sect1>
 </chapter>


</book>
