<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                    "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd" [
 <!ENTITY SISC "<emphasis>SISC</emphasis>">
 <!ENTITY R5RS "R<superscript>5</superscript>RS">
 <!ENTITY syntax "<emphasis role='bold'><emphasis>syntax:</emphasis></emphasis>">
 <!ENTITY returns "<emphasis role='bold'><emphasis>returns:</emphasis></emphasis>">
 <!ENTITY procedure "<emphasis role='bold'><emphasis>procedure:</emphasis></emphasis>">
 <!ENTITY parameter "<emphasis role='bold'><emphasis>parameter:</emphasis></emphasis>">
 <!ENTITY f "&num;f">
]>

<book lang="en">
  <!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
  <bookinfo>
    <title>
      &SISC; <emphasis>for Seasoned Schemers</emphasis>
    </title>
    <author>
      <firstname>Scott</firstname><surname>Miller</surname>
    </author>
    <date>
      Jan 2002
    </date>
  </bookinfo>
  <chapter>
    <title>
      Introduction
    </title>
    <para>
      &SISC; is a lightweight, platform independent
      Scheme system whose primary goals are rapid execution of the
      complete &R5RS; and future Scheme
      standards, plus a useful superset for real-world application
      development. 
    </para>
    <para>
      &SISC;'s development progresses in two
      directions, to improve the core interpreter to be simpler,
      more elegant, and more efficient; and to add necessary
      functionality through extensions that do not complicate the
      core.
    </para>
    <sect1>
      <title>
	Features
      </title>
      <itemizedlist>
	<listitem>
	  <para>
	    Full &R5RS; compliance
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Efficient number tower, with support for integers, floating-point numbers, rationals, and complex numbers of arbitrary precision
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Lightweight Scheme engine, requiring less than 200 kilobytes of code.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Runtime extensiblity through a scopable module system, which may add new functions and first-class types.
	  </para>
	</listitem>
      </itemizedlist>
    </sect1>
    <sect1>
      <title>
	About this document
      </title>
      <para>
	This document explains the &SISC; Scheme system. It assumes
	knowledge of the Scheme language. As such, when discussing the
	Scheme language, we will focus primarily on differences
	between the Scheme standard and the language implemented by
	&SISC;.
      </para>
      <para>
	Secondly, &SISC; implements the &R5RS; standard. As such, any
	code written to that standard should run without reading any
	further.
      </para>
      <sect2>
	<title>
	  About procedure documentation
	</title>
	<para>
	  Throughout this document, procedures will be defined using
	  the following syntax:
	</para>
	<programlisting>
	  &procedure; (procedure-name argument [optional argument] ...)
	  &returns; type and description of the return value
	</programlisting>
	<blockquote>
	  <para>
	    Description of the procedure's semantics.
	  </para>
	</blockquote>
	<programlisting>
	  &parameter; (parameter-name [new-value])
	  Description of the parameter and its effects.
	   
	   
	  &syntax; (syntactic-keyword structure ...)
	  Description of the syntax expressions semantics
	</programlisting>
	<para>
	  A procedure is a function that takes a number of arguments
	  and produces a result, which may be undefined. The arguments
	  of a procedure are always evaluated before the procedure is
	  invoked.</para> 
	<para>
	  A parameter is a value that effects the operation of part of
	  the Scheme system. When a parameter is invoked with no
	  arguments, the current value of the parameter is
	  returned. With arguments, the value of the parameter is
	  changed to the arguments given. 
	</para>
	<para>
	  Finally, syntax is any construct whose arguments are not
	  necessarily other s-expressions. Arguments to a syntactic
	  expression are not necessarily evaluated. Syntactic
	  expressions are expanded at compile time to expressions that
	  have the correct semantics but contain no additional
	  syntactic expressions, and are often much more difficult to
	  read then the unexpanded version.
	</para>
	<para>
	  Procedures, parameters, and syntax may take one or more
	  arguments.  The name of an argument in a description
	  indicates the expected type of the argument.  'value'
	  indicates any type.  If the argument is enclosed in square
	  brackets ([]), that parameter is optional, and may be
	  ommited.  If the description ends in elipses (...), then 
	  additional arguments may be provided, but are not required.
	</para>
      </sect2>
    </sect1>
  </chapter>
  <chapter>
    <title>
      Installation and Invocation
    </title>
    <sect1>
      <title>
	Required Environment
      </title>
      <para>
	&SISC; primarily targets the Java Virtual
	Machine, and the Java v1.2 and higher class libraries.  The
	1.2 libraries and VM are required due to a reliance on memory
	reference functionality used to properly garbage collect
	unused symbols while still maining pointer equality between
	those that remain active.
      </para>
      <para>
	&SISC; does not require any particular operating system, though
	the official distribution currently provides launching
	assistance for Windows and Unix based systems.  Theoretically
	any machine that supports Java 1.2 or higher should be able to
	run &SISC;.
      </para>
    </sect1>
    <sect1>
      <title>
	The Read-Eval-Print-Loop
      </title>
      <para>
	As in most Scheme systems, &SISC;'s primary
	human interface is a REPL, or Read-Eval-Print-Loop.  &SISC;
	presents the user with a prompt ('>'), then reads an
	s-expression from the console.  &SISC; then evaluates the
	s-expression, producing a value or error, which it then
	prints.  Finally a prompt is displayed and the process begins
	again.
      </para>
      <para>
	The process terminates with a forced kill of the JVM (with
	Control-C or similar), or when an end of file is detected on
	the console.
      </para>
    </sect1>
    <sect1>
      <title> 
	Display Conventions
      </title>
      <para>
	Executing or loading code in the REPL ordinarily producs a value
	result which is displayed during the Print phase.  However,
	two other message types may be displayed.  First, if an error
	is raised that is not handled by the running program, the
	message will be described in one of three forms:
      </para>
      <programlisting>
	Error: &lt;description&gt;

	Error in &lt;error-location&gt;: &lt;description&gt;

	Error.
      </programlisting>
      <para>
	The first form describes an error that was raised in an
	anonymous procedure or syntax.  The second describes an error
	that was raised in a named procedure or syntax definition.
	The error-location indicates which procedure encountered
	the error.  The final form is produced by an explicit call
	to the error function with no arguments.
      </para>
      <para>
	In addition to errors, it is possible for code to produce
	warnings during compilation or run-time.  A warning is a
	message to the user about a condition that is unusual but not
	terminal to the program flow.  The compiler, for example, does
	a minimal amount of sanity checking on code and may produce
	warnings about code that has the potential to raise errors
	during execution.  Warnings are always distinguished from
	ordinary messages by surrounding braces ({}). 
      </para>
      <programlisting>
	{warning: &lt;description&gt;}
      </programlisting>
    </sect1>
  </chapter>
  <chapter>
    <title>
      Scheme Language
    </title>
    <para>
      In this chapter we will examine the language that &SISC;
      interprets, which is a superset of the
      &R5RS; Scheme Standard.
    </para>
    <sect1>
      <title>
	Types
      </title>
      <sect2>
	<title>
	  Numbers
	</title>
	<para>
	  The full Scheme number tower is supported:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Integers
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Floating Point numbers 
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Rational numbers
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Complex numbers
	    </para>
	  </listitem>
	</itemizedlist>
	<para>
	  Depending on the numeric library compiled into &SISC;,
	  floating point numbers have either 32 or 64 bit IEEE
	  precision, or arbitrary precision. Regardless, &SISC;'s
	  complex numbers have floating point components of the same
	  precision as the reals. Integers have arbitrary precision in
	  all numeric libraries, and rational numbers are built with
	  arbitrary precision components.
	</para>
	<sect3>
	  <title>
	    Numeric constants
	  </title>
	  <para>
	    The precision specifying exponents (<computeroutput>S, F,
	    L, </computeroutput>and
	    <computeroutput>D</computeroutput>) 
	    are ignored in &SISC;, all inexact numbers are kept
	    in the precision of the numeric library.  The exponents
	    are read and used to scale the real number as expected.
	    In the case of
	    arbitrary precision floats, specific precision constraints
	    are maintained to prevent a runaway increase of
	    precision. The parameterized functions
	    <emphasis>min-precision</emphasis> and
	    <emphasis>max-precision</emphasis> specify the
	    constraints:
	  </para>
	  <programlisting>
	    &parameter; (min-precision [digits])
	    Sets or displays the minimum precision constraint, an
	    integer.

	    &parameter; (max-precision [digits])
	    Sets or displays the maximum precision constraint, an integer.
	  </programlisting>
	  <para>
	    All four base specifiers (<computeroutput>&num;x, &num;o,
	    &num;d, &num;b</computeroutput>) are supported for
	    integers and rationals. Only decimal 
	    (<computeroutput>&num;d</computeroutput>), the
	    default, is supported for floating point and complex
	    numbers.
	  </para>
	</sect3>
	<sect3>
	  <title>
	    Exactness
	  </title>
	  <para>
	    Exactness and inexactness contagion behaves as
	    expected. Rational's are made inexact through
	    division. Floats are made exact by conversion to a
	    rational number. &SISC; attempts as accurate a conversion as
	    possible, by converting the decimal portion of the number
	    to a ratio with a denominator of the form 10^n, where n is
	    the scale of the floating point number. Then the fraction
	    is reduced as usual.
	  </para>
	  <para>
	    Since complex numbers must have floating point components
	    currently, conversion to an exact merely rounds the
	    components to integers. 
	  </para>
	</sect3>
      </sect2>
      <sect2>
	<title>
	  Characters
	</title>
	<para>
	  &SISC;'s characters are based on the Java character type. As
	  such, the full range of unicode characters are
	  supported. Unicode characters can be created with
	  <computeroutput>number-&gt;character</computeroutput> or 
	  <computeroutput>&num;&bsol;nnnn</computeroutput>, where <computeroutput>nnnn</computeroutput> is an
	  octal number in the range 0000 -&gt; ffff. 
	</para>
	<para>
	  Characters are compared with respect to the locale detected
	  by the Java VM.
	</para>
      </sect2>
      <sect2>
	<title>
	  Symbols
	</title>
	<para>
	  &SISC;'s symbols are ordinarily case-insensitive. &SISC;
	  maintains pointer equality between symbols with like
	  contents, unless the symbol is created
	  <emphasis>uninterned</emphasis>. An uninterned symbol is one
	  which is guaranteed to be pointer distinct from any other
	  symbol in the Scheme system, even another with the same
	  contents. Uninterned symbols can be generated with:
	</para>
	<programlisting>
	  &procedure; (string-&gt;uninterned-symbol string)
	  &returns; an uninterned, pointer distinct symbol
	  
	</programlisting>
	<para>
	  &SISC; also allows symbols to be created that
	  <emphasis>are</emphasis> case-sensitive. This can be done
	  one of two ways. The first involves setting the reader to
	  produce cased symbols via the procedure
	</para>
	<programlisting>
	  &parameter; (case-sensitive [boolean])
	  Sets or retrieves the reader's case sensitivity.
	</programlisting>
	<para>
	  The second method is via a non-standard symbol syntax. If a
	  symbol is enclosed in pipe ('|') characters, the reader will
	  treat that individual symbol as cased. For example:
	</para>
	<programlisting>
	  (eq? 'a '|A|) ; => #f
	  (eq? 'a '|a|) ; => #t
	  (eq? '|A| '|a|) ; => #f
	</programlisting>
      </sect2>
      <sect2>
	<title>
	  Strings
	</title>
	<para>
	  Strings are built from unicode characters, and are compared
	  according to the locale's rules.
	</para>
      </sect2>
      <sect2>
	<title>
	  Lists
	</title>
	<para></para>
      </sect2>
      <sect2>
	<title>
	  Vectors
	</title>
	<para>
	  &SISC; supports the length prefix method of creating Vector
	  constants. For example:

	  <programlisting>
	    #5(x)
	  </programlisting>
	  creates a vector constant containing five identical
	  symbols.  In addition, the length-prefix form is used when
	  printing vectors, and if elements repeat at the end of a
	  Vector, only the last unique element is printed.
	</para>
      </sect2>
      <sect2>
	<title>
	  Circular structures
	</title>
	<para>
	  &SISC; provides a parse-time syntax for 
	  creating data (primarily vectors and lists) that contain
	  references to themselves.  This can be useful to create streams,
	  graphs, and other self-referencing structures while
	  maintaining readability and avoiding complex construction
	  code.
	</para>
	<para> 
	  The reader syntax has two parts, defining a pointer, and
	  later referencing the pointer to create the circular
	  reference.
	</para>
	<para>
	  Below is an addition to the &R5RS;
	  formal syntax (specifically section 7.1.2, external
	  representations) to support circular structures:
	</para>
	<programlisting>
	  &lt;pointer definition&gt; --> #&lt;uinteger 10&gt;=&lt;datum&gt;
	  &lt;pointer reference&gt; --> #&lt;uinteger 10&gt;#
	</programlisting>
	<para>
	  The first form instructs the reader to create a pointer
	  identified by the specified integer, which maps to the datum
	  that follows, and is active during the reading of the datum
	  on the right-hand side of the definition.  
	</para>
	<para>
	  If a second definition occurs during the reading of the
	  datum with the same integral identifier, the previous
	  definition is overwritten for the duration of the read.  The
	  definitions are <emphasis>not</emphasis> scoped in any way.
	  The pointer identifiers should be kept unique by the
	  programmer to prevent any unintended effects of identifier
	  collisions. 
	</para>
	<para>
	  The second form references a previously created pointer 
	  definition.  It is an error to reference an undefined
	  pointer.  The reader will handle a valid reference by
	  placing a pointer at the current read position back to the
	  location of the definition. 
	</para>
	<para>
	  At this point some examples might be helpful:
	</para>
	<programlisting>
	  (define x '#0=(1 2 . #0#))
	  (caddr x)        ; => 1
	  (list-ref x 15)  ; => 2

	  (define y '(1 2 #1=#(3 4) . #1#))
	  (eq? (caddr y) (cdddr y)) ; => #t
	</programlisting>
      </sect2>
      <sect2>
	<title>
	  Immutable types
	</title>
	<para>
	  &SISC; follows the &R5RS;
	  recommendation of immutable list, string, and vector
	  constants. Quoted lists and vectors are
	  immutable. Attempting to modify elements in these constants
	  will raise an error. String constants are immutable as well
	  when created with <computeroutput>symbol-&gt;string</computeroutput>.
	</para>
      </sect2>
    </sect1>
    <sect1>
      <title>
	Error handling
      </title>
      <para>
	Errors or exceptions are unusual program conditions that cause
	the immediate termination of the program.  
      </para>
    </sect1>
    <sect1>
      <title>
	Symbolic Environments
      </title>
      <para>
      </para>
    </sect1>
    <sect1>
      <title>
	Boxing
      </title>
      <para>
	&SISC; supports boxes, a container for a
	Scheme value. Boxing is often used to implement
	call-by-reference semantics. Boxes are created and accessed
	using the following three functions:
      </para>
      <programlisting>
	&procedure; (box value)
	&returns; a box containing the given value
	 
	Creates a box filled with the given value.

	&procedure; (unbox box)
	&returns; the value contained in the given box
	 
	Returns the contents of a box.

	&procedure; (set-box! box value)
	&returns; undefined
	 
	Replaces the value contained in the given box with a given
	value.
      </programlisting>
    </sect1>
  </chapter>
  <chapter>
    <title>
      &SISC; Library Functions
    </title>
    <sect1>
      <title>
	Debugging
      </title>
      <para>
	&SISC; provides debugging aids that can be added to Scheme source code, as well as limited support for debugging without modification. 
      </para>
      <programlisting>
	&syntax; (trace-lambda trace-name formals body)

	When replaced with a trace-lambda, all calls to a lambda defined 
	procedure are traced on the console.  <emphasis>trace-name</emphasis> 
	is a symbol to identify the procedure in the trace. 
	<emphasis>formals </emphasis>and <emphasis>body</emphasis> have
	identical semantics to lambda.
	 
	&syntax; (trace-let loop-name formal-bindings body)
	Replaces a named-let expression in a similar manner to trace-lambda.  
	 
	&procedure; (trace-top-level-procedures symbol ...)
	&returns; undefined
	 
	Begins traces on the procedures named by the symbols given.  The procedures must be defined in the top-level environment.
	 
	&procedure; (untrace-top-level-procedures symbol ...)
	&returns; undefined
	 
	Stops tracing the top-level procedures named by the symbols given.
      </programlisting>
      <para>
	Trace-lambda and trace-let are useful for debugging anonymous
	lambdas and named-lets
	respectively. Trace-top-level-procedures can be used to trace
	calls to any procedure, including native procedures and stored
	continuations.
      </para>
    </sect1>
    <sect1>
      <title>
	Logical Operations
      </title>
      <para></para>
    </sect1>
    <sect1>
      <title>
	Operating System interface
      </title>
      <para></para>
    </sect1>
  </chapter>
  <chapter>
    <title>
      I/O
    </title>
    <para>
      &SISC;'s I/O routines are implemented in a flexible manner, allowing 
      extensions to create new I/O sources that will behave as
      standard Scheme port objects.  The ports can then be operated on
      with all &R5RS; port operations, as well as some &SISC; specific 
      port functions.
    </para>
    <sect1>
      <title>
	Port creation
      </title>
      <para>&SISC; extends the &R5RS; standard's port-creation
	functions in order to provide buffered output ports.  All &SISC; 
	output ports are buffered, and a programmer may choose whether
	a given port should automatically flush after each write
	operation.  By default ports do <emphasis>not</emphasis>
	automatically flush.  Enabling auto-flush can be done when the
	port is created per the specifications below.  A port that
	does not automatically flush can be flushed at any time by
	calling <computeroutput>flush-output-port</computeroutput>.
	Finally, an output-port that does not automatically flush will
	be flushed when the port is closed with
	<computeroutput>close-output-port</computeroutput>, but may
	not be flushed if the Scheme system is exited without closing
	the port.
      </para>
      <programlisting>
	&procedure; (open-output-file file [auto-flush])
	&returns; An output port

	Creates an output port to the specified file (a string).  If
	the optional auto-flush argument is provided and is true, the
	port will automatically flush after each write call.  If the
	specified file exists, it will be overwritten silently when
	the port is opened.


	&procedure; (flush-output-port output-port)
	&returns; unspecified

	Causes the specified output-port's buffered data to be written
	immediately.  This operation is allowed on both auto-flush and
	non-auto-flush output ports, though it has no effect on the
	former.
      </programlisting>
    </sect1>
    <sect1>
      <title>
	Block I/O
      </title>
      <para>
	In addition to the standard operations on ports
	(<computeroutput>read, read-char, char-available?,
	display,</computeroutput> and
	<computeroutput>write</computeroutput>), &SISC; provides block
	input/output functions, that allow a Scheme program to read
	blocks of more than one byte/character of data at a time.
	&SISC; stores data that is read or is to be written as String
	objects.  Binary data in strings is fully supported throughout
	the Scheme system.  Such strings may be read and written as
	usual, though undisplayable characters will often be escaped.
      </para>
      <programlisting> 
	&procedure; (block-read buffer input-port integer)
	&returns; the number of bytes read, an integer

	Reads up to <emphasis>integer</emphasis> bytes of data from the
        provided <emphasis>input-port</emphasis> into
        <emphasis>buffer</emphasis>.  Note that less than
        <emphasis>integer</emphasis> bytes may be read. 

	&procedure; (block-write buffer input-port integer)
	&returns; unspecified
 
        Writes up to <emphasis>integer</emphasis> bytes of data stored
	in <emphasis>buffer</emphasis> to the specified 
	<emphasis>output-port</emphasis>.
      </programlisting>
    </sect1>
    <sect1>
      <title>
	File-system interface
      </title>
      <para></para>
    </sect1>
    <sect1 id="netio">
      <title>
	Networking
      </title>
      <para>
	The &SISC; Networking library provides a mechanism for
	creating and manipulating IP network protocols as standard
	Scheme ports.  &SISC; supports TCP, UDP, and Multicast UDP.
	Each is described in the sections that follow.
      </para>
      <para>
	Each protocol provides one or more <emphasis>socket
	constructors</emphasis>.  These functions produce a Socket
	handle, which is represented in &SISC; as
	<computeroutput>&num;&lt;socket&gt;</computeroutput>.  A
	socket handle is then used to obtain Scheme ports.
      </para>
      <para>
	IP addresses are represented as strings in &SISC;.  Unless
	otherwise noted, the network library functions that require an
	address may take an address as a string in the dotted quad
	form ("aaa.bbb.ccc.ddd"), or as a hostname which will be
	resolved using the domain name system.  All port values must
	be integers in the proper range.
      </para>
      <sect2 id="netutils">
	<title>
	  Address functions
	</title>
	<para>
	  Several utility functions are provided for manipulating IP
	  addresses.  These are described below.
	</para>
	<programlisting>
	  &procedure; (get-host-ip-by-name string)
	  &returns; A dotted-quad IP address or &f;

	  Attempts to resolve a hostname provided as a string into an 
	  IP address in dotted-quad form.  If the host cannot be
	  found, &f; is returned.

	  
	  &procedure; (get-host-name-by-ip string)
	  &returns; A hostname or &f;

	  Attempts a reverse lookup of the given dotted-quad address
	  to determine a registered domain name.  If unsuccessful, &f;
	  is returned

	  
	  &procedure; (get-local-host)
	  &returns; The dotted-quad address of the local host 

	  Attempts to determine the Internet visible IP address of the
	  local machine.  If successful, this address is returned in
	  dotted-quad notation.  &f; is returned otherwise.
	</programlisting>
      </sect2>
      <sect2 id="sockets">
	<title>
	  Socket operations
	</title>
	<para>
	  Once obtained using a protocol specific constructor, a
	  Socket Handle allows manipulation of common socket options,
	  the creation of Scheme input/output ports, and closing of
	  the socket.
	</para>
	<programlisting>
	  &procedure; (open-socket-input-port socket)
	  &returns; an input port

	  Opens a Scheme input port to the socket.  


	  &procedure; (open-socket-output-port socket [boolean])
	  &returns; an output port

	  Opens a Scheme output port to the socket.  If provided, the
	  boolean argument specifies whether the given port should be
	  set to auto-flush mode.  If unspecified, the port does
	  <emphasis>not</emphasis> auto-flush.
	  

	  &procedure; (close-socket socket)
	  &returns; unspecified

	  Closes an IP socket.  
	</programlisting>
	<para>
	  The port-obtaining functions above work on most sockets.
	  An exception applies for  TCP server sockets, which are used only to
	  obtain connected TCP sockets.
	</para>
      </sect2>
      <sect2 id="TCP">
	<title>
	  TCP
	</title>
	<para>
	  The most commonly used Internet protocol maps most favorably
	  to Scheme's input/output model.  Writing to an output port
	  retrieved from a TCP socket writes the data to that socket.
	  Reading from an input port reads from the connected socket.
	  One imporant note is that one can control the amount of data
	  that fills a TCP packet by using an output port that does
	  not auto-flush.  Data is written to the port until one
	  considers the packet complete, and then uses
	  <computeroutput>(flush-output-port port)</computeroutput> to
	  complete the packet.  Note also that this does not
	  <emphasis>guarantee</emphasis> that one gets the desired
	  packet size, but does allow one to construct reasonably
	  sized packets.
	</para>
	<para>
	  TCP sockets are obtained one of two ways.  Either one
	  creates an outgoing connection to another listening host and
	  then subsequently obtains a socket handle, or one creates a
	  <emphasis>listening socket</emphasis> and then obtains a
	  socket by waiting for an incoming connection on the
	  specified port.  In either case, the result is a socket
	  handle with an available input and output port that can be
	  obtained using a function in the previous section.
	</para>
	<programlisting>
	  &procedure; (open-tcp-socket string integer)
	  &returns; A connected TCP socket

	  Attempts to connect to the host at the given hostname or IP
	  address encoded in the string, at the given TCP port
	  specified by the integer.  An error is raised if the host
	  cannot be found or the connection fails.

	  
	  &procedure; (open-tcp-listener integer [string])
	  &returns; A TCP server socket

	  Creates a TCP server socket, which may only be used with
	  accept-tcp-socket, or closed.  The server socket will listen
	  on the integer port specified.  If provided, the string
	  specifies the address of a local interface to bind to.  If
	  not provided, the port is bound on all available
	  interfaces.  An error is raised if the socket cannot be
	  bound and set listening.

	  
	  &procedure; (accept-tcp-socket server-socket)
	  &returns; A TCP socket

	  Accepts an incoming connection on the provided
	  server-socket, and returns a TCP socket handle.  This
	  function will block until an incoming connection is made,
	  or, if set, the socket timeout is exceeded.  If the latter
	  happens, an error will be raised.

	  
	  &procedure; (set-so-timeout! socket integer)
	  &returns; undefined

	  Sets the socket timeout on a socket.  The socket can be
	  either a server socket or connected socket.  In the former
	  case, this value specifies the number of milliseconds that
	  an accept-tcp-socket can wait before timing out.  In the
	  latter, the value specifies the number of milliseconds that
	  can elapse during a read call before timing out.
	</programlisting>
      </sect2>
    </sect1>
  </chapter>
  <chapter>
    <title>
      Threads and Concurrency
    </title>
    <para></para>
  </chapter>
  <chapter>
    <title>
      The Module System
    </title>
    <para>
      The Module system consists of two components. The first is the
      module syntax extension provided by R. Kent Dybvig's syntax
      expander &lsqb;REF&rsqb;. This level provides the ability to
      scope Scheme code into importable modules with selectable
      exports. 
    </para>
    <para>
      The second is the Java level &SISC; API for
      native extensions to the language. A &SISC;
      module defines new types and functions. Each
      &SISC; module can be queried from Scheme, and
      imported into the runtime environment as a whole, or packaged
      via the same export mechanism as native Scheme code.
    </para>
  </chapter>
  <chapter id="javainteraction">
    <title>
      Java Interaction
    </title>
    <para>
      &SISC; can be used as a scripting language
      for Java, or Java may be used to provide functionality to
      Scheme. Such activity is collectively termed
      'bridging'. &SISC; provides an API that may
      be called from Java to execute Scheme code or evaluate Scheme
      expressions. In addition, the J2S module provides Scheme level
      control of Java objects, methods, and fields. Finally, the two
      can be combined in a number of complex ways to intertwine the
      two languages.
    </para>
    <sect1>
      <title>
	Java to Scheme call API
      </title>
      <para></para>
      <sect2>
	<title>
	  Error Handling
	</title>
	<para></para>
      </sect2>
      <sect2>
	<title>
	  Continuations
	</title>
	<para></para>
      </sect2>
    </sect1>
    <sect1>
      <title>
	Scheme level Java manipulation
      </title>
      <para></para>
    </sect1>
  </chapter>
</book>
