<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                    "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd" [
 <!ENTITY SISC "<emphasis>SISC</emphasis>">
 <!ENTITY R5RS "R<superscript>5</superscript>RS">
 <!ENTITY syntax "<emphasis role='bold'><emphasis>syntax:</emphasis></emphasis>">
 <!ENTITY returns "<emphasis role='bold'><emphasis>returns:</emphasis></emphasis>">
 <!ENTITY procedure "<emphasis role='bold'><emphasis>procedure:</emphasis></emphasis>">
 <!ENTITY parameter "<emphasis role='bold'><emphasis>parameter:</emphasis></emphasis>">
 <!ENTITY f "&num;f">
 <!ENTITY gfdl SYSTEM "fdl.sgml">
]>

<book lang="en">
  <!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
  <bookinfo>
    <title>
      &SISC; <emphasis>for Seasoned Schemers</emphasis>
    </title>
    <authorgroup>
      <author>
	<firstname>Scott</firstname>
	<othername>G.</othername>
	<surname>Miller</surname>
      </author>
      <author>
	<firstname>Matthias</firstname>
	<surname>Radestock</surname>
	<contrib>
	  Generic functions and Scheme/Java bridge documentation
	</contrib>
      </author>
    </authorgroup>
    <date>
      February 2002
    </date>
    <copyright>
      <year>2002</year>
      <holder>Scott G. Miller</holder>
    </copyright>
    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation License,
	Version 1.1 or any later version published by the Free Software
	Foundation; with no Invariant Sections, with no Front-Cover
	Texts, and with no Back-Cover Texts.  A copy of the license is
	included in the section entitled "GNU Free Documentation License".
	(<xref linkend="gfdl"/>)
      </para>
    </legalnotice>
      
  </bookinfo>
  <chapter>
    <title>
      Introduction
    </title>
    <para>
      &SISC; is a lightweight, platform independent
      Scheme system whose primary goals are rapid execution of the
      complete &R5RS; and future Scheme
      standards, plus a useful superset for real-world application
      development. 
    </para>
    <para>
      &SISC;'s development progresses in two
      directions, to improve the core interpreter to be simpler,
      more elegant, and more efficient; and to add necessary
      functionality through extensions that do not complicate the
      core.
    </para>
    <sect1 id="Features">
      <title>
	Features
      </title>
      <itemizedlist>
	<listitem>
	  <para>
	    Full &R5RS; compliance
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Efficient number tower, with support for integers, floating-point numbers, rationals, and complex numbers of arbitrary precision
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Lightweight Scheme engine, requiring less than 200 kilobytes of code.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Runtime extensiblity through a scopable module system, which may add new functions and first-class types.
	  </para>
	</listitem>
      </itemizedlist>
    </sect1>
    <sect1 id="About">
      <title>
	About this document
      </title>
      <para>
	This document explains the &SISC; Scheme system. It assumes
	knowledge of the Scheme language. As such, when discussing the
	Scheme language, we will focus primarily on differences
	between the Scheme standard and the language implemented by
	&SISC;.
      </para>
      <para>
	Secondly, &SISC; implements the &R5RS; standard. As such, any
	code written to that standard should run without reading any
	further.
      </para>
      <sect2 id="AboutProcedures">
	<title>
	  About procedure documentation
	</title>
	<para>
	  Throughout this document, procedures will be defined using
	  the following syntax:
	</para>
	  <para>
	    
	  <funcsynopsis>
	    <funcprototype>
	      <funcdef><function>max</function></funcdef>
	      <paramdef><parameter>string</parameter></paramdef>
	      <paramdef><parameter>string</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	</para>
	<blockquote>
	  <para>
	    Description of the procedure's semantics.
	  </para>
	</blockquote>
	<programlisting>
	  &parameter; (parameter-name [new-value])
	  Description of the parameter and its effects.
	   
	   
	  &syntax; (syntactic-keyword structure ...)
	  Description of the syntax expressions semantics
	</programlisting>
	<para>
	  A procedure is a function that takes a number of arguments
	  and produces a result, which may be undefined. The arguments
	  of a procedure are always evaluated before the procedure is
	  invoked.</para> 
	<para>
	  A parameter is a value that effects the operation of part of
	  the Scheme system. When a parameter is invoked with no
	  arguments, the current value of the parameter is
	  returned. With arguments, the value of the parameter is
	  changed to the arguments given. 
	</para>
	<para>
	  Finally, syntax is any construct whose arguments are not
	  necessarily other s-expressions. Arguments to a syntactic
	  expression are not necessarily evaluated. Syntactic
	  expressions are expanded at compile time to expressions that
	  have the correct semantics but contain no additional
	  syntactic expressions, and are often much more difficult to
	  read then the unexpanded version.
	</para>
	<para>
	  Procedures, parameters, and syntax may take one or more
	  arguments.  The name of an argument in a description
	  indicates the expected type of the argument.  'value'
	  indicates any type.  If the argument is enclosed in square
	  brackets ([]), that parameter is optional, and may be
	  ommited.  If the description ends in elipses (...), then 
	  additional arguments may be provided, but are not required.
	</para>
      </sect2>
    </sect1>
  </chapter>
  <chapter id="Installation">
    <title>
      Installation and Invocation
    </title>
    <sect1 id="RequiredEnv">
      <title>
	Required Environment
      </title>
      <para>
	&SISC; primarily targets the Java Virtual
	Machine, and the Java v1.2 and higher class libraries.  The
	1.2 libraries and VM are required due to a reliance on memory
	reference functionality used to properly garbage collect
	unused symbols while still maining pointer equality between
	those that remain active.
      </para>
      <para>
	&SISC; does not require any particular operating system, though
	the official distribution currently provides launching
	assistance for Windows and Unix based systems.  Theoretically
	any machine that supports Java 1.2 or higher should be able to
	run &SISC;.
      </para>
    </sect1>
    <sect1 id="REPL">
      <title>
	The Read-Eval-Print-Loop
      </title>
      <para>
	As in most Scheme systems, &SISC;'s primary
	human interface is a REPL, or Read-Eval-Print-Loop.  &SISC;
	presents the user with a prompt ('>'), then reads an
	s-expression from the console.  &SISC; then evaluates the
	s-expression, producing a value or error, which it then
	prints.  Finally a prompt is displayed and the process begins
	again.
      </para>
      <para>
	The process terminates with a forced kill of the JVM (with
	Control-C or similar), or when an end of file is detected on
	the console.
      </para>
    </sect1>
    <sect1 id="DisplayConventions">
      <title> 
	Display Conventions
      </title>
      <para>
	Executing or loading code in the REPL ordinarily producs a value
	result which is displayed during the Print phase.  However,
	two other message types may be displayed.  First, if an error
	is raised that is not handled by the running program, the
	message will be described in one of three forms:
      </para>
      <programlisting>
	Error: &lt;description&gt;

	Error in &lt;error-location&gt;: &lt;description&gt;

	Error.
      </programlisting>
      <para>
	The first form describes an error that was raised in an
	anonymous procedure or syntax.  The second describes an error
	that was raised in a named procedure or syntax definition.
	The error-location indicates which procedure encountered
	the error.  The final form is produced by an explicit call
	to the error function with no arguments.
      </para>
      <para>
	In addition to errors, it is possible for code to produce
	warnings during compilation or run-time.  A warning is a
	message to the user about a condition that is unusual but not
	terminal to the program flow.  The compiler, for example, does
	a minimal amount of sanity checking on code and may produce
	warnings about code that has the potential to raise errors
	during execution.  Warnings are always distinguished from
	ordinary messages by surrounding braces ({}). 
      </para>
      <programlisting>
	{warning: &lt;description&gt;}
      </programlisting>
    </sect1>
  </chapter>
  <chapter id="SchemeLanguage">
    <title>
      Scheme Language
    </title>
    <para>
      In this chapter we will examine the language that &SISC;
      interprets, which is a superset of the
      &R5RS; Scheme Standard.
    </para>
    <sect1 id="Types">
      <title>
	Types
      </title>
      <sect2 id="Numbers">
	<title>
	  Numbers
	</title>
	<para>
	  The full Scheme number tower is supported:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Integers
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Floating Point numbers 
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Rational numbers
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Complex numbers
	    </para>
	  </listitem>
	</itemizedlist>
	<para>
	  Depending on the numeric library compiled into &SISC;,
	  floating point numbers have either 32 or 64 bit IEEE
	  precision, or arbitrary precision. Regardless, &SISC;'s
	  complex numbers have floating point components of the same
	  precision as the reals. Integers have arbitrary precision in
	  all numeric libraries, and rational numbers are built with
	  arbitrary precision components.
	</para>
	<sect3 id="NumericConstants">
	  <title>
	    Numeric constants
	  </title>
	  <para>
	    The precision specifying exponents (<computeroutput>S, F,
	    L, </computeroutput>and
	    <computeroutput>D</computeroutput>) 
	    are ignored in &SISC;, all inexact numbers are kept
	    in the precision of the numeric library.  The exponents
	    are read and used to scale the real number as expected.
	    In the case of
	    arbitrary precision floats, specific precision constraints
	    are maintained to prevent a runaway increase of
	    precision. The parameterized functions
	    <emphasis>min-precision</emphasis> and
	    <emphasis>max-precision</emphasis> specify the
	    constraints:
	  </para>
	  <programlisting>
	    &parameter; (min-precision [digits])
	    Sets or displays the minimum precision constraint, an
	    integer.

	    &parameter; (max-precision [digits])
	    Sets or displays the maximum precision constraint, an integer.
	  </programlisting>
	  <para>
	    All four base specifiers (<computeroutput>&num;x, &num;o,
	    &num;d, &num;b</computeroutput>) are supported for
	    integers and rationals. Only decimal 
	    (<computeroutput>&num;d</computeroutput>), the
	    default, is supported for floating point and complex
	    numbers.
	  </para>
	</sect3>
	<sect3 id="Exactness">
	  <title>
	    Exactness
	  </title>
	  <para>
	    Exactness and inexactness contagion behaves as
	    expected. Rational's are made inexact through
	    division. Floats are made exact by conversion to a
	    rational number. &SISC; attempts as accurate a conversion as
	    possible, by converting the decimal portion of the number
	    to a ratio with a denominator of the form 10^n, where n is
	    the scale of the floating point number. Then the fraction
	    is reduced as usual.
	  </para>
	  <para>
	    Since complex numbers must have floating point components
	    currently, conversion to an exact merely rounds the
	    components to integers. 
	  </para>
	</sect3>
      </sect2>
      <sect2 id="Characters">
	<title>
	  Characters
	</title>
	<para>
	  &SISC;'s characters are based on the Java character type. As
	  such, the full range of unicode characters are
	  supported. Unicode characters can be created with
	  <computeroutput>number-&gt;character</computeroutput> or 
	  <computeroutput>&num;&bsol;nnnn</computeroutput>, where <computeroutput>nnnn</computeroutput> is an
	  octal number in the range 0000 -&gt; ffff. 
	</para>
	<para>
	  Characters are compared with respect to the locale detected
	  by the Java VM.
	</para>
      </sect2>
      <sect2 id="Symbols">
	<title>
	  Symbols
	</title>
	<para>
	  &SISC;'s symbols are ordinarily case-insensitive. &SISC;
	  maintains pointer equality between symbols with like
	  contents, unless the symbol is created
	  <emphasis>uninterned</emphasis>. An uninterned symbol is one
	  which is guaranteed to be pointer distinct from any other
	  symbol in the Scheme system, even another with the same
	  contents. Uninterned symbols can be generated with:
	</para>
	<indexterm>
	  <primary>string-&gt;uninterned-symbol</primary>
	</indexterm>
	<programlisting>
	  &procedure; (string-&gt;uninterned-symbol string)
	  &returns; an uninterned, pointer distinct symbol
	  
	</programlisting>
	<para>
	  &SISC; also allows symbols to be created that
	  <emphasis>are</emphasis> case-sensitive. This can be done
	  one of two ways. The first involves setting the reader to
	  produce cased symbols via the procedure
	</para>
	<programlisting>
	  &parameter; (case-sensitive [boolean])
	  Sets or retrieves the reader's case sensitivity.
	</programlisting>
	<para>
	  The second method is via a non-standard symbol syntax. If a
	  symbol is enclosed in pipe ('|') characters, the reader will
	  treat that individual symbol as cased. For example:
	</para>
	<programlisting>
	  (eq? 'a '|A|) ; => #f
	  (eq? 'a '|a|) ; => #t
	  (eq? '|A| '|a|) ; => #f
	</programlisting>
      </sect2>
      <sect2 id="Strings">
	<title>
	  Strings
	</title>
	<para>
	  Strings are built from unicode characters, and are compared
	  according to the locale's rules.
	</para>
      </sect2>
      <sect2 id="Lists">
	<title>
	  Lists
	</title>
	<para></para>
      </sect2>
      <sect2 id="Vectors">
	<title>
	  Vectors
	</title>
	<para>
	  &SISC; supports the length prefix method of creating Vector
	  constants. For example, '<computeroutput>&num;5(x)</computeroutput>'
	  creates a vector constant containing five identical
	  symbols.  In addition, the length-prefix form is used when
	  printing vectors, and if elements repeat at the end of a
	  Vector, only the last unique element is printed.  This form
	  is refered to as the <emphasis>compact</emphasis> vector 
	  representation.  The unprefixed form with all elements
	  displayed is called the <emphasis>verbose</emphasis> representation.
	</para>
	<para>
	  Vectors are displayed differently depending on the call
	  used.  When called with
	  <computeroutput>display</computeroutput>, in addition to the
	  ordinary &R5RS; rules regarding the output of values
	  displayed with <computeroutput>display</computeroutput>,
	  the verbose representation is displayed. Using 
	  <computeroutput>write</computeroutput>, on the other hand
	  produces the compact representation.
	</para>
	<para>
	  Displaying a vector with
	  <computeroutput>pretty-print</computeroutput> may output
	  either the verbose or compact representation of a vector.
	  The behavior of pretty-print is controlled by the parameter
	  <computeroutput>vector-length-prefixing</computeroutput>.
	  If set to &num;t, pretty-print will emit the compact representation.
	  If &num;f, the verbose representation is produced.  By default,
	  <computeroutput>vector-length-prefixing</computeroutput> is true.
	</para>
	<programlisting>
	  &parameter; (vector-length-prefixing [boolean])
	  If set to true, this parameter will instruct the
	  pretty-printer to emit length prefixed,
	  trailing-duplicate-eliminated vectors in its output.  If
	  false, ordinary full-length vectors without prefixes will be
	  emitted.
	</programlisting>
      </sect2>
      <sect2 id="CircularStructures">
	<title>
	  Circular structures
	</title>
	<para>
	  &SISC; provides a parse-time syntax for 
	  creating data (primarily vectors and lists) that contain
	  references to themselves.  This can be useful to create streams,
	  graphs, and other self-referencing structures while
	  maintaining readability and avoiding complex construction
	  code.
	</para>
	<para> 
	  The reader syntax has two parts, defining a pointer, and
	  later referencing the pointer to create the circular
	  reference.
	</para>
	<para>
	  Below is an addition to the &R5RS;
	  formal syntax (specifically section 7.1.2, external
	  representations) to support circular structures:
	</para>
	<programlisting>
	  &lt;pointer definition&gt; --> #&lt;uinteger 10&gt;=&lt;datum&gt;
	  &lt;pointer reference&gt; --> #&lt;uinteger 10&gt;#
	</programlisting>
	<para>
	  The first form instructs the reader to create a pointer
	  identified by the specified integer, which maps to the datum
	  that follows, and is active during the reading of the datum
	  on the right-hand side of the definition.  
	</para>
	<para>
	  If a second definition occurs during the reading of the
	  datum with the same integral identifier, the previous
	  definition is overwritten for the duration of the read.  The
	  definitions are <emphasis>not</emphasis> scoped in any way.
	  The pointer identifiers should be kept unique by the
	  programmer to prevent any unintended effects of identifier
	  collisions. 
	</para>
	<para>
	  The second form references a previously created pointer 
	  definition.  It is an error to reference an undefined
	  pointer.  The reader will handle a valid reference by
	  placing a pointer at the current read position back to the
	  location of the definition. 
	</para>
	<para>
	  At this point some examples might be helpful:
	</para>
	<programlisting>
	  (define x '#0=(1 2 . #0#))
	  (caddr x)        ; => 1
	  (list-ref x 15)  ; => 2

	  (define y '(1 2 #1=#(3 4) . #1#))
	  (eq? (caddr y) (cdddr y)) ; => #t
	</programlisting>
	<para>
	  At this time, only circular lists are detected by the
	  Read-Eval-Print-Loop and blocked from being Printed.  If a
	  cycle exists in any other compound type, it will
	  <emphasis>not</emphasis> be detected, and a print will be
	  attempted.  The print may cause the JVM to exit or may just
	  print to the console indefinitely.  No support yet exists
	  for printing circular lists or other compound cyclic
	  structures, though such functionality may exist in future releases.
	</para>
      </sect2>
      <sect2 id="ImmutableTypes">
	<title>
	  Immutable types
	</title>
	<para>
	  &SISC; follows the &R5RS;
	  recommendation of immutable list, string, and vector
	  constants. Quoted lists and vectors are
	  immutable. Attempting to modify elements in these constants
	  will raise an error. String constants are immutable as well
	  when created with
	  <computeroutput>symbol-&gt;string</computeroutput>.
	</para>
      </sect2>
    </sect1>
    <sect1 id="ErrorHandling">
      <title>
	Error handling
      </title>
      <para>
	&SISC; provides a sophisticated mechanism for handling errors
	raised during the execution of a program.  During the
	execution of any program, there is always a continuation that
	represents the <emphasis>rest</emphasis> of a computation.  In
	addition, one can imagine all the activities that will occur
	as a result of an error.  This sequence of actions is
	explicitly represented in &SISC; as a <emphasis>failure
	continuation</emphasis>. 
      </para>
      <sect2 id="FailureContinuations">
	<title>
	  Failure continuations
	</title>
	<para>
	  Similar to
	  <computeroutput>call-with-current-continuation</computeroutput>,
	  &SISC; provides a function,
	  <computeroutput>call-with-failure-continuation</computeroutput>,
	  that allows a programmer to define the sequence of actions
	  that should occur as a result of an error in a called expression.
	</para>
	<programlisting>
	  &procedure; (call-with-failure-continuation thunk handler)
	  &procedure; (call/fc thunk handler)
	</programlisting>
	<blockquote>
	  <para>
	    <computeroutput>call-with-failure-continuation</computeroutput>
	    takes as arguments a thunk (a zero-argument procedure) to
	    be evaluated.  If during the
	    evaluation of the thunk an error is raised, the second,
	    three argument procedure is called with values describing
	    the error and its context.  If no error occurs, the
	    value of evaluating the thunk becomes the value of the
	    call/fc expression.
	  </para>
	</blockquote>
      </sect2>
      <sect2 id="ErrorHandlers">
	<title>
	  Error handlers
	</title>
	<para>
	  The error handler required as an argument to
	  <computeroutput>call-with-failure-continuation</computeroutput>
	  must take three parameters.  The first, a string, is a human
	  readable message describing the error that occured.  The
	  second is a procedure encapsulating the continuation that was
	  in place at the site of the error.  This continuation is
	  refered to as the <emphasis>error continuation</emphasis>
	  The third, the <emphasis>failure-continuation</emphasis> is
	  a procedure that when invoked calls the failure continuation
	  of the <computeroutput>call/fc</computeroutput> expression.  
	</para>
	<para>
	  When an error occurs, the error handler may choose one of
	  three courses in dealing with the error.  First, the handler
	  may choose to return an alternate value as the result of the
	  <computeroutput>call/fc</computeroutput> expression.
	  Second, the handler may restart the computation from the
	  error site by invoking the error continuation with a value
	  that should be returned in place of the expression that
	  caused the error.  Finally, the handler may choose to
	  propogate the error (or a new error) to the failure
	  continuation of the <computeroutput>call/fc</computeroutput>
	  expression.  To do this, the handler invokes the
	  failure-continuation with the provided or new message and
	  the provided error-continuation or a different continuation
	  captured by other means.
	</para>
	<para>
	  At this point, a few examples may be helpful:
	</para>
	<programlisting>
	  (+ 1 (/ 1 0) 3)
   	    ; => <emphasis>A divide by zero error is raised</emphasis>

	  ; Return a new value
	  (call-with-failure-continuation
	    (lambda ()
              (+ 1 (/ 1 0) 3))
	    (lambda (message error-k failure-k)
	      'error))     
            ; => <emphasis>The symbol</emphasis> 'error

	  ; Restart with a different value
	  (call-with-failure-continuation
  	    (lambda ()
              (+ 1 (/ 1 0) 3))
	    (lambda (message error-k failure-k)
	      (error-k 2)))
            ; => 6

	  ; Propogate the error
	  (call-with-failure-continuation
  	    (lambda ()
              (+ 1 (/ 1 0) 3))
	    (lambda (message error-k failure-k)
	      (failure-k message error-k)))
	    ; => <emphasis>A divide by zero error is raised</emphasis>
	</programlisting>
      </sect2>
      <sect2>
	<title><computeroutput>dynamic-wind</computeroutput></title>
	<para>
	  &R5RS; does not specify the behavior of
	  <computeroutput>dynamic-wind</computeroutput> in the case
	  where an error is raised somewhere in a call to the
	  <emphasis>during</emphasis> thunk.  &SISC; chooses to view
	  an error raised in that section as an instance of the
	  dynamic extent being exited.  In other words, if an error is
	  raised in the dynamic extent of a dynamic-wind expression,
	  &SISC will ensure that the <emphasis>after</emphasis> thunk
	  is evaluated before the error is propogated to the
	  failure-continuation of the dynamic-wind expression.
	</para>
	<para>
	  Here is an example:
	</para>
	<programlisting>
	  (define x 0)
	  (dynamic-wind (lambda () (set! x (+ x 1)))
	                (lambda () (/ 1 0))
	                (lambda () (set! x (+ x 1))))
	  ; => A divide by zero error is raised, and the value of x is 2
	</programlisting>
	<para>
	  If an error is raised in either the
	  <emphasis>before</emphasis> or <emphasis>after</emphasis>
	  thunks, no additional measures are taken.  The error is
	  propogated to the failure-continuation of the dynamic-wind
	  as if the dynamic-wind call was an ordinary function
	  application.  Explicitly, if an error is raised from
	  <emphasis>before</emphasis>, neither
	  <emphasis>during</emphasis> nor <emphasis>after</emphasis>
	  will be executed.  If an error is raised in
	  <emphasis>after</emphasis>, the results of evaluating
	  <emphasis>before</emphasis> and <emphasis>during</emphasis>
	  remain valid.  
	</para>
	<para>
	  Also noteworthy is what happens if a continuation is invoked
	  that exits from either the <emphasis>before</emphasis> or
	  <emphasis>after</emphasis> thunks.  Such a case is treated
	  just as if a continuation was invoked during the evaluation
	  of an operand to an application.  This is to say that no
	  additional steps will be taken by &SISC;.  If
	  <emphasis>before</emphasis> is escaped by a continuation invocation,
	  neither <emphasis>during</emphasis> nor <emphasis>after</emphasis>
	  will be executed.  If <emphasis>after</emphasis> is escaped,
	  the results of <emphasis>before</emphasis> and
	  <emphasis>during</emphasis> remain valid.
	</para>
	<para>
	  In summary, extraordinary evaluation is only possible during
	  the evaluation of the <emphasis>during</emphasis> thunk, the
	  <emphasis>before</emphasis> and <emphasis>after</emphasis>
	  thunks are evaluated with the dynamic environment and
	  dynamic-wind stack of the call to dynamic-wind itself.
	</para>
      </sect2>
    </sect1>
    <sect1 id="SymbolicEnvironments">
      <title>
	Symbolic Environments
      </title>
      <para>
	Symbolic environments provide additional named global
	environments useful for storing program specific data without
	exposing it to the general global environment.  
      </para>
      <programlisting>
	&procedure; (getprop variable-name environment-name)
	&returns; a value, or &num;f if unbound

	Attempts a lookup of variable-name in the symbolic environment
	named by environment-name.  If found, the value is returned.
	If not bound, &num;f is returned.

	&procedure; (putprop variable-name environment-name value)
	&returns; undefined

	Sets the value of the variable named by variable name in the
	symbolc environment named by environment-value to the provided
	value.  Any previous value is forgotten.
      </programlisting>
    </sect1>
    <sect1 id="Boxing">
      <title>
	Boxing
      </title>
      <para>
	&SISC; supports boxes, a container for a
	Scheme value. Boxing is often used to implement
	call-by-reference semantics. Boxes are created and accessed
	using the following three functions:
      </para>
      <programlisting>
	&procedure; (box value)
	&returns; a box containing the given value
	 
	Creates a box filled with the given value.

	&procedure; (unbox box)
	&returns; the value contained in the given box
	 
	Returns the contents of a box.

	&procedure; (set-box! box value)
	&returns; undefined
	 
	Replaces the value contained in the given box with a given
	value.
      </programlisting>
    </sect1>
  </chapter>
  <chapter id="LibraryFunctions">
    <title>
      &SISC; Library Functions
    </title>
    <sect1 id="Debugging">
      <title>
	Debugging
      </title>
      <para>
	&SISC; provides debugging aids that can be added to Scheme
	source code, as well as limited support for debugging without
	modification. 
      </para>
      <programlisting>
	&syntax; (trace-lambda trace-name formals body)

	When replaced with a trace-lambda, all calls to a lambda defined 
	procedure are traced on the console.  <emphasis>trace-name</emphasis> 
	is a symbol to identify the procedure in the trace. 
	<emphasis>formals </emphasis>and <emphasis>body</emphasis> have
	identical semantics to lambda.
	 
	&syntax; (trace-let loop-name formal-bindings body)
	Replaces a named-let expression in a similar manner to trace-lambda.  
	 
	&procedure; (trace-top-level-procedures symbol ...)
	&returns; undefined
	 
	Begins traces on the procedures named by the symbols given.  The procedures must be defined in the top-level environment.
	 
	&procedure; (untrace-top-level-procedures symbol ...)
	&returns; undefined
	 
	Stops tracing the top-level procedures named by the symbols given.
      </programlisting>
      <para>
	Trace-lambda and trace-let are useful for debugging anonymous
	lambdas and named-lets
	respectively. Trace-top-level-procedures can be used to trace
	calls to any procedure, including native procedures and stored
	continuations.
      </para>
    </sect1>
    <sect1 id="BitwiseLogicalOperations">
      <title>
	Bitwise Logical Operations
      </title>
      <para>
	In addition to the &R5RS; set of procedures that deal with
	numbers, &SISC; provides operators for performing bitwise
	logic operations on a limited range of integers.  The domain of the
	logical operators are exact real integers of the range
	-2,147,483,647 to 2,147,483,646 inclusive.  An error is raised
	if the logical operators are applied to integers outside this
	range, to a non-integer, or a non-real.
      </para>
      <programlisting>
	&procedure; (logand integer [integer] ...)
	&returns; The logical AND of all provided operands
	
	&procedure; (logor integer [integer] ...)
	&returns; The logical OR of all provided operands

	&procedure; (logxor integer [integer] ...)
	&returns; The logical exclusive-OR of all provided operands

	&procedure; (lognot integer)
	&returns; The logical NOT of the provided operand
      </programlisting>
      <para>
	In addition, two operators are provided to perform arithmetic
	shifts on any integer (these operators do not have the range
	limitation the previous logical functions do).  The shift
	operators return a newly generated number formed by shifting
	the provided number left or right by the given number of bits.
      </para>
      <programlisting>
	&procedure; (ashl integer bits)
	&returns; <emphasis>integer</emphasis> shifted left by <emphasis>bits</emphasis> bits.

	&procedure; (ashr integer bits)
	&returns; <emphasis>integer</emphasis> shifted right by <emphasis>bits</emphasis> bits.
      </programlisting>
      <para>
	Mathematically, if r is the number, and s is the number of
	bits, ashl calculates:
	<programlisting>
	  r x 2<superscript>s</superscript>
	</programlisting>
	while ashr calculates
	<programlisting>
	  r / 2<superscript>s</superscript>
	</programlisting>
	in the integer domain.  Both ashl and ashr operate on exact
	integers and produce only exact integers.  
      </para>
    </sect1>
    <sect1 id="OperatingSystemInterface">
      <title>
	Operating System interface
      </title>
      <para></para>
    </sect1>
  </chapter>
  <chapter id="IO">
    <title>
      I/O
    </title>
    <para>
      &SISC;'s I/O routines are implemented in a flexible manner, allowing 
      extensions to create new I/O sources that will behave as
      standard Scheme port objects.  The ports can then be operated on
      with all &R5RS; port operations, as well as some &SISC; specific 
      port functions.
    </para>
    <sect1 id="PortCreation">
      <title>
	Port creation
      </title>
      <para>&SISC; extends the &R5RS; standard's port-creation
	functions in order to provide buffered output ports.  All &SISC; 
	output ports are buffered, and a programmer may choose whether
	a given port should automatically flush after each write
	operation.  By default ports do <emphasis>not</emphasis>
	automatically flush.  Enabling auto-flush can be done when the
	port is created per the specifications below.  A port that
	does not automatically flush can be flushed at any time by
	calling <computeroutput>flush-output-port</computeroutput>.
	Finally, an output-port that does not automatically flush will
	be flushed when the port is closed with
	<computeroutput>close-output-port</computeroutput>, but may
	not be flushed if the Scheme system is exited without closing
	the port.
      </para>
      <programlisting>
	&procedure; (open-output-file file [auto-flush])
	&returns; An output port

	Creates an output port to the specified file (a string).  If
	the optional auto-flush argument is provided and is true, the
	port will automatically flush after each write call.  If the
	specified file exists, it will be overwritten silently when
	the port is opened.


	&procedure; (flush-output-port output-port)
	&returns; unspecified

	Causes the specified output-port's buffered data to be written
	immediately.  This operation is allowed on both auto-flush and
	non-auto-flush output ports, though it has no effect on the
	former.
      </programlisting>
    </sect1>
    <sect1 id="BlockIO">
      <title>
	Block I/O
      </title>
      <para>
	In addition to the standard operations on ports
	(<computeroutput>read, read-char, char-available?,
	display,</computeroutput> and
	<computeroutput>write</computeroutput>), &SISC; provides block
	input/output functions, that allow a Scheme program to read
	blocks of more than one byte or character of data at a time.
	&SISC; stores data that is read or is to be written in a string.
	Binary data in strings is fully supported throughout &SISC;.  
	Such strings may be read and written as usual, though
	undisplayable characters will often be escaped.
      </para>
      <programlisting> 
	&procedure; (block-read buffer input-port integer)
	&returns; the number of bytes read, an integer

	Reads up to <emphasis>integer</emphasis> bytes of data from
        the provided <emphasis>input-port</emphasis> into
        <emphasis>buffer</emphasis>.  Note that less than
        <emphasis>integer</emphasis> bytes may be read. 

	&procedure; (block-write buffer input-port integer)
	&returns; unspecified
 
        Writes up to <emphasis>integer</emphasis> bytes of data stored
	in <emphasis>buffer</emphasis> to the specified
	<emphasis>output-port</emphasis>.
      </programlisting>
    </sect1>
    <sect1 id="StringPorts">
      <title>
	String Ports
      </title>
      <para>
	String ports are input or output ports that read or write to a
	string rather than a file or other stream.  String ports can
	be used to parse or emit formatted strings using the standard
	Scheme port operations.  A String Input port will read from a
	given string until the end of string is reached, at which
	point <computeroutput>&num;!eof</computeroutput> is returned.  
      </para>
      <programlisting>
	&procedure; (open-input-string string)
	&returns; A string input port 
	
	Creates a string input port whose characters are read from the
	provided string.  Characters will be returned from any read
	operation on the port until the end of the string is reached.
	Read calls after reaching the end of the string will return 
	&num;!eof.

	
	&procedure; (open-output-string)
	&returns; A string output port

	Creates a string output port, which behaves as an ordinary
	output port, except that writes are used to create a string as
	output.  The results of all the write operations are retrieved
	using (get-output-string)


	&procedure; (get-output-string string-output-port)
	&returns; A string

	Returns the string that was created by zero or more writes to
	a string output port.  If no writes were performed on the
	string output port, an empty string ("") is returned.  After
	this call, the provided string output port is reset to its
	initial, empty state.
      </programlisting>
    </sect1>
    <sect1 id="PrettyPrinting">
      <title>
	Pretty-printing
      </title>
      <para>
	&SISC; includes a pretty-printer, a function that behaves like
	<computeroutput>write</computeroutput>, but introduces
	whitespace in order to make the output of data more readable
	to humans. 
	</para>
      <programlisting>
	&procedure; (pretty-print value [output-port])
	&returns; unspecified

	Pretty-prints the specified value, either to the specified
	output-port, or to the console if no output-port is
	specified. 
      </programlisting>
    </sect1>
    <sect1 id="FileSystem">
      <title>
	File-system interface
      </title>
      <para>
	&SISC; provides several additional functions that allow a
	programmer to interface to the filesystem, to obtain
	information about files or directories, and to delete, rename, 
	and modify these files and directories.
      </para>
      <para>
	This API is incomplete... please stay tuned.
      </para>
    </sect1>
    <sect1 id="netio">
      <title>
	Networking
      </title>
      <para>
	The &SISC; Networking library provides a mechanism for
	creating and manipulating IP network protocols as standard
	Scheme ports.  &SISC; supports TCP, UDP, and Multicast UDP.
	Each is described in the sections that follow.
      </para>
      <para>
	Each protocol provides one or more <emphasis>socket
	constructors</emphasis>.  These functions produce a Socket
	handle, which is represented in &SISC; as
	<computeroutput>&num;&lt;socket&gt;</computeroutput>.  A
	socket handle is then used to obtain Scheme ports.
      </para>
      <para>
	IP addresses are represented as strings in &SISC;.  Unless
	otherwise noted, the network library functions that require an
	address may take an address as a string in the dotted quad
	form ("aaa.bbb.ccc.ddd"), or as a hostname which will be
	resolved using the domain name system.  All port values must
	be integers in the proper range.
      </para>
      <sect2 id="netutils">
	<title>
	  Address functions
	</title>
	<para>
	  Several utility functions are provided for manipulating IP
	  addresses.  These are described below.
	</para>
	<programlisting>
	  &procedure; (get-host-ip-by-name string)
	  &returns; A dotted-quad IP address or &f;

	  Attempts to resolve a hostname provided as a string into an 
	  IP address in dotted-quad form.  If the host cannot be
	  found, &f; is returned.

	  
	  &procedure; (get-host-name-by-ip string)
	  &returns; A hostname or &f;

	  Attempts a reverse lookup of the given dotted-quad address
	  to determine a registered domain name.  If unsuccessful, &f;
	  is returned

	  
	  &procedure; (get-local-host)
	  &returns; The dotted-quad address of the local host 

	  Attempts to determine the Internet visible IP address of the
	  local machine.  If successful, this address is returned in
	  dotted-quad notation.  &f; is returned otherwise.
	</programlisting>
      </sect2>
      <sect2 id="sockets">
	<title>
	  Socket operations
	</title>
	<para>
	  Once obtained using a protocol specific constructor, a
	  Socket Handle allows manipulation of common socket options,
	  the creation of Scheme input/output ports, and closing of
	  the socket.
	</para>
	<programlisting>
	  &procedure; (open-socket-input-port socket)
	  &returns; an input port

	  Opens a Scheme input port to the socket.  


	  &procedure; (open-socket-output-port socket [boolean])
	  &returns; an output port

	  Opens a Scheme output port to the socket.  If provided, the
	  boolean argument specifies whether the given port should be
	  set to auto-flush mode.  If unspecified, the port does
	  <emphasis>not</emphasis> auto-flush.
	  

	  &procedure; (close-socket socket)
	  &returns; unspecified

	  Closes an IP socket.  
	</programlisting>
	<para>
	  The port-obtaining functions above work on most sockets.
	  An exception applies for  TCP server sockets, which are used only to
	  obtain connected TCP sockets.
	</para>
      </sect2>
      <sect2 id="TCP">
	<title>
	  TCP
	</title>
	<para>
	  The most commonly used Internet protocol maps most favorably
	  to Scheme's input/output model.  Writing to an output port
	  retrieved from a TCP socket writes the data to that socket.
	  Reading from an input port reads from the connected socket.
	  One imporant note is that one can control the amount of data
	  that fills a TCP packet by using an output port that does
	  not auto-flush.  Data is written to the port until one
	  considers the packet complete, and then uses
	  <computeroutput>(flush-output-port port)</computeroutput> to
	  complete the packet.  Note also that this does not
	  <emphasis>guarantee</emphasis> that one gets the desired
	  packet size, but does allow one to construct reasonably
	  sized packets.
	</para>
	<para>
	  TCP sockets are obtained one of two ways.  Either one
	  creates an outgoing connection to another listening host and
	  then subsequently obtains a socket handle, or one creates a
	  <emphasis>listening socket</emphasis> and then obtains a
	  socket by waiting for an incoming connection on the
	  specified port.  In either case, the result is a socket
	  handle with an available input and output port that can be
	  obtained using a function in the previous section.
	</para>
	<programlisting>
	  &procedure; (open-tcp-socket string integer)
	  &returns; A connected TCP socket

	  Attempts to connect to the host at the given hostname or IP
	  address encoded in the string, at the given TCP port
	  specified by the integer.  An error is raised if the host
	  cannot be found or the connection fails.

	  
	  &procedure; (open-tcp-listener integer [string])
	  &returns; A TCP server socket

	  Creates a TCP server socket, which may only be used with
	  accept-tcp-socket, or closed.  The server socket will listen
	  on the integer port specified.  If provided, the string
	  specifies the address of a local interface to bind to.  If
	  not provided, the port is bound on all available
	  interfaces.  An error is raised if the socket cannot be
	  bound and set listening.

	  
	  &procedure; (accept-tcp-socket server-socket)
	  &returns; A TCP socket

	  Accepts an incoming connection on the provided
	  server-socket, and returns a TCP socket handle.  This
	  function will block until an incoming connection is made,
	  or, if set, the socket timeout is exceeded.  If the latter
	  happens, an error will be raised.

	  
	  &procedure; (set-so-timeout! socket integer)
	  &returns; undefined

	  Sets the socket timeout on a socket.  The socket can be
	  either a server socket or connected socket.  In the former
	  case, this value specifies the number of milliseconds that
	  an accept-tcp-socket can wait before timing out.  In the
	  latter, the value specifies the number of milliseconds that
	  can elapse during a read call before timing out.
	</programlisting>
      </sect2>
    </sect1>
  </chapter>
  <chapter id="Threads">
    <title>
      Threads and Concurrency
    </title>
    <para></para>
  </chapter>
  <chapter>
    <title>
      The Module System
    </title>
    <para>
      The Module system consists of two components. The first is the
      module syntax extension provided by R. Kent Dybvig's syntax
      expander &lsqb;REF&rsqb;. This level provides the ability to
      scope Scheme code into importable modules with selectable
      exports. 
    </para>
    <para>
      The second is the Java level &SISC; API for
      native extensions to the language. A &SISC;
      module defines new types and functions. Each
      &SISC; module can be queried from Scheme, and
      imported into the runtime environment as a whole, or packaged
      via the same export mechanism as native Scheme code.
    </para>
  </chapter>
  <chapter id="javainteraction">
    <title>
      Java Interaction
    </title>
    <para>
      &SISC; can be used as a scripting language
      for Java, or Java may be used to provide functionality to
      Scheme. Such activity is collectively termed 'bridging'. &SISC;
      provides an API that may be called from Java to execute Scheme
      code or evaluate Scheme expressions. In addition, the J2S module
      provides Scheme level control of Java objects, methods, and
      fields. Finally, the two can be combined in a number of complex
      ways to intertwine the two languages.
    </para>
    <sect1 id="JavaToScheme">
      <title>
	Java to Scheme call API
      </title>
      <para></para>
      <sect2 id="JErrorHandling">
	<title>
	  Error Handling
	</title>
	<para></para>
      </sect2>
      <sect2 id="JContinuations">
	<title>
	  Continuations
	</title>
	<para></para>
      </sect2>
    </sect1>
    <sect1 id="SchemeToJava">
      <title>
	Scheme level Java manipulation
      </title>
      <para></para>
    </sect1>
  </chapter>
  <appendix id="Errata">
    <title>Errata</title>
    <para>
      This appendix describes where this manual and the implementation
      of SISC depart.  This section should remain small, as it is the
      goal of the Interpreter to conform to this document, not for
      this document to describe the idiosyncracies of the Interpreter.
    </para>
    <para>
      <orderedlist>
	<listitem>
	  <para>
	    (<xref linkend="Symbols"/>) The function
	    <computeroutput>case-sensitive</computeroutput> is not yet implemented.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    (<xref linkend="Characters"/> and <xref
	    linkend="Strings"/>) Characters  and strings are not
	    compared according to locale rules (bug &num;493773)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    (<xref linkend="Debugging"/>) The debugging functions
	     functions <computeroutput>trace</computeroutput> and
	    <computeroutput>untrace</computeroutput> are not yet
	    implemented.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    (<xref linkend="PortCreation"/>) The optional boolean
	    argument in the creation of output ports that specifies
	    auto-flush behavior is only present on net network port
	    creation functions.  File ports are missing this
	    functionality.  
	  </para>
	</listitem>
      </orderedlist>
    </para>
  </appendix>
  &gfdl;
  <index id="functions">
    <title>Index of Functions</title>
    <para>
    </para>
  </index>
</book>
