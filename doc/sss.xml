<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                    "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd" [
 <!ENTITY SISC "<emphasis>SISC</emphasis>">
 <!ENTITY R5RS "R<superscript>5</superscript>RS">
 <!ENTITY syntax "<emphasis role='bold'><emphasis>syntax:</emphasis></emphasis>">
 <!ENTITY returns "<emphasis role='bold'><emphasis>returns:</emphasis></emphasis>">
 <!ENTITY procedure "<emphasis role='bold'><emphasis>procedure:</emphasis></emphasis>">
 <!ENTITY parameter "<emphasis role='bold'><emphasis>parameter:</emphasis></emphasis>">
 <!ENTITY f "&num;f">
 <!ENTITY gfdl SYSTEM "fdl.sgml">
]>

<book lang="en">
  <!-- DocBook file was created by LyX 1.1
  See http://www.lyx.org/ for more information -->
  <bookinfo>
    <title>
      &SISC; <emphasis>for Seasoned Schemers</emphasis>
    </title>
    <authorgroup>
      <author>
	<firstname>Scott</firstname>
	<othername>G.</othername>
	<surname>Miller</surname>
      </author>
      <author>
	<firstname>Matthias</firstname>
	<surname>Radestock</surname>
	<contrib>
	  Generic functions and Scheme/Java bridge documentation
	</contrib>
      </author>
    </authorgroup>
    <date>
      February 2002
    </date>
    <copyright>
      <year>2002</year>
      <holder>Scott G. Miller</holder>
    </copyright>
    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation License,
	Version 1.1 or any later version published by the Free Software
	Foundation; with no Invariant Sections, with no Front-Cover
	Texts, and with no Back-Cover Texts.  A copy of the license is
	included in the section entitled "GNU Free Documentation License".
	(<xref linkend="gfdl"/>)
      </para>
    </legalnotice>
      
  </bookinfo>
  <chapter>
    <title>
      Introduction
    </title>
    <para>
      &SISC; is a lightweight, platform independent
      Scheme system whose primary goals are rapid execution of the
      complete &R5RS; and future Scheme
      standards, plus a useful superset for real-world application
      development. 
    </para>
    <para>
      &SISC;'s development progresses in two
      directions, to improve the core interpreter to be simpler,
      more elegant, and more efficient; and to add necessary
      functionality through extensions that do not complicate the
      core.
    </para>
    <sect1 id="Features">
      <title>
	Features
      </title>
      <itemizedlist>
	<listitem>
	  <para>
	    Full &R5RS; compliance
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Efficient number tower, with support for integers, floating-point numbers, rationals, and complex numbers of arbitrary precision
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Lightweight Scheme engine, requiring less than 200 kilobytes of code.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Runtime extensiblity through a scopeable module system, which may add new functions and first-class types.
	  </para>
	</listitem>
      </itemizedlist>
    </sect1>
    <sect1 id="About">
      <title>
	About this document
      </title>
      <para>
	This document explains the &SISC; Scheme system. It assumes
	knowledge of the Scheme language. As such, when discussing the
	Scheme language, we will focus primarily on differences
	between the Scheme standard and the language implemented by
	&SISC;.
      </para>
      <para>
	Secondly, &SISC; implements the &R5RS; standard. As such, any
	code written to that standard should run without reading any
	further.
      </para>
      <sect2 id="AboutProcedures">
	<title>
	  About procedure documentation
	</title>
	<para>
	  Throughout this document, procedures will be defined using
	  the following syntax:
	</para>
	  <para>
	    
	  <funcsynopsis>
	    <funcprototype>
	      <funcdef><function>max</function></funcdef>
	      <paramdef><parameter>string</parameter></paramdef>
	      <paramdef><parameter>string</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	</para>
	<blockquote>
	  <para>
	    Description of the procedure's semantics.
	  </para>
	</blockquote>
	<programlisting>
	  &parameter; (parameter-name [new-value])
	  Description of the parameter and its effects.
	   
	   
	  &syntax; (syntactic-keyword structure ...)
	  Description of the syntax expressions semantics
	</programlisting>
	<para>
	  A procedure is a function that takes a number of arguments
	  and produces a result, which may be undefined. The arguments
	  of a procedure are always evaluated before the procedure is
	  invoked.</para> 
	<para>
	  A parameter is a value that effects the operation of part of
	  the Scheme system. When a parameter is invoked with no
	  arguments, the current value of the parameter is
	  returned. With arguments, the value of the parameter is
	  changed to the arguments given. 
	</para>
	<para>
	  Finally, syntax is any construct whose arguments are not
	  necessarily other s-expressions. Arguments to a syntactic
	  expression are not necessarily evaluated. Syntactic
	  expressions are expanded at compile time to expressions that
	  have the correct semantics but contain no additional
	  syntactic expressions, and are often much more difficult to
	  read then the unexpanded version.
	</para>
	<para>
	  Procedures, parameters, and syntax may take one or more
	  arguments.  The name of an argument in a description
	  indicates the expected type of the argument.  'value'
	  indicates any type.  If the argument is enclosed in square
	  brackets ([]), that parameter is optional, and may be
	  ommitted.  If the description ends in ellipses (...), then 
	  additional arguments may be provided, but are not required.
	</para>
      </sect2>
    </sect1>
  </chapter>
  <chapter id="Installation">
    <title>
      Installation and Invocation
    </title>
    <sect1 id="RequiredEnv">
      <title>
	Required Environment
      </title>
      <para>
	&SISC; primarily targets the Java Virtual
	Machine, and the Java v1.2 and higher class libraries.  The
	1.2 libraries and VM are required due to a reliance on memory
	reference functionality used to properly garbage collect
	unused symbols while still maintaining pointer equality between
	those that remain active.
      </para>
      <para>
	&SISC; does not require any particular operating system, though
	the official distribution currently provides launching
	assistance for Windows and Unix based systems.  Theoretically
	any machine that supports Java 1.2 or higher should be able to
	run &SISC;.
      </para>
    </sect1>
    <sect1 id="REPL">
      <title>
	The Read-Eval-Print-Loop
      </title>
      <para>
	As in most Scheme systems, &SISC;'s primary
	human interface is a REPL, or Read-Eval-Print-Loop.  &SISC;
	presents the user with a prompt ('>'), then reads an
	s-expression from the console.  &SISC; then evaluates the
	s-expression, producing a value or error, which it then
	prints.  Finally a prompt is displayed and the process begins
	again.
      </para>
      <para>
	The process terminates with a forced kill of the JVM (with
	Control-C or similar), or when an end of file is detected on
	the console.
      </para>
    </sect1>
    <sect1 id="DisplayConventions">
      <title> 
	Display Conventions
      </title>
      <para>
	Executing or loading code in the REPL ordinarily produces a value
	result which is displayed during the Print phase.  However,
	two other message types may be displayed.  First, if an error
	is raised that is not handled by the running program, the
	message will be described in one of three forms:
      </para>
      <programlisting>
	Error: &lt;description&gt;

	Error in &lt;error-location&gt;: &lt;description&gt;

	Error.
      </programlisting>
      <para>
	The first form describes an error that was raised in an
	anonymous procedure or syntax.  The second describes an error
	that was raised in a named procedure or syntax definition.
	The error-location indicates which procedure encountered
	the error.  The final form is produced by an explicit call
	to the error function with no arguments.
      </para>
      <para>
	In addition to errors, it is possible for code to produce
	warnings during compilation or run-time.  A warning is a
	message to the user about a condition that is unusual but not
	terminal to the program flow.  The compiler, for example, does
	a minimal amount of sanity checking on code and may produce
	warnings about code that has the potential to raise errors
	during execution.  Warnings are always distinguished from
	ordinary messages by surrounding braces ({}). 
      </para>
      <programlisting>
	{warning: &lt;description&gt;}
      </programlisting>
    </sect1>
  </chapter>
  <chapter id="SchemeLanguage">
    <title>
      Scheme Language
    </title>
    <para>
      In this chapter we will examine the language that &SISC;
      interprets, which is a superset of the
      &R5RS; Scheme Standard.
    </para>
    <sect1 id="Types">
      <title>
	Types
      </title>
      <sect2 id="Numbers">
	<title>
	  Numbers
	</title>
	<para>
	  The full Scheme number tower is supported:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Integers
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Floating Point numbers 
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Rational numbers
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Complex numbers
	    </para>
	  </listitem>
	</itemizedlist>
	<para>
	  Depending on the numeric library compiled into &SISC;,
	  floating point numbers have either 32 or 64 bit IEEE
	  precision, or arbitrary precision. Regardless, &SISC;'s
	  complex numbers have floating point components of the same
	  precision as the reals. Integers have arbitrary precision in
	  all numeric libraries, and rational numbers are built with
	  arbitrary precision components.
	</para>
	<sect3 id="NumericConstants">
	  <title>
	    Numeric constants
	  </title>
	  <para>
	    The precision specifying exponents (<computeroutput>S, F,
	    L, </computeroutput>and
	    <computeroutput>D</computeroutput>) 
	    are ignored in &SISC;, all inexact numbers are kept
	    in the precision of the numeric library.  The exponents
	    are read and used to scale the real number as expected.
	    In the case of
	    arbitrary precision floats, specific precision constraints
	    are maintained to prevent a runaway increase of
	    precision. The parameterized functions
	    <emphasis>min-precision</emphasis> and
	    <emphasis>max-precision</emphasis> specify the
	    constraints:
	  </para>
	  <programlisting>
	    &parameter; (min-precision [digits])
	    Sets or displays the minimum precision constraint, an
	    integer.

	    &parameter; (max-precision [digits])
	    Sets or displays the maximum precision constraint, an integer.
	  </programlisting>
	  <para>
	    All four base specifiers (<computeroutput>&num;x, &num;o,
	    &num;d, &num;b</computeroutput>) are supported for
	    integers and rationals. Only decimal 
	    (<computeroutput>&num;d</computeroutput>), the
	    default, is supported for floating point and complex
	    numbers.
	  </para>
	</sect3>
	<sect3 id="Exactness">
	  <title>
	    Exactness
	  </title>
	  <para>
	    Exactness and inexactness contagion behaves as
	    expected. Rational's are made inexact through
	    division. Floats are made exact by conversion to a
	    rational number. &SISC; attempts as accurate a conversion as
	    possible, by converting the decimal portion of the number
	    to a ratio with a denominator of the form 10^n, where n is
	    the scale of the floating point number. Then the fraction
	    is reduced as usual.
	  </para>
	  <para>
	    Since complex numbers must have floating point components
	    currently, conversion to an exact merely rounds the
	    components to integers. 
	  </para>
	</sect3>
      </sect2>
      <sect2 id="Characters">
	<title>
	  Characters
	</title>
	<para>
	  &SISC;'s characters are based on the Java character type. As
	  such, the full range of unicode characters are
	  supported. Unicode characters can be created with
	  <computeroutput>number-&gt;character</computeroutput> or 
	  <computeroutput>&num;&bsol;nnnn</computeroutput>, where <computeroutput>nnnn</computeroutput> is an
	  octal number in the range 0000 -&gt; ffff. 
	</para>
	<para>
	  Characters are compared with respect to the locale detected
	  by the Java VM.
	</para>
      </sect2>
      <sect2 id="Symbols">
	<title>
	  Symbols
	</title>
	<para>
	  &SISC;'s symbols are ordinarily case-insensitive. &SISC;
	  maintains pointer equality between symbols with like
	  contents, unless the symbol is created
	  <emphasis>uninterned</emphasis>. An uninterned symbol is one
	  which is guaranteed to be pointer distinct from any other
	  symbol in the Scheme system, even another with the same
	  contents. Uninterned symbols can be generated with:
	</para>
	<indexterm>
	  <primary>string-&gt;uninterned-symbol</primary>
	</indexterm>
	<programlisting>
	  &procedure; (string-&gt;uninterned-symbol string)
	  &returns; an uninterned, pointer distinct symbol
	  
	</programlisting>
	<para>
	  &SISC; also allows symbols to be created that
	  <emphasis>are</emphasis> case-sensitive. This can be done
	  one of two ways. The first involves setting the reader to
	  produce cased symbols via the procedure
	</para>
	<programlisting>
	  &parameter; (case-sensitive [boolean])
	  Sets or retrieves the reader's case sensitivity.
	</programlisting>
	<para>
	  The second method is via a non-standard symbol syntax. If a
	  symbol is enclosed in pipe ('|') characters, the reader will
	  treat that individual symbol as cased. For example:
	</para>
	<programlisting>
	  (eq? 'a '|A|) ; => #f
	  (eq? 'a '|a|) ; => #t
	  (eq? '|A| '|a|) ; => #f
	</programlisting>
      </sect2>
      <sect2 id="Strings">
	<title>
	  Strings
	</title>
	<para>
	  Strings are built from unicode characters, and are compared
	  according to the locale's rules.
	</para>
      </sect2>
      <sect2 id="Lists">
	<title>
	  Lists
	</title>
	<para></para>
      </sect2>
      <sect2 id="Vectors">
	<title>
	  Vectors
	</title>
	<para>
	  &SISC; supports the length prefix method of creating Vector
	  constants. For example, '<computeroutput>&num;5(x)</computeroutput>'
	  creates a vector constant containing five identical
	  symbols.  In addition, the length-prefix form is used when
	  printing vectors, and if elements repeat at the end of a
	  Vector, only the last unique element is printed.  This form
	  is referred to as the <emphasis>compact</emphasis> vector 
	  representation.  The unprefixed form with all elements
	  displayed is called the <emphasis>verbose</emphasis> representation.
	</para>
	<para>
	  Vectors are displayed differently depending on the call
	  used.  When called with
	  <computeroutput>display</computeroutput>, in addition to the
	  ordinary &R5RS; rules regarding the output of values
	  displayed with <computeroutput>display</computeroutput>,
	  the verbose representation is displayed. Using 
	  <computeroutput>write</computeroutput>, on the other hand
	  produces the compact representation.
	</para>
	<para>
	  Displaying a vector with
	  <computeroutput>pretty-print</computeroutput> may output
	  either the verbose or compact representation of a vector.
	  The behavior of pretty-print is controlled by the parameter
	  <computeroutput>vector-length-prefixing</computeroutput>.
	  If set to &num;t, pretty-print will emit the compact representation.
	  If &num;f, the verbose representation is produced.  By default,
	  <computeroutput>vector-length-prefixing</computeroutput> is true.
	</para>
	<programlisting>
	  &parameter; (vector-length-prefixing [boolean])
	  If set to true, this parameter will instruct the
	  pretty-printer to emit length prefixed,
	  trailing-duplicate-eliminated vectors in its output.  If
	  false, ordinary full-length vectors without prefixes will be
	  emitted.
	</programlisting>
      </sect2>
      <sect2 id="CircularStructures">
	<title>
	  Circular structures
	</title>
	<para>
	  &SISC; provides a parse-time syntax for 
	  creating data (primarily vectors and lists) that contain
	  references to themselves.  This can be useful to create streams,
	  graphs, and other self-referencing structures while
	  maintaining readability and avoiding complex construction
	  code.
	</para>
	<para> 
	  The reader syntax has two parts, defining a pointer, and
	  later referencing the pointer to create the circular
	  reference.
	</para>
	<para>
	  Below is an addition to the &R5RS;
	  formal syntax (specifically section 7.1.2, external
	  representations) to support circular structures:
	</para>
	<programlisting>
	  &lt;pointer definition&gt; --> #&lt;uinteger 10&gt;=&lt;datum&gt;
	  &lt;pointer reference&gt; --> #&lt;uinteger 10&gt;#
	</programlisting>
	<para>
	  The first form instructs the reader to create a pointer
	  identified by the specified integer, which maps to the datum
	  that follows, and is active during the reading of the datum
	  on the right-hand side of the definition.  
	</para>
	<para>
	  If a second definition occurs during the reading of the
	  datum with the same integral identifier, the previous
	  definition is overwritten for the duration of the read.  The
	  definitions are <emphasis>not</emphasis> scoped in any way.
	  The pointer identifiers should be kept unique by the
	  programmer to prevent any unintended effects of identifier
	  collisions. 
	</para>
	<para>
	  The second form references a previously created pointer 
	  definition.  It is an error to reference an undefined
	  pointer.  The reader will handle a valid reference by
	  placing a pointer at the current read position back to the
	  location of the definition. 
	</para>
	<para>
	  At this point some examples might be helpful:
	</para>
	<programlisting>
	  (define x '#0=(1 2 . #0#))
	  (caddr x)        ; => 1
	  (list-ref x 15)  ; => 2

	  (define y '(1 2 #1=#(3 4) . #1#))
	  (eq? (caddr y) (cdddr y)) ; => #t
	</programlisting>
	<para>
	  At this time, only circular lists are detected by the
	  Read-Eval-Print-Loop and blocked from being Printed.  If a
	  cycle exists in any other compound type, it will
	  <emphasis>not</emphasis> be detected, and a print will be
	  attempted.  The print may cause the JVM to exit or may just
	  print to the console indefinitely.  No support yet exists
	  for printing circular lists or other compound cyclic
	  structures, though such functionality may exist in future releases.
	</para>
      </sect2>
      <sect2 id="ImmutableTypes">
	<title>
	  Immutable types
	</title>
	<para>
	  &SISC; follows the &R5RS;
	  recommendation of immutable list, string, and vector
	  constants. Quoted lists and vectors are
	  immutable. Attempting to modify elements in these constants
	  will raise an error. String constants are immutable as well
	  when created with
	  <computeroutput>symbol-&gt;string</computeroutput>.
	</para>
      </sect2>
    </sect1>
    <sect1 id="ErrorHandling">
      <title>
	Error handling
      </title>
      <para>
	&SISC; provides a sophisticated mechanism for handling errors
	raised during the execution of a program.  During the
	execution of any program, there is always a continuation that
	represents the <emphasis>rest</emphasis> of a computation.  In
	addition, one can imagine all the activities that will occur
	as a result of an error.  This sequence of actions is
	explicitly represented in &SISC; as a <emphasis>failure
	continuation</emphasis>. 
      </para>
      <sect2 id="FailureContinuations">
	<title>
	  Failure continuations
	</title>
	<para>
	  Similar to
	  <computeroutput>call-with-current-continuation</computeroutput>,
	  &SISC; provides a function,
	  <computeroutput>call-with-failure-continuation</computeroutput>,
	  that allows a programmer to define the sequence of actions
	  that should occur as a result of an error in a called expression.
	</para>
	<programlisting>
	  &procedure; (call-with-failure-continuation thunk handler)
	  &procedure; (call/fc thunk handler)
	</programlisting>
	<blockquote>
	  <para>
	    <computeroutput>call-with-failure-continuation</computeroutput>
	    takes as arguments a thunk (a zero-argument procedure) to
	    be evaluated.  If during the
	    evaluation of the thunk an error is raised, the second,
	    three argument procedure is called with values describing
	    the error and its context.  If no error occurs, the
	    value of evaluating the thunk becomes the value of the
	    call/fc expression.
	  </para>
	</blockquote>
      </sect2>
      <sect2 id="ErrorHandlers">
	<title>
	  Error handlers
	</title>
	<para>
	  The error handler required as an argument to
	  <computeroutput>call-with-failure-continuation</computeroutput>
	  must take three parameters.  The first, a string, is a human
	  readable message describing the error that occurred.  The
	  second is a procedure encapsulating the continuation that was
	  in place at the site of the error.  This continuation is
	  referred to as the <emphasis>error continuation</emphasis>
	  The third, the <emphasis>failure-continuation</emphasis> is
	  a procedure that when invoked calls the failure continuation
	  of the <computeroutput>call/fc</computeroutput> expression.  
	</para>
	<para>
	  When an error occurs, the error handler may choose one of
	  three courses in dealing with the error.  First, the handler
	  may choose to return an alternate value as the result of the
	  <computeroutput>call/fc</computeroutput> expression.
	  Second, the handler may restart the computation from the
	  error site by invoking the error continuation with a value
	  that should be returned in place of the expression that
	  caused the error.  Finally, the handler may choose to
	  propagate the error (or a new error) to the failure
	  continuation of the <computeroutput>call/fc</computeroutput>
	  expression.  To do this, the handler invokes the
	  failure-continuation with the provided or new message and
	  the provided error-continuation or a different continuation
	  captured by other means.
	</para>
	<para>
	  At this point, a few examples may be helpful:
	</para>
	<programlisting>
	  (+ 1 (/ 1 0) 3)
   	    ; => <emphasis>A divide by zero error is raised</emphasis>

	  ; Return a new value
	  (call-with-failure-continuation
	    (lambda ()
              (+ 1 (/ 1 0) 3))
	    (lambda (message error-k failure-k)
	      'error))     
            ; => <emphasis>The symbol</emphasis> 'error

	  ; Restart with a different value
	  (call-with-failure-continuation
  	    (lambda ()
              (+ 1 (/ 1 0) 3))
	    (lambda (message error-k failure-k)
	      (error-k 2)))
            ; => 6

	  ; Propagate the error
	  (call-with-failure-continuation
  	    (lambda ()
              (+ 1 (/ 1 0) 3))
	    (lambda (message error-k failure-k)
	      (failure-k message error-k)))
	    ; => <emphasis>A divide by zero error is raised</emphasis>
	</programlisting>
      </sect2>
    </sect1>
    <sect1>
      <title><computeroutput>dynamic-wind</computeroutput></title>
      <para>
	&R5RS; does not specify the behavior of
	<computeroutput>dynamic-wind</computeroutput> in the case
	where an error is raised somewhere in a call to the
	<emphasis>during</emphasis> thunk.  &SISC; chooses to view
	an error raised in that section as an instance of the
	dynamic extent being exited.  In other words, if an error is
	raised in the dynamic extent of a dynamic-wind expression,
	&SISC will ensure that the <emphasis>after</emphasis> thunk
	is evaluated before the error is propagated to the
	failure-continuation of the dynamic-wind expression.
      </para>
      <para>
	Here is an example:
      </para>
      <programlisting>
	(define x 0)
	(dynamic-wind (lambda () (set! x (+ x 1)))
	              (lambda () (/ 1 0))
             	      (lambda () (set! x (+ x 1))))
	; => A divide by zero error is raised, and the value of x is 2
      </programlisting>
      <para>
	If an error is raised in either the
	<emphasis>before</emphasis> or <emphasis>after</emphasis>
	thunks, no additional measures are taken.  The error is
	propagated to the failure-continuation of the dynamic-wind
	as if the dynamic-wind call was an ordinary function
	application.  Explicitly, if an error is raised from
	<emphasis>before</emphasis>, neither
	<emphasis>during</emphasis> nor <emphasis>after</emphasis>
	will be executed.  If an error is raised in
	<emphasis>after</emphasis>, the results of evaluating
	<emphasis>before</emphasis> and <emphasis>during</emphasis>
	remain valid.  
      </para>
      <para>
	Also noteworthy is what happens if a continuation is invoked
	that exits from either the <emphasis>before</emphasis> or
	<emphasis>after</emphasis> thunks.  Such a case is treated
	just as if a continuation was invoked during the evaluation
	of an operand to an application.  This is to say that no
	additional steps will be taken by &SISC;.  If
	<emphasis>before</emphasis> is escaped by a continuation invocation,
	neither <emphasis>during</emphasis> nor <emphasis>after</emphasis>
	will be executed.  If <emphasis>after</emphasis> is escaped,
	the results of <emphasis>before</emphasis> and
	<emphasis>during</emphasis> remain valid.
      </para>
      <para>
	In summary, extraordinary evaluation is only possible during
	the evaluation of the <emphasis>during</emphasis> thunk. The
	<emphasis>before</emphasis> and <emphasis>after</emphasis>
	thunks are evaluated with the dynamic environment and
	dynamic-wind stack of the call to dynamic-wind itself.
      </para>
    </sect1>
    <sect1 id="SymbolicEnvironments">
      <title>
	Symbolic Environments
      </title>
      <para>
	Symbolic environments (sometimes referred to as property lists) 
	provide additional named global environments useful for storing 
	program specific data without exposing it to the general
	purpose top-level environment.
      </para>
      <programlisting>
	&procedure; (getprop variable-name environment-name)
	&returns; a value, or &num;f if unbound

	Attempts a lookup of variable-name in the symbolic environment
	named by environment-name.  If found, the value is returned.
	If not bound, &num;f is returned.

	&procedure; (putprop variable-name environment-name value)
	&returns; undefined

	Sets the value of the variable named by variable name in the
	symbolic environment named by environment-value to the provided
	value.  Any previous value is forgotten.
      </programlisting>
      <para>
	In addition, the top-level Scheme environment is a symbolic
	environment in &SISC; that can be accessed using getprop and putprop, 
	by ommitting the <emphasis>environment-name</emphasis> parameter.  
      </para>
      <programlisting>
	&procedure; (getprop variable-name)
	&returns; a value, or &num;f if unbound

	Attempts a lookup of variable-name in the top-level environment.
	If found, the value is returned.  If not bound, &num;f is returned.

	&procedure; (putprop variable-name value)
	&returns; undefined

	Sets the value of the variable named by variable name in the
	top-level environment to the provided value.  
      </programlisting>
      <para>
	Finally, &SISC; adheres strictly to &R5RS; when it comes to
	using <computeroutput>set!</computeroutput> to modify the
	contents of a top-level variable.  If an attempt to set an
	undefined variable is made, an error will be raised.  This
	differs from some Scheme systems that will silently create the
	binding and set it to the new value.
      </para>
    </sect1>
    <sect1 id="Boxing">
      <title>
	Boxing
      </title>
      <para>
	&SISC; supports boxes, a container for a
	Scheme value. Boxing is often used to implement
	call-by-reference semantics. Boxes are created and accessed
	using the following three functions:
      </para>
      <programlisting>
	&procedure; (box value)
	&returns; a box containing the given value
	 
	Creates a box filled with the given value.

	&procedure; (unbox box)
	&returns; the value contained in the given box
	 
	Returns the contents of a box.

	&procedure; (set-box! box value)
	&returns; undefined
	 
	Replaces the value contained in the given box with a given
	value.
      </programlisting>
    </sect1>
  </chapter>
  <chapter id="LibraryFunctions">
    <title>
      &SISC; Library Functions
    </title>
    <sect1 id="Debugging">
      <title>
	Debugging
      </title>
      <para>
	&SISC; provides debugging aids that can be added to Scheme
	source code, as well as limited support for debugging without
	modification. 
      </para>
      <programlisting>
	&syntax; (trace-lambda trace-name formals body)

	When replaced with a trace-lambda, all calls to a lambda defined 
	procedure are traced on the console.  <emphasis>trace-name</emphasis> 
	is a symbol to identify the procedure in the trace. 
	<emphasis>formals </emphasis>and <emphasis>body</emphasis> have
	identical semantics to lambda.
	 
	&syntax; (trace-let loop-name formal-bindings body)
	Replaces a named-let expression in a similar manner to trace-lambda.  
	 
	&procedure; (trace-top-level-procedures symbol ...)
	&returns; undefined
	 
	Begins traces on the procedures named by the symbols given.  The procedures must be defined in the top-level environment.
	 
	&procedure; (untrace-top-level-procedures symbol ...)
	&returns; undefined
	 
	Stops tracing the top-level procedures named by the symbols given.
      </programlisting>
      <para>
	Trace-lambda and trace-let are useful for debugging anonymous
	lambdas and named-lets
	respectively. Trace-top-level-procedures can be used to trace
	calls to any procedure, including native procedures and stored
	continuations.
      </para>
    </sect1>
    <sect1 id="BitwiseLogicalOperations">
      <title>
	Bitwise Logical Operations
      </title>
      <para>
	In addition to the &R5RS; set of procedures that deal with
	numbers, &SISC; provides operators for performing bitwise
	logic operations on a limited range of integers.  The domain of the
	logical operators are exact real integers of the range
	-2,147,483,647 to 2,147,483,646 inclusive.  An error is raised
	if the logical operators are applied to integers outside this
	range, to a non-integer, or a non-real.
      </para>
      <programlisting>
	&procedure; (logand integer [integer] ...)
	&returns; The logical AND of all provided operands
	
	&procedure; (logor integer [integer] ...)
	&returns; The logical OR of all provided operands

	&procedure; (logxor integer [integer] ...)
	&returns; The logical exclusive-OR of all provided operands

	&procedure; (lognot integer)
	&returns; The logical NOT of the provided operand
      </programlisting>
      <para>
	In addition, two operators are provided to perform arithmetic
	shifts on any integer (these operators do not have the range
	limitation the previous logical functions do).  The shift
	operators return a newly generated number formed by shifting
	the provided number left or right by the given number of bits.
      </para>
      <programlisting>
	&procedure; (ashl integer bits)
	&returns; <emphasis>integer</emphasis> shifted left by <emphasis>bits</emphasis> bits.

	&procedure; (ashr integer bits)
	&returns; <emphasis>integer</emphasis> shifted right by <emphasis>bits</emphasis> bits.
      </programlisting>
      <para>
	Mathematically, if r is the number, and s is the number of
	bits, ashl calculates:
	<programlisting>
	  r x 2<superscript>s</superscript>
	</programlisting>
	while ashr calculates
	<programlisting>
	  r / 2<superscript>s</superscript>
	</programlisting>
	in the integer domain.  Both ashl and ashr operate on exact
	integers and produce only exact integers.  
      </para>
    </sect1>
    <sect1 id="OperatingSystemInterface">
      <title>
	Operating System interface
      </title>
      <para></para>
    </sect1>
  </chapter>
  <chapter id="IO">
    <title>
      I/O
    </title>
    <para>
      &SISC;'s I/O routines are implemented in a flexible manner, allowing 
      extensions to create new I/O sources that will behave as
      standard Scheme port objects.  The ports can then be operated on
      with all &R5RS; port operations, as well as some &SISC; specific 
      port functions.
    </para>
    <sect1 id="PortCreation">
      <title>
	Port creation
      </title>
      <para>&SISC; extends the &R5RS; standard's port-creation
	functions in order to provide buffered output ports.  All &SISC; 
	output ports are buffered, and a programmer may choose whether
	a given port should automatically flush after each write
	operation.  By default ports do <emphasis>not</emphasis>
	automatically flush.  Enabling auto-flush can be done when the
	port is created per the specifications below.  A port that
	does not automatically flush can be flushed at any time by
	calling <computeroutput>flush-output-port</computeroutput>.
	Finally, an output-port that does not automatically flush will
	be flushed when the port is closed with
	<computeroutput>close-output-port</computeroutput>, but may
	not be flushed if the Scheme system is exited without closing
	the port.
      </para>
      <programlisting>
	&procedure; (open-output-file file [auto-flush])
	&returns; An output port

	Creates an output port to the specified file (a string).  If
	the optional auto-flush argument is provided and is true, the
	port will automatically flush after each write call.  If the
	specified file exists, it will be overwritten silently when
	the port is opened.


	&procedure; (flush-output-port output-port)
	&returns; unspecified

	Causes the specified output-port's buffered data to be written
	immediately.  This operation is allowed on both auto-flush and
	non-auto-flush output ports, though it has no effect on the
	former.
      </programlisting>
    </sect1>
    <sect1 id="BlockIO">
      <title>
	Block I/O
      </title>
      <para>
	In addition to the standard operations on ports
	(<computeroutput>read, read-char, char-available?,
	display,</computeroutput> and
	<computeroutput>write</computeroutput>), &SISC; provides block
	input/output functions, that allow a Scheme program to read
	blocks of more than one byte or character of data at a time.
	&SISC; stores data that is read or is to be written in a string.
	Binary data in strings is fully supported throughout &SISC;.  
	Such strings may be read and written as usual, though
	undisplayable characters will often be escaped.
      </para>
      <programlisting> 
	&procedure; (block-read buffer input-port integer)
	&returns; the number of bytes read, an integer

	Reads up to <emphasis>integer</emphasis> bytes of data from
        the provided <emphasis>input-port</emphasis> into
        <emphasis>buffer</emphasis>.  Note that less than
        <emphasis>integer</emphasis> bytes may be read. 

	&procedure; (block-write buffer input-port integer)
	&returns; unspecified
 
        Writes up to <emphasis>integer</emphasis> bytes of data stored
	in <emphasis>buffer</emphasis> to the specified
	<emphasis>output-port</emphasis>.
      </programlisting>
    </sect1>
    <sect1 id="StringPorts">
      <title>
	String Ports
      </title>
      <para>
	String ports are input or output ports that read or write to a
	string rather than a file or other stream.  String ports can
	be used to parse or emit formatted strings using the standard
	Scheme port operations.  A String Input port will read from a
	given string until the end of string is reached, at which
	point <computeroutput>&num;!eof</computeroutput> is returned.  
      </para>
      <programlisting>
	&procedure; (open-input-string string)
	&returns; A string input port 
	
	Creates a string input port whose characters are read from the
	provided string.  Characters will be returned from any read
	operation on the port until the end of the string is reached.
	Read calls after reaching the end of the string will return 
	&num;!eof.

	
	&procedure; (open-output-string)
	&returns; A string output port

	Creates a string output port, which behaves as an ordinary
	output port, except that writes are used to create a string as
	output.  The results of all the write operations are retrieved
	using (get-output-string)


	&procedure; (get-output-string string-output-port)
	&returns; A string

	Returns the string that was created by zero or more writes to
	a string output port.  If no writes were performed on the
	string output port, an empty string ("") is returned.  After
	this call, the provided string output port is reset to its
	initial, empty state.
      </programlisting>
    </sect1>
    <sect1 id="PrettyPrinting">
      <title>
	Pretty-printing
      </title>
      <para>
	&SISC; includes a pretty-printer, a function that behaves like
	<computeroutput>write</computeroutput>, but introduces
	whitespace in order to make the output of data more readable
	to humans. 
	</para>
      <programlisting>
	&procedure; (pretty-print value [output-port])
	&returns; unspecified

	Pretty-prints the specified value, either to the specified
	output-port, or to the console if no output-port is
	specified. 
      </programlisting>
    </sect1>
    <sect1 id="FileSystem">
      <title>
	File-system interface
      </title>
      <para>
	&SISC; provides several additional functions that allow a
	programmer to interface to the filesystem, to obtain
	information about files or directories, and to delete, rename, 
	and modify these files and directories.
      </para>
      <para>
	This API is incomplete... please stay tuned.
      </para>
    </sect1>
    <sect1 id="netio">
      <title>
	Networking
      </title>
      <para>
	The &SISC; Networking library provides a mechanism for
	creating and manipulating IP network protocols as standard
	Scheme ports.  &SISC; supports TCP, UDP, and Multicast UDP.
	Each is described in the sections that follow.
      </para>
      <para>
	Each protocol provides one or more <emphasis>socket
	constructors</emphasis>.  These functions produce a Socket
	handle, which is represented in &SISC; as
	<computeroutput>&num;&lt;socket&gt;</computeroutput>.  A
	socket handle is then used to obtain Scheme ports.
      </para>
      <para>
	IP addresses are represented as strings in &SISC;.  Unless
	otherwise noted, the network library functions that require an
	address may take an address as a string in the dotted quad
	form ("aaa.bbb.ccc.ddd"), or as a hostname which will be
	resolved using the domain name system.  All port values must
	be integers in the proper range.
      </para>
      <sect2 id="netutils">
	<title>
	  Address functions
	</title>
	<para>
	  Several utility functions are provided for manipulating IP
	  addresses.  These are described below.
	</para>
	<programlisting>
	  &procedure; (get-host-ip-by-name string)
	  &returns; A dotted-quad IP address or &f;

	  Attempts to resolve a hostname provided as a string into an 
	  IP address in dotted-quad form.  If the host cannot be
	  found, &f; is returned.

	  
	  &procedure; (get-host-name-by-ip string)
	  &returns; A hostname or &f;

	  Attempts a reverse lookup of the given dotted-quad address
	  to determine a registered domain name.  If unsuccessful, &f;
	  is returned

	  
	  &procedure; (get-local-host)
	  &returns; The dotted-quad address of the local host 

	  Attempts to determine the Internet visible IP address of the
	  local machine.  If successful, this address is returned in
	  dotted-quad notation.  &f; is returned otherwise.
	</programlisting>
      </sect2>
      <sect2 id="sockets">
	<title>
	  Socket operations
	</title>
	<para>
	  Once obtained using a protocol specific constructor, a
	  Socket Handle allows manipulation of common socket options,
	  the creation of Scheme input/output ports, and closing of
	  the socket.
	</para>
	<programlisting>
	  &procedure; (open-socket-input-port socket)
	  &returns; an input port

	  Opens a Scheme input port to the socket.  


	  &procedure; (open-socket-output-port socket [boolean])
	  &returns; an output port

	  Opens a Scheme output port to the socket.  If provided, the
	  boolean argument specifies whether the given port should be
	  set to auto-flush mode.  If unspecified, the port does
	  <emphasis>not</emphasis> auto-flush.
	  

	  &procedure; (close-socket socket)
	  &returns; unspecified

	  Closes an IP socket.  
	</programlisting>
	<para>
	  The port-obtaining functions above work on most sockets.
	  An exception applies for  TCP server sockets, which are used only to
	  obtain connected TCP sockets.
	</para>
      </sect2>
      <sect2 id="TCP">
	<title>
	  TCP
	</title>
	<para>
	  The most commonly used Internet protocol maps most favorably
	  to Scheme's input/output model.  Writing to an output port
	  retrieved from a TCP socket writes the data to that socket.
	  Reading from an input port reads from the connected socket.
	  One important note is that one can control the amount of data
	  that fills a TCP packet by using an output port that does
	  not auto-flush.  Data is written to the port until one
	  considers the packet complete, and then uses
	  <computeroutput>(flush-output-port port)</computeroutput> to
	  complete the packet.  Note also that this does not
	  <emphasis>guarantee</emphasis> that one gets the desired
	  packet size, but does allow one to construct reasonably
	  sized packets.
	</para>
	<para>
	  TCP sockets are obtained one of two ways.  Either one
	  creates an outgoing connection to another listening host and
	  then subsequently obtains a socket handle, or one creates a
	  <emphasis>listening socket</emphasis> and then obtains a
	  socket by waiting for an incoming connection on the
	  specified port.  In either case, the result is a socket
	  handle with an available input and output port that can be
	  obtained using a function in the previous section.
	</para>
	<programlisting>
	  &procedure; (open-tcp-socket string integer)
	  &returns; A connected TCP socket

	  Attempts to connect to the host at the given hostname or IP
	  address encoded in the string, at the given TCP port
	  specified by the integer.  An error is raised if the host
	  cannot be found or the connection fails.

	  
	  &procedure; (open-tcp-listener integer [string])
	  &returns; A TCP server socket

	  Creates a TCP server socket, which may only be used with
	  accept-tcp-socket, or closed.  The server socket will listen
	  on the integer port specified.  If provided, the string
	  specifies the address of a local interface to bind to.  If
	  not provided, the port is bound on all available
	  interfaces.  An error is raised if the socket cannot be
	  bound and set listening.

	  
	  &procedure; (accept-tcp-socket server-socket)
	  &returns; A TCP socket

	  Accepts an incoming connection on the provided
	  server-socket, and returns a TCP socket handle.  This
	  function will block until an incoming connection is made,
	  or, if set, the socket timeout is exceeded.  If the latter
	  happens, an error will be raised.

	  
	  &procedure; (set-so-timeout! socket integer)
	  &returns; undefined

	  Sets the socket timeout on a socket.  The socket can be
	  either a server socket or connected socket.  In the former
	  case, this value specifies the number of milliseconds that
	  an accept-tcp-socket can wait before timing out.  In the
	  latter, the value specifies the number of milliseconds that
	  can elapse during a read call before timing out.
	</programlisting>
      </sect2>
    </sect1>
  </chapter>
  <chapter id="Threads">
    <title>
      Threads and Concurrency
    </title>
    <para>
      &SISC; provides a comprehensive library for executing Scheme
      code in parallel in multiple concurrent threads.  This allows
      code for simple code for handling blocking I/O sources (such as
      network servers) or for the ability to do parallel computation
      across multiple processors.
    </para>
    <para>
      In addition, functions are provided to ensure mutually exclusive
      access to data (mutexes), to assign priorities to Scheme
      threads, and for inter-thread signaling and synchronization.
    </para>
    <sect1>
      <title>
	Scheme Thread Semantics
      </title>
      <para>
	Care has been taken to ensure that Scheme code executing
	concurrently in two or more threads does not result in
	unpredictable behavior.  Assuming the executing threads do not
	share data, executing code in multiple threads should behave
	just as executing the code in a single thread.  
      </para>
      <para>
	All threads executing in the system share some resources.  The
	top-level and symbolic environments are shared by all
	threads.  If a thread makes a change to these environments,
	the change will be visible in all other threads.  
	unless changed by the thread, all threads share the same
	console input and output ports.  As threads originate from a
	thunk created in the primordial thread or a child thread, the
	lexical environment captured by the thunk may include some
	lexical variables from the parent thread.  These variables
	will be visible by both the parent and child threads.  The
	lexical environments created in an executing thread are
	visible by that thread only (unless that thread spawns a child
	thread whose thunk binds its parents lexicals).  
      </para>
      <para>
	Some resources can be shared but may also be distinct from
	thread to thread.  These resources are inherited from the
	parent thread, but may be changed by the child or parent
	without affecting the other.  The console input and output
	port are inherited by the parent, as is the dynamic-wind
	stack.  
      </para>
      <para>
	When a thread begins, it is considered to be isolated from its
	parent in terms of the dynamic-wind stack.  If a parent spawns
	a thread in the <emphasis>during</emphasis> section of a
	dynamic-wind call, the spawned thread
	<emphasis>escapes</emphasis> the restrictions of the
	dynamic-wind call.  This is logical, as the parent thread may
	then exit from the dynamic extent even as the child thread
	executes, or may remain there waiting for the child thread to
	finish, in which case the parent has not left the
	dynamic extent of the call.  In short, the dynamic-wind is
	protecting only the parent thread. 
      </para>
      <para>
	It is possible for more than one thread to access the same
	memory location (be it a lexical variable or a named variable
	in the top-level or a symbolic environment), it is also
	possible that interactions on shared variables can have
	unpredictable results.  As in any multi-threaded language,
	unprotected access to shared variables can result in race
	conditions and other concurrency mishaps.  If the programmer
	anticipates concurrent access to a shared variable and if
	any thread is to write to the variable, sections of code that
	access the variable should use a protection mechanism from
	<xref linkend="Monitors"/>.
      </para>
      <para>
	A thread can complete in one of two ways.  If the thunk
	that contains the thread's code exits, the thread will
	terminate and the thread handle will contain the return value
	of the thunk.  This completion condition is called a
	<emphasis>clean</emphasis> exit.  If during the execution of
	the thunk's body an error is raised, the thread will terminate
	and the thread handle will trap the error.  The error will be
	raised to any caller that attempts to retrieve the return
	value of the thread. 
      </para>
      <para>
	It is perfectly legal for a thunk to both capture and invoke
	continuations, even continuations created by other threads.
	When applying a continuation captured outside of the thread,
	the resources of the executing thread are used, though the
	thread may be accessing lexical environments created by other
	threads.  
      </para>
      <para>
	Once created, a thread can be in one of three states:
	<emphasis>ready</emphasis>, <emphasis>running</emphasis>, or
	<emphasis>finished</emphasis>.  The finished state is actually
	two states, either <emphasis>finished</emphasis>, or
	<emphasis>finished-with-error</emphasis>.  The former
	indicates that the thread is stopped and a value was returned
	from its evaluation.  The later indicates that the thread
	completed because an error was raised when evaluating its
	code.
      </para>
      <para>
	There are no guarantees that a Scheme thread will ever exit.
	It is perfectly valid for a thread to execute indefinitely.
	Also, the &SISC; environment will not exit until all threads
	have completed, either cleanly or with a failure, unless all
	remaining threads are so-called <emphasis>daemon</emphasis>
	threads.  Daemon threads are threads that may run indefinitely
	but will be forcibly terminated if no non-daemon threads (of
	which the primordial thread is one) are still running.
	Termination of a daemon thread when no non-daemon threads
	exist is the <emphasis>only</emphasis> instance where a thread
	can be forcibly terminated.  There is no thread stop or
	destroy operation.
      </para>
    </sect1>
    <sect1>
      <title>
	Basic Thread Operations
      </title>
      <para>
	This section describes the basic, low-level operations on
	threads, including how to create a thread, how to start it,
	how to wait for it to terminate, and how to retrieve it's
	result.  A thread is managed in Scheme by its <emphasis>thread
	handle</emphasis>, an opaque value that is used to identify
	the thread.  A thread handle is present as an argument to most
	of the thread library functions.
      </para>
      <para>
	Threads are created with
	<computeroutput>thread/new</computeroutput>.  This function
	takes as its sole argument a thunk.  The body of the thunk is
	the code that the thread will execute when started.  
      </para>
      <programlisting>
	&procedure (thread/new thunk)
	&returns; A thread handle

	Creates a new thread handle whose code is defined in the
	provided thunk.
      </programlisting>
      <para>
	Once a thread-handle is created, the thread is in the ready
	state, and can be started at any time by calling
	<computeroutput>thread/start</computeroutput>.  
      </para>
      <programlisting>
	&procedure (thread/start thread-handle)
	&returns; undefined

	Starts the given thread represented by thread-handle.  The
	thread must be in the ready state.  It is an error to start
	a thread in any other state.
      </programlisting>
      <para>
	Once started, the thread will be in the running state.  The
	body of the thunk is now being evaluated in parallel to the
	parent thread.  The thread will remain in the running state
	until it completes and enters one of the two finished states.
	The state can be read using
	<computeroutput>thread/state</computeroutput>.
      </para>
      <programlisting>
	&procedure; (thread/state thread-handle)
	&returns; The thread's state, one of 'ready, 'running,
	          'finished or 'finished-with-error
      </programlisting>
      <para>
	The parent thread may continue executing its own code, or may
	attempt to <emphasis>join</emphasis> the child thread.
	To join another thread is to wait until the other thread has
	completed.  The parent thread can join a child using
	<computeroutput>thread/join</computeroutput>.  The parent can
	wait indefinitely or may specify a timeout, after which the
	<computeroutput>thread/join</computeroutput> command will
	return with &num;f.
      </para>
      <programlisting>
	&procedure (thread/join thread-handle [timeout])
	&returns; &num;t if the indicated thread has completed, &num;f
	          otherwise.

	Attempts to join with the indicated thread.  If the thread
	terminates, thread/join will return &num;t.  If a timeout is
	specified, thread/join will only wait timeout milliseconds for
	the thread to complete.  If the thread does not terminate
	before the timeout, &num;f will be returned.
      </programlisting>
      <para>
	It is possible to join on an already completed thread.  In
	such a case the join will immediately return &num;t.
	The behavior of a join on a thread in the ready state is
	unspecified, and may cause an error.  Finally, it is possible
	that a join may return &num;f, even if no timeout is
	specified.  Though unlikely, programmers who wish to wait
	indefinitely for a thread to complete should check the return
	value of <computeroutput>thread/join</computeroutput> and
	repeat the join until &num;t is returned.
      </para>
      <para>
	Once a thread has completed, the parent thread may wish to
	retrieve the result of the thread's thunk, be it an error or a
	valid result.  This can be done with the
	<computeroutput>thread/result</computeroutput> function.  
      </para>
      <programlisting>
	&procedure; (thread/result thread-handle)
	&returns; A value

	Returns the return value from a completed thread.  If the
	thread completed with error, that error is raised from this
	call.
      </programlisting>
      <para>
	An error will be raised if an attempt is made to retrieve the
	result of a thread before that thread has completed.  
      </para>
    </sect1>
    <sect1>
      <title>
	High-level Functions
      </title>
      <para>
	In addition to the basic thread operations, some high level
	syntax is provided to simplify some general case thread use.
      </para>
      <programlisting>
	&syntax; (parallel thunk thunk [thunk ...])
	&returns; The return values of each thunk as multiple values

	Executes each thunk in its own thread in parallel.  The call
	to parallel blocks until all the threads have finished.  
	If all threads completed without error, the results of each
	thunk are returned as multiple values.  If any thread raised
	an error, that error is raised from the call to parallel.  The
	error is raised only after all other thunks have also
	completed.  If more than one thunk raises an error, it is
	undefined which error will be raised to the caller.
      </programlisting>
    </sect1>
    <sect1>
      <title>
	Thread Scheduling
      </title>
      <para>
	All Scheme threads created in &SISC; are preemptive and
	managed by a scheduler.  It is possible for a program to
	manage the priorities of threads in order to give execution
	preference to higher priority threads.  It is also possible
	for threads to give up their execution time to other blocked
	threads.
      </para>
      <para>
	The priority of a thread is representing by an integer.  The
	range of priorities and the default priority of a thread is
	unspecified and may be platform specific.  Larger integers
	represent higher priorities then lower integers.  If a higher 
	or lower priority thread is desired, the recommended procedure
	is to get the current priority of a thread and increment or
	decrement it.  Though unspecified, it is possible that an
	error will be raised if a priority level outside the platform
	specific range is selected.
      </para>
      <para>
	Though not guaranteed, the behavior of the scheduler when two 
	threads, one with higher priority than another are both
	runnable but only one processor is available to run a thread,
	the higher priority thread will be selected.  If only equal
	priority are available to be run, the scheduler can choose any
	thread to run.  No guarantees are made about latency or fairness.
      </para>
      <para>
	Thread priorities can be set by the parent thread or the
	thread itself.  The behavior of a child thread attempting to
	set the parent's priority, or a sibling's priority is
	undefined.
      </para>
      <programlisting>
	&procedure; (thread/priority thread-handle)
	&returns; The priority of the given thread, an integer

	Retrieves the current priority of the given thread.

	
	&procedure; (thread/priority! thread-handle new-priority)
	&returns; undefined

	Attempts to set the given thread's priority to the integer
	new-priority.
      </programlisting>
      <para>
	In addition to setting priority levels, a program may wish to
	yield its execution time temporarily to other threads.
	Performing a yield allows the scheduler to select a thread to
	run on the processor of the thread that just yielded control.
	It is possible that the yielding thread may be selected again,
	or another thread may be chosen.
      </para>
      <programlisting>
	&procedure; (thread/yield)
	&returns; unspecified

	Causes the currently executing thread to yield to other
	threads.
      </programlisting>
    </sect1>
    <sect1 id="Monitors">
      <title>
	Monitors and Synchronization
      </title>
      <para>
        &SISC; provides an implementation of the monitor data structure
        for concurrency protection and inter-thread communication.
        Monitors provide mutual exclusion locking and implicitly include
        an associated condition variable to facilitate synchronization
        of threads with the change in state of monitored data.
        Unlike simple mutexes, monitors can be re-entered by the
        thread that currently holds them.  The monitor is not unlocked
        until the holding thread has exited (unlocked) the monitor as
        many times as it was entered (locked).
      </para>
      <para>
	Throughout the following sections, a thread is often said to
	<emphasis>block</emphasis> because of some circumstance.
	While a thread is blocked on some resource, other threads are
	allowed to execute freely, at the discretion of the scheduler.
      </para>
      <para>
	Several functions exist for performing low level operations 
	such as creating a monitor.  All require a monitor object.
	Monitors are represented in scheme as opaque values displayed as
	<computeroutput>&num;&lt;monitor&gt;</computeroutput>.  To
	obtain a monitor, the
	<computeroutput>monitor/new</computeroutput> function is
	used.  It is important to understand that all the monitor
	operations depend on the same monitor being shared between any
	threads using monitor functionality.
      </para>
      <programlisting>
	&procedure; (monitor/new)
	&returns; A new monitor.
      </programlisting>
      <sect2>
        <title>
	  Lock Operations
        </title>
	<para>
	  In order to protect a segment of Scheme code from concurrent
	  access, one can create a monitor that is shared by all
	  threads that may access the segment.  When entering the
	  contested region of code (the <emphasis>critical
	  section</emphasis>), a thread would call
	  <computeroutput>monitor/lock</computeroutput>.  Upon exiting
	  the region, <computeroutput>monitor/unlock</computeroutput>
	  is called.
	</para>
	<programlisting>
	  &procedure; (monitor/lock monitor)
	  &returns; undefined 

	  Attempts to acquire the lock on the given monitor.  Returns
	  only when the lock has been successfully acquired.

	  
	  &procedure; (monitor/unlock monitor)
	  &returns; undefined
	  
	  Releases the lock on the given monitor.  The behavior when
	  unlocking a monitor when the running thread does not have
	  the lock is undefined, and may raise an error.
	</programlisting>
	<para> 
	  The semantics of
	  <computeroutput>monitor/lock</computeroutput> ensure that
	  only one thread can execute beyond the lock call at any one
	  time.  The first thread that reaches the call
	  <emphasis>acquires</emphasis> the lock on the monitor.  Any
	  later threads will block at the call to
	  <computeroutput>monitor/lock</computeroutput> until the
	  thread that owns the lock releases the lock with
	  <computeroutput>monitor/unlock</computeroutput>.  
	</para>
      </sect2>
      <sect2>
	<title>
	  Condition Variable Operations
	</title>
	<para>
	  In addition to locking functionality, a monitor also
	  has an implicitly associated <emphasis>condition
	  variable</emphasis>.  A condition variable allows one thread
	  to sleep until another wakes it.  A common situation is for
	  one thread to check the status of a variable, and sleep if
	  the <emphasis>condition</emphasis> is not met.  While the
	  thread sleeps, one or more separate threads may execute and
	  satisfy the condition (by changing the state of the
	  variable) and then <emphasis>notify</emphasis> the sleeping
	  thread.  The thread then awakes, checks the variable, and
	  proceeds if the condition is met.  If not, it sleeps again.  
	  This construct allows for cooperate between multiple threads
	  on a computation.
	</para>
	<para>
	  To wait on a monitor, the
	  <computeroutput>monitor/wait</computeroutput> function is
	  applied to a monitor.  This will cause the thread to block
	  until notified by another thread.
	</para>
	<programlisting>
	  &procedure; (monitor/wait monitor [timeout])
	  &returns; undefined

	  Causes the thread to sleep until notified by another
	  thread.  This call will not return until notified, unless
	  the optional timeout is specified and timeout milliseconds 
	  have elapsed without a notification. 
	</programlisting>
	<para>
	  Another thread may wake a single waiting thread with the
	  <computeroutput>monitor/notify</computeroutput> operation.
	  When called, one thread waiting on the monitor is
	  woken.  If no threads are waiting this call has no effect.
	  If more than one thread is waiting, exactly one will
	  be woken.  Which is woken is unspecified.  If a thread
	  wishes to wake <emphasis>all</emphasis> threads waiting on a
	  given monitor, it may use the
	  <computeroutput>monitor/notify-all</computeroutput> function.
	</para>
	<programlisting>
	  &procedure; (monitor/notify monitor)
	  &returns; undefined

	  Wakes exactly one thread waiting on the monitor, if any such
	  threads exist.

	  
	  &procedure (monitor/notify-all monitor)
	  &returns; undefined
	  
	  Wakes all threads waiting on the monitor, if any waiting
	  threads exist.
	</programlisting>
      </sect2>
      <sect2>
	<title>
	  High-level Concurrency
	</title>
	<para>
	  In addition to the low-level operations on monitors, two
	  library functions are provided to greatly ease the
	  construction and readability of thread-safe code.
	</para>
	<programlisting>
	  &syntax; (monitor/synchronize monitor expression)
	  
	  Protects expression as a critical section by safely locking
	  access to the expression with the monitor.

	  
	  &syntax; (monitor/synchronize-unsafe monitor expression)
	  
	  Behaves exactly as monitor/synchronize without automatic 
	  unlocking when an error is raised from or a continuation 
	  escapes from expression.
	</programlisting>
	<para>
	  <computeroutput>monitor/synchronize</computeroutput> locks
	  the monitor while the expression provided is being
	  executed.  The lock is automatically released when the
	  expression has completed.  Also, if an error is raised or a
	  continuation is invoked that escapes the call to
	  <computeroutput>monitor/synchronize</computeroutput>, the
	  lock is automatically released.
	</para>
	<para>
	  The added safety provided by 
	  <computeroutput>monitor/synchronize</computeroutput> may
	  slow the execution of code that repeatedly calls a critical
	  section.  If the programmer is absolutely sure that no error
	  can be raised and that no continuations will be applied to
	  escape the call,
	  <computeroutput>monitor/synchronize-unsafe</computeroutput>
	  may be used.  It provides no safety guarantees in those
	  situations.  If an error is raised or an escaping
	  continuation invoked, the monitor will remain locked which
	  could cause a deadlock if another thread attempts to acquire
	  the lock.  
	</para>
      </sect2>
    </sect1>
  </chapter>
  <chapter>
    <title>
      The Module System
    </title>
    <para>
      The Module system consists of two components. The first is the
      module syntax extension provided by R. Kent Dybvig's syntax
      expander &lsqb;REF&rsqb;. This level provides the ability to
      scope Scheme code into importable modules with selectable
      exports. 
    </para>
    <para>
      The second is the Java level &SISC; API for
      native extensions to the language. A &SISC;
      module defines new types and functions. Each
      &SISC; module can be queried from Scheme, and
      imported into the runtime environment as a whole, or packaged
      via the same export mechanism as native Scheme code.
    </para>
  </chapter>
  <chapter id="javainteraction">
    <title>
      Java Interaction
    </title>
    <para>
      &SISC; can be used as a scripting language
      for Java, or Java may be used to provide functionality to
      Scheme. Such activity is collectively termed 'bridging'. &SISC;
      provides an API that may be called from Java to execute Scheme
      code or evaluate Scheme expressions. In addition, the J2S module
      provides Scheme level control of Java objects, methods, and
      fields. Finally, the two can be combined in a number of complex
      ways to intertwine the two languages.
    </para>
    <sect1 id="JavaToScheme">
      <title>
	Java to Scheme call API
      </title>
      <para></para>
      <sect2 id="JErrorHandling">
	<title>
	  Error Handling
	</title>
	<para></para>
      </sect2>
      <sect2 id="JContinuations">
	<title>
	  Continuations
	</title>
	<para></para>
      </sect2>
    </sect1>
    <sect1 id="SchemeToJava">
      <title>
	Scheme level Java manipulation
      </title>
      <para></para>
    </sect1>
  </chapter>
  <appendix id="Errata">
    <title>Errata</title>
    <para>
      This appendix describes where this manual and the implementation
      of SISC depart.  This section should remain small, as it is the
      goal of the Interpreter to conform to this document, not for
      this document to describe the idiosyncrasies of the Interpreter.
    </para>
    <para>
      <orderedlist>
	<listitem>
	  <para>
	    (<xref linkend="Characters"/> and <xref
	    linkend="Strings"/>) Characters  and strings are not
	    compared according to locale rules (bug &num;493773)
	  </para>
	</listitem>
	<listitem>
	  <para>
	    (<xref linkend="Debugging"/>) The debugging functions
	     functions <computeroutput>trace</computeroutput> and
	    <computeroutput>untrace</computeroutput> are not yet
	    implemented.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    (<xref linkend="PortCreation"/>) The optional boolean
	    argument in the creation of output ports that specifies
	    auto-flush behavior is only present on net network port
	    creation functions.  File ports are missing this
	    functionality.  
	  </para>
	</listitem>
      </orderedlist>
    </para>
  </appendix>
  &gfdl;
  <index id="functions">
    <title>Index of Functions</title>
    <para>
    </para>
  </index>
</book>
